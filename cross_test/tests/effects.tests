=== Algebraic Effects Tests ===

--- test: basic effect handle return
effect Greeting =
  greet : unit -> string
end
handle
  42
with
| return x -> x
--- expect: 42

--- test: perform and handle
effect Ask =
  ask : unit -> string
end
handle
  perform ask ()
with
| return x -> x
| ask () k -> resume k "hello"
--- expect: hello

--- test: continue with value
effect Val =
  get_val : unit -> int
end
handle
  let x = perform get_val () in
  x + 1
with
| return x -> x
| get_val () k -> resume k 10
--- expect: 11

--- test: multiple performs
effect Val =
  get_val : int -> int
end
handle
  let a = perform get_val 1 in
  let b = perform get_val 2 in
  a + b
with
| return x -> x
| get_val n k -> resume k (n + 10)
--- expect: 23

--- test: state effect get/put
effect State =
  get : unit -> int
  put : int -> unit
end
handle
  let x = perform get () in
  perform put (x + 1);
  perform get ()
with
| return x -> x
| get () k -> resume k 10
| put v k -> resume k ()
--- expect: 10

--- test: handler without continue
effect Abort =
  abort : int -> unit
end
handle
  perform abort 42;
  0
with
| return x -> x
| abort v k -> v
--- expect: 42

--- test: nested handles
effect Inner =
  inner_op : unit -> int
end
effect Outer =
  outer_op : unit -> int
end
handle
  handle
    let a = perform inner_op () in
    let b = perform outer_op () in
    a + b
  with
  | return x -> x
  | inner_op () k -> resume k 10
with
| return x -> x
| outer_op () k -> resume k 20
--- expect: 30

--- test: continue result
effect Eff =
  op : unit -> int
end
handle
  perform op ()
with
| return x -> x + 100
| op () k -> resume k 42
--- expect: 142

--- test: unhandled effect error
effect Unhandled =
  boom : unit -> int
end
perform boom ()
--- expect-type-error

--- test: one-shot continuation error
effect Eff =
  op : unit -> int
end
handle
  perform op ()
with
| return x -> x
| op () k ->
  let _ = resume k 1 in
  resume k 2
--- expect-runtime-error: already resumed

--- test: effect with computed arg
effect Math =
  double : int -> int
end
handle
  perform double (3 + 4)
with
| return x -> x
| double n k -> resume k (n * 2)
--- expect: 14

--- test: copy continuation multi-shot
let rec append xs ys = match xs with
  | [] -> ys
  | x :: rest -> x :: append rest ys
effect Choice =
  choose : unit -> bool
end
handle
  let x = perform choose () in
  let y = perform choose () in
  if x && y do 1 else 0
with
| return x -> [x]
| choose () k ->
  let k2 = copy_continuation k in
  let a = resume k true in
  let b = resume k2 false in
  append a b
--- expect: [1; 0; 0; 0]

--- test: copy continuation simple
let rec append xs ys = match xs with
  | [] -> ys
  | x :: rest -> x :: append rest ys
effect Pick =
  pick : unit -> int
end
handle
  perform pick ()
with
| return x -> [x]
| pick () k ->
  let k2 = copy_continuation k in
  let a = resume k 1 in
  let b = resume k2 2 in
  append a b
--- expect: [1; 2]

=== Try/With Tests ===

--- test: try/with basic return
effect Exn =
  raise : string -> 'a
end
try 42 with
| raise msg -> 0
--- expect: 42

--- test: try/with catch exception
effect Exn =
  raise : string -> 'a
end
try
  perform raise "oops"
with
| raise msg -> msg
--- expect: oops

--- test: try/with no continuation
effect Exn =
  raise : string -> 'a
end
try
  let x = 10 in
  if x > 5 do perform raise "too big"
  else x
with
| raise msg -> 0
--- expect: 0

--- test: try/with multiple operations
effect IO =
  file_not_found : string -> 'a
end
effect Validation =
  invalid_input : string -> 'a
end
try
  perform invalid_input "bad data"
with
| file_not_found path -> "missing: " ^ path
| invalid_input msg -> "invalid: " ^ msg
--- expect: invalid: bad data

--- test: try/with value passes through
effect Exn =
  raise : string -> 'a
end
try "hello" with
| raise msg -> "caught"
--- expect: hello

--- test: try/with unit arg
effect Exn =
  fail : unit -> 'a
end
try
  perform fail ()
with
| fail () -> 99
--- expect: 99

=== Effect Typing Tests ===

--- test: unhandled effect at top level
effect MyEff =
  my_op : unit -> int
end
perform my_op ()
--- expect-type-error

--- test: handled effect at top level
effect MyEff =
  my_op : unit -> int
end
handle
  perform my_op ()
with
| return x -> x
| my_op () k -> resume k 42
--- expect: 42

--- test: effectful function handled by caller
effect Ask =
  ask : unit -> int
end
let f () = perform ask () + 1
handle
  f ()
with
| return x -> x
| ask () k -> resume k 10
--- expect: 11

--- test: multiple effects partial handle
effect E1 =
  op1 : unit -> int
end
effect E2 =
  op2 : unit -> int
end
handle
  handle
    perform op1 () + perform op2 ()
  with
  | return x -> x
  | op1 () k -> resume k 10
with
| return x -> x
| op2 () k -> resume k 20
--- expect: 30

--- test: nested handlers
effect Outer =
  get_outer : unit -> int
end
effect Inner =
  get_inner : unit -> int
end
handle
  handle
    perform get_outer () + perform get_inner ()
  with
  | return x -> x
  | get_inner () k -> resume k 5
with
| return x -> x
| get_outer () k -> resume k 10
--- expect: 15

--- test: effectful callback in higher-order function
effect Counter =
  inc : unit -> unit
end
let apply f x = f x
handle
  let mut n = 0 in
  apply (fn x -> perform inc (); x + 1) 10;
  n
with
| return x -> x
| inc () k -> resume k ()
--- expect: 0

--- test: for loop break with effect tracking
let mut sum = 0 in
for x in [1; 2; 3; 4; 5] do
  if x > 3 do break
  else sum := sum + x
end;
sum
--- expect: 6

--- test: handler produces pure result
effect Tick =
  tick : unit -> unit
end
let result = handle
  perform tick ();
  perform tick ();
  42
with
| return x -> x
| tick () k -> resume k ()
in
result + 1
--- expect: 43

--- test: constrained fn performs effect
effect Log =
  log : string -> unit
end
let show_and_log (x: 'a) : string where Show 'a =
  let s = show x in
  perform log s;
  s
;;
handle
  show_and_log 42
with
| return x -> x
| log msg k -> resume k ()
--- expect: 42

--- test: multi-constraint fn with effect
effect Acc =
  add : int -> unit
end
let process (x: 'a) (y: 'a) : unit where Show 'a, Eq 'a =
  if x = y do perform add 1
  else perform add 2
;;
let mut total = 0 in
handle
  process 3 3;
  process 1 2;
  total
with
| return x -> x
| add n k -> total := total + n; resume k ()
--- expect: 3

--- test: typeclass method in effectful context
effect Collect =
  emit : string -> unit
end
let show_emit (x: 'a) : unit where Show 'a =
  perform emit (show x)
;;
let mut buf = "" in
handle
  show_emit 1;
  show_emit true;
  show_emit "hi"
with
| return _ -> buf
| emit s k -> buf := buf ^ s ^ ","; resume k ()
--- expect: 1,true,hi,

--- test: List.map with effectful callback
effect Counter =
  inc : unit -> unit
end
let mut count = 0 in
handle
  let result = List.map (fn x -> perform inc (); x * 2) [1; 2; 3] in
  List.fold (fn a b -> a + b) 0 result
with
| return x -> x + count
| inc () k -> count := count + 1; resume k ()
--- expect: 15

--- test: List.filter with effectful predicate
effect Log =
  log : int -> unit
end
let mut logged = 0 in
handle
  let evens = List.filter (fn x -> do
    perform log x;
    x mod 2 = 0
  end) [1; 2; 3; 4; 5] in
  List.length evens
with
| return x -> x * 100 + logged
| log n k -> logged := logged + n; resume k ()
--- expect: 215

--- test: nested HOFs with effects
effect Track =
  hit : unit -> unit
end
let mut hits = 0 in
handle
  let xs = [1; 2; 3; 4] in
  let doubled = List.map (fn x -> perform hit (); x * 2) xs in
  let big = List.filter (fn x -> perform hit (); x > 4) doubled in
  List.fold (fn a b -> a + b) 0 big
with
| return x -> x + hits
| hit () k -> hits := hits + 1; resume k ()
--- expect: 22

--- test: fold with effectful accumulator fn
effect Notify =
  notify : int -> unit
end
let mut notifications = 0 in
handle
  List.fold (fn acc x -> do
    (if x > 2 do perform notify x else ());
    acc + x
  end) 0 [1; 2; 3; 4; 5]
with
| return x -> x + notifications
| notify n k -> notifications := notifications + n; resume k ()
--- expect: 27

--- test: closure captures effect and called in handler
effect State =
  get : unit -> int
  put : int -> unit
end
let make_adder n = fn () ->
  let cur = perform get () in
  perform put (cur + n)
let add3 = make_adder 3 in
let add7 = make_adder 7 in
let mut st = 0 in
handle
  add3 ();
  add7 ();
  add3 ();
  perform get ()
with
| return x -> x
| get () k -> resume k st
| put n k -> st := n; resume k ()
--- expect: 13

--- test: HOF returns effectful closure
effect E =
  op : int -> int
end
let wrap f = fn x -> perform op (f x)
let double = wrap (fn x -> x * 2)
handle
  double 5 + double 3
with
| return x -> x
| op n k -> resume k (n + 1)
--- expect: 18

--- test: effects through pipe
effect Tap =
  tap : int -> unit
end
let mut tapped = 0 in
handle
  [1; 2; 3; 4; 5]
    |> List.map (fn x -> perform tap x; x * x)
    |> List.filter (fn x -> x > 5)
    |> List.fold (fn a b -> a + b) 0
with
| return x -> x + tapped
| tap n k -> tapped := tapped + n; resume k ()
--- expect: 65

--- test: effect in match arms
effect Log =
  log : string -> unit
end
type shape = Circle of int | Rect of int * int
let describe s =
  match s with
  | Circle r -> perform log "circle"; r * r
  | Rect (w, h) -> perform log "rect"; w * h
let mut msgs = "" in
handle
  describe (Circle 5) + describe (Rect (3, 4))
with
| return x -> x
| log s k -> msgs := msgs ^ s; resume k ()
--- expect: 37

--- test: mutual recursion with effects
effect Ping =
  ping : int -> unit
end
let mut pings = 0 in
let rec is_even n =
  if n = 0 do true
  else (perform ping n; is_odd (n - 1))
and is_odd n =
  if n = 0 do false
  else (perform ping n; is_even (n - 1))
in
handle
  if is_even 6 do 1 else 0
with
| return x -> x + pings
| ping n k -> pings := pings + 1; resume k ()
--- expect: 7

--- test: handler transforms result
effect Choose =
  choose : unit -> bool
end
let pick_path () =
  if perform choose () do 10 else 20
handle
  pick_path () + pick_path ()
with
| return x -> x
| choose () k ->
  let a = resume k true in
  a
--- expect: 20

--- test: layered handlers different effects
effect A =
  op_a : unit -> int
end
effect B =
  op_b : unit -> int
end
let f () =
  let a = perform op_a () in
  let b = perform op_b () in
  a + b
handle
  handle
    f ()
  with
  | return x -> x
  | op_a () k -> resume k 100
with
| return x -> x
| op_b () k -> resume k 7
--- expect: 107

--- test: handler inside for loop
effect Fail =
  fail : unit -> int
end
let safe_div a b =
  handle
    if b = 0 do perform fail ()
    else a / b
  with
  | return x -> x
  | fail () k -> resume k (0 - 1)
;;
let mut sum = 0 in
for b in [2; 0; 3; 0; 5] do
  sum := sum + safe_div 30 b
end;
sum
--- expect: 29

--- test: record with effectful function field
effect Log =
  log : string -> unit
end
let make_logger name = {
  info = fn msg -> perform log (name ^ ": " ^ msg);
  name = name
}
let lgr = make_logger "test"
let mut logged = "" in
handle
  lgr.info "hello";
  lgr.info "world";
  42
with
| return x -> x
| log s k -> logged := logged ^ s ^ ";"; resume k ()
--- expect: 42

--- test: effect inside for loop
effect Count =
  count : unit -> unit
end
handle
  for x in [1; 2; 3; 4; 5] with acc = 0 do
    perform count ();
    acc + 1
  end
with
| return x -> x
| count () k -> resume k ()
--- expect: 5

--- test: effect inside fold-for loop
effect Tap =
  tap : int -> unit
end
let mut tapped = 0 in
handle
  for x in [10; 20; 30] with acc = 0 do
    perform tap x;
    acc + x
  end
with
| return x -> x + tapped
| tap n k -> tapped := tapped + n; resume k ()
--- expect: 120

--- test: compose effectful functions
effect E =
  op : int -> int
end
let compose f g = fn x -> f (g x)
let double x = perform op (x * 2)
let inc x = perform op (x + 1)
let double_then_inc = compose inc double
handle
  double_then_inc 5
with
| return x -> x
| op n k -> resume k n
--- expect: 11

--- test: apply function n times with effects
effect Step =
  step : int -> int
end
let rec apply_n f n x =
  if n = 0 do x
  else apply_n f (n - 1) (f x)
in
handle
  apply_n (fn x -> perform step (x + 1)) 5 0
with
| return x -> x
| step n k -> resume k n
--- expect: 5

--- test: effectful let binding in handler
effect Gen =
  next : unit -> int
end
let mut counter = 0 in
handle
  let a = perform next () in
  let b = perform next () in
  let c = perform next () in
  a + b + c
with
| return x -> x
| next () k -> counter := counter + 1; resume k counter
--- expect: 6

--- test: unit effect in sequence
effect Log =
  log : string -> unit
end
let mut count = 0 in
handle
  perform log "a";
  perform log "b";
  perform log "c";
  99
with
| return x -> x + count
| log _ k -> count := count + 1; resume k ()
--- expect: 102

--- test: Seq with effects
effect E =
  observe : int -> unit
end
let mut observed = 0 in
handle
  Seq.range 1 4
    |> Seq.map (fn x -> perform observe x; x * x)
    |> Seq.fold (fn a b -> a + b) 0
with
| return x -> x + observed
| observe n k -> observed := observed + n; resume k ()
--- expect: 20

=== Perform Parsing Tests ===

--- test: perform with field access no parens
effect E = put : int -> unit end
let mut received = 0 in
handle
  let r = { x = 42; y = 10 } in
  perform put r.x;
  received
with
| return x -> x
| put v k -> received := v; resume k ()
--- expect: 42

--- test: perform with chained field access
effect E = send : int -> unit end
let mut received = 0 in
handle
  let r = { inner = { val_ = 99 } } in
  perform send r.inner.val_;
  received
with
| return x -> x
| send v k -> received := v; resume k ()
--- expect: 99

--- test: perform with indexing
effect E = send : int -> unit end
let mut received = 0 in
handle
  let arr = #[10; 20; 30] in
  perform send arr.[1];
  received
with
| return x -> x
| send v k -> received := v; resume k ()
--- expect: 20

=== Continuation Type Error Tests ===

--- test: direct continuation application rejected
effect Boom = boom : unit -> int end
handle perform boom () with
| return x -> x
| boom () k -> k 10
--- expect-type-error

--- test: continuation passed to higher-order function rejected
effect Ask = ask : unit -> int end
handle perform ask () with
| return x -> x
| ask () k -> (fn f -> f 42) k
--- expect-type-error

--- test: resume with continuation still works
effect Val = get_val : unit -> int end
let r = handle
  perform get_val () + 1
with
| return x -> x
| get_val () k -> resume k 10
in print (string_of_int r)
--- expect: 11

--- test: deep recursion with effects (stack safety)
effect Counter =
  tick : unit -> unit
end
handle
  let rec loop n =
    if n <= 0 do ()
    else (perform tick (); loop (n - 1))
  in
  loop 5000;
  "done"
with
| return x -> x
| tick () k -> resume k ()
--- expect: done

=== Simple Handler Optimization Tests ===

--- test: simple handler inline performs
effect Val = get : unit -> int end
handle
  perform get () + perform get () + 1
with
| return x -> x
| get () k -> resume k 10
--- expect: 21

--- test: simple handler with mutation
effect Counter = inc : unit -> unit end
let mut count = 0 in
handle
  perform inc ();
  perform inc ();
  perform inc ();
  count
with
| return x -> x
| inc () k -> count := count + 1; resume k ()
--- expect: 3

--- test: simple handler with return arm
effect Val = get : unit -> int end
handle
  perform get ()
with
| return x -> x + 100
| get () k -> resume k 42
--- expect: 142

--- test: simple handler multi-op state
effect State =
  get : unit -> int
  put : int -> unit
end
let mut st = 0 in
handle
  perform put 10;
  let x = perform get () in
  perform put (x + 5);
  perform get ()
with
| return x -> x
| get () k -> resume k st
| put v k -> st := v; resume k ()
--- expect: 15

--- test: simple handler called function uses CPS wrapper
effect Ask = ask : unit -> int end
let f () = perform ask () * 2
handle
  f () + 1
with
| return x -> x
| ask () k -> resume k 21
--- expect: 43

--- test: mixed simple and non-simple ops
effect E =
  get : unit -> int
  choose : unit -> bool
end
handle
  let x = perform get () in
  let b = perform choose () in
  if b do x else 0
with
| return x -> x
| get () k -> resume k 42
| choose () k ->
  let a = resume k true in
  a
--- expect: 42

=== Try/With Optimization Tests ===

--- test: try/with basic catch
effect Exn = fail : string -> int end
try
  perform fail "error"
with
| fail msg -> 42
--- expect: 42

--- test: try/with no exception
effect Exn = fail : string -> int end
try
  10 + 20
with
| fail msg -> 0
--- expect: 30

--- test: try/with called function throws
effect Exn = fail : unit -> int end
let boom () = perform fail ()
try
  boom () + 1
with
| fail () -> 99
--- expect: 99

--- test: try/with multiple ops
effect IO =
  not_found : string -> int
  perm_denied : string -> int
end
try
  perform perm_denied "secret"
with
| not_found path -> 1
| perm_denied path -> 2
--- expect: 2

--- test: nested try/with and simple handler
effect Exn = fail : unit -> int end
effect Val = get : unit -> int end
try
  handle
    perform get () + 1
  with
  | return x -> x
  | get () k -> resume k 42
with
| fail () -> 0
--- expect: 43

--- test: try/with recursive function throws
effect Exn = fail : string -> int end
let rec check n =
  if n <= 0 do perform fail "done"
  else check (n - 1)
try
  check 50
with
| fail msg -> 100
--- expect: 100

--- test: recursive non-tail call inside handle with effects
effect Trace =
  trace : string -> unit
end
let rec eval n =
  if n <= 0 do 0
  else
    let a = eval (n - 1) in
    perform trace "step";
    a + n
in
let mut log = 0 in
handle
  eval 5
with
| return x -> (x, log)
| trace _ k ->
  log := log + 1;
  resume k ()
--- expect: (15, 5)

--- test: recursive non-tail call with nested effects and multiple bindings
effect Counter =
  inc : unit -> int
end
let rec tree_sum depth =
  if depth <= 0 do
    perform inc ()
  else
    let left = tree_sum (depth - 1) in
    let right = tree_sum (depth - 1) in
    left + right
in
let mut count = 0 in
handle
  tree_sum 3
with
| return x -> (x, count)
| inc () k ->
  count := count + 1;
  resume k count
--- expect: (36, 8)

--- test: handler classification - tail-resumptive provide pattern
effect Config = get_db : unit -> string; get_port : unit -> int end
handle
  let db = perform get_db () in
  let port = perform get_port () in
  db ^ ":" ^ show port
with
| return x -> x
| get_db () k -> resume k "localhost"
| get_port () k -> resume k 8080
--- expect: localhost:8080

--- test: handler classification - non-resuming try pattern
effect Fail = fail : string -> 'a end
try
  let x = 10 in
  if x > 5 do perform fail "too big" else x
with
| fail msg -> -1
--- expect: -1

--- test: handler classification - mixed provide and full arms
effect Mixed = get_val : unit -> int; choose : unit -> bool end
handle
  let v = perform get_val () in
  if perform choose () do v * 2 else v
with
| return x -> x
| get_val () k -> resume k 21
| choose () k -> resume k true
--- expect: 42

--- test: handler classification - provide with branching resume
effect Lookup = lookup : string -> int end
handle
  perform lookup "a" + perform lookup "b"
with
| return x -> x
| lookup key k ->
  if key = "a" do resume k 10
  else resume k 20
--- expect: 30

--- test: handler classification - provide with let in body
effect Env = get : unit -> int end
handle
  let x = perform get () in
  x * x
with
| return x -> x
| get () k ->
  let v = 7 in
  resume k v
--- expect: 49

=== Provide/With Tests ===

--- test: provide basic value
effect Env = get_name : unit -> string end
provide
  perform get_name ()
with
| get_name () -> "world"
--- expect: world

--- test: provide with argument
effect Config = get : string -> int end
provide
  perform get "port"
with
| get key -> if key = "port" do 8080 else 0
--- expect: 8080

--- test: provide multiple operations
effect DB = host : unit -> string; port : unit -> int end
provide
  perform host () ^ ":" ^ show (perform port ())
with
| host () -> "localhost"
| port () -> 5432
--- expect: localhost:5432

--- test: provide nested different effects
effect Outer = get_outer : unit -> string end
effect Inner = get_inner : unit -> string end
provide
  let a = perform get_outer () in
  let b = provide perform get_inner () with
    | get_inner () -> "red"
  in
  (a, b)
with
| get_outer () -> "blue"
--- expect: (blue, red)

--- test: provide nested same effect
effect Theme = color : unit -> string end
provide
  let outer = perform color () in
  let inner = provide perform color () with
    | color () -> "red"
  in
  (outer, inner)
with
| color () -> "blue"
--- expect: (blue, red)

--- test: nested handle same effect
effect Val = get : unit -> int end
handle
  let a = perform get () in
  let b = handle perform get () with
    | return x -> x
    | get () k -> resume k 99
  in
  (a, b)
with
| return x -> x
| get () k -> resume k 42
--- expect: (42, 99)

--- test: inner full handler shadows outer provide
effect E = get : unit -> int end
provide
  handle
    perform get ()
  with
  | return x -> x
  | get () k -> resume k 99
with
| get () -> 42
--- expect: 99

--- test: inner try handler shadows outer provide
effect E = get : unit -> int end
provide
  try perform get () with
  | get () -> 99
with
| get () -> 42
--- expect: 99

--- test: triple nesting same effect
effect E = get : unit -> int end
provide
  let a = perform get () in
  let b = provide
    let x = perform get () in
    let y = provide perform get () with
      | get () -> 3
    in
    (x, y)
  with
  | get () -> 2
  in
  (a, b)
with
| get () -> 1
--- expect: (1, (2, 3))

--- test: provide with computation in arm
effect Lookup = find : string -> int end
provide
  perform find "a" + perform find "b"
with
| find key ->
  if key = "a" do 1 else 2
--- expect: 3

--- test: provide side-effecting unit operation
effect Logger = log : string -> unit end
let mut msgs = [] in
provide
  perform log "hello";
  perform log "world";
  msgs
with
| log msg -> msgs := msg :: msgs
--- expect: [world; hello]

--- test: provide with try inside
effect Ctx = get_user : unit -> string end
effect Fail = fail : string -> 'a end
provide
  try
    let u = perform get_user () in
    if u = "admin" do perform fail "nope" else u
  with
  | fail msg -> "fallback"
with
| get_user () -> "admin"
--- expect: fallback

--- test: provide is classified as THOpProvide
--- provide arms should get the tail-resumptive optimization
effect Counter = next : unit -> int end
let mut n = 0 in
provide
  let a = perform next () in
  let b = perform next () in
  let c = perform next () in
  (a, b, c)
with
| next () -> n := n + 1; n
--- expect: (1, 2, 3)

=== Unit/Wildcard Elision Tests ===

--- test: perform unit elision
effect E = get_val : unit -> int end
handle
  perform get_val + 1
with
| return x -> x
| get_val () k -> resume k 42
--- expect: 43

--- test: perform unit elision in sequence
effect Logger = log : string -> unit end
let mut count = 0 in
handle
  perform log "a";
  perform log "b";
  count
with
| return x -> x
| log _ k -> count := count + 1; resume k ()
--- expect: 2

--- test: perform unit elision in let binding
effect E = get : unit -> int end
handle
  let x = perform get in
  x * 2
with
| return x -> x
| get () k -> resume k 21
--- expect: 42

--- test: perform unit elision parenthesized
effect E = get : unit -> int end
handle
  (perform get) + 1
with
| return x -> x
| get () k -> resume k 10
--- expect: 11

--- test: perform with arg still works
effect E = double : int -> int end
handle
  perform double 5
with
| return x -> x
| double n k -> resume k (n * 2)
--- expect: 10

--- test: try/with wildcard arm elision
effect Fail = fail : string -> 'a end
try
  perform fail "oops"
with
| fail -> "caught"
--- expect: caught

--- test: try/with wildcard elision unit effect
effect Boom = boom : unit -> 'a end
try
  perform boom;
  "unreachable"
with
| boom -> "caught"
--- expect: caught

--- test: try/with wildcard elision with explicit arg still works
effect Fail = fail : string -> 'a end
try
  perform fail "hello"
with
| fail msg -> msg
--- expect: hello

--- test: provide wildcard arm elision
effect E = get_name : unit -> string end
provide
  perform get_name
with
| get_name -> "world"
--- expect: world

--- test: provide wildcard elision non-unit effect
effect E = check : string -> bool end
provide
  perform check "admin"
with
| check -> true
--- expect: true

--- test: provide wildcard elision with explicit arg still works
effect E = get : string -> int end
provide
  perform get "port"
with
| get key -> if key = "port" do 8080 else 0
--- expect: 8080

--- test: handle wildcard elision no arg no k
effect E = get : unit -> int end
handle
  perform get
with
| return x -> x
| get -> resume __k 42
--- expect: 42

--- test: handle wildcard elision one ident is k
effect E = get : unit -> int end
handle
  perform get
with
| return x -> x
| get k -> resume k 42
--- expect: 42

--- test: handle wildcard elision non-unit effect
effect E = check : string -> unit end
handle
  perform check "test";
  "done"
with
| return x -> x
| check k -> resume k ()
--- expect: done

--- test: handle unit-paren then arrow elision
effect E = get : unit -> int end
handle
  perform get
with
| return x -> x
| get () -> resume __k 99
--- expect: 99

--- test: handle explicit arg and k still works
effect E = double : int -> int end
handle
  perform double 5
with
| return x -> x
| double n k -> resume k (n * 2)
--- expect: 10

--- test: mixed elision in multi-arm handler
effect E =
  get : unit -> int
  check : string -> bool
  put : int -> unit
end
let mut st = 0 in
handle
  let v = perform get in
  if perform check "go" do
    perform put (v + 1);
    perform get
  else v
with
| return x -> x
| get k -> resume k st
| check k -> resume k true
| put v k -> st := v; resume k ()
--- expect: 1

--- test: elision in provide with multiple ops
effect DB = host : unit -> string; port : unit -> int end
provide
  perform host ^ ":" ^ show (perform port)
with
| host -> "localhost"
| port -> 5432
--- expect: localhost:5432

--- test: elision in try with multiple ops
effect IO =
  not_found : string -> 'a
  timeout : unit -> 'a
end
try
  perform timeout;
  "ok"
with
| not_found -> "missing"
| timeout -> "timed out"
--- expect: timed out
