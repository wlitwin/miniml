=== Algebraic Effects Tests ===

--- test: basic effect handle return
effect Greeting =
  greet : unit -> string
end
handle
  42
with
| return x -> x
--- expect: 42

--- test: perform and handle
effect Ask =
  ask : unit -> string
end
handle
  perform ask ()
with
| return x -> x
| ask () k -> resume k "hello"
--- expect: hello

--- test: continue with value
effect Val =
  get_val : unit -> int
end
handle
  let x = perform get_val () in
  x + 1
with
| return x -> x
| get_val () k -> resume k 10
--- expect: 11

--- test: multiple performs
effect Val =
  get_val : int -> int
end
handle
  let a = perform get_val 1 in
  let b = perform get_val 2 in
  a + b
with
| return x -> x
| get_val n k -> resume k (n + 10)
--- expect: 23

--- test: state effect get/put
effect State =
  get : unit -> int
  put : int -> unit
end
handle
  let x = perform get () in
  perform put (x + 1);
  perform get ()
with
| return x -> x
| get () k -> resume k 10
| put v k -> resume k ()
--- expect: 10

--- test: handler without continue
effect Abort =
  abort : int -> unit
end
handle
  perform abort 42;
  0
with
| return x -> x
| abort v k -> v
--- expect: 42

--- test: nested handles
effect Inner =
  inner_op : unit -> int
end
effect Outer =
  outer_op : unit -> int
end
handle
  handle
    let a = perform inner_op () in
    let b = perform outer_op () in
    a + b
  with
  | return x -> x
  | inner_op () k -> resume k 10
with
| return x -> x
| outer_op () k -> resume k 20
--- expect: 30

--- test: continue result
effect Eff =
  op : unit -> int
end
handle
  perform op ()
with
| return x -> x + 100
| op () k -> resume k 42
--- expect: 142

--- test: unhandled effect error
effect Unhandled =
  boom : unit -> int
end
perform boom ()
--- expect-type-error

--- test: one-shot continuation error
effect Eff =
  op : unit -> int
end
handle
  perform op ()
with
| return x -> x
| op () k ->
  let _ = resume k 1 in
  resume k 2
--- expect-runtime-error: already resumed

--- test: effect with computed arg
effect Math =
  double : int -> int
end
handle
  perform double (3 + 4)
with
| return x -> x
| double n k -> resume k (n * 2)
--- expect: 14

--- test: copy continuation multi-shot
let rec append xs ys = match xs with
  | [] -> ys
  | x :: rest -> x :: append rest ys
effect Choice =
  choose : unit -> bool
end
handle
  let x = perform choose () in
  let y = perform choose () in
  if x && y do 1 else 0
with
| return x -> [x]
| choose () k ->
  let k2 = copy_continuation k in
  let a = resume k true in
  let b = resume k2 false in
  append a b
--- expect: [1; 0; 0; 0]

--- test: copy continuation simple
let rec append xs ys = match xs with
  | [] -> ys
  | x :: rest -> x :: append rest ys
effect Pick =
  pick : unit -> int
end
handle
  perform pick ()
with
| return x -> [x]
| pick () k ->
  let k2 = copy_continuation k in
  let a = resume k 1 in
  let b = resume k2 2 in
  append a b
--- expect: [1; 2]

=== Try/With Tests ===

--- test: try/with basic return
effect Exn =
  raise : string -> 'a
end
try 42 with
| raise msg -> 0
--- expect: 42

--- test: try/with catch exception
effect Exn =
  raise : string -> 'a
end
try
  perform raise "oops"
with
| raise msg -> msg
--- expect: oops

--- test: try/with no continuation
effect Exn =
  raise : string -> 'a
end
try
  let x = 10 in
  if x > 5 do perform raise "too big"
  else x
with
| raise msg -> 0
--- expect: 0

--- test: try/with multiple operations
effect IO =
  file_not_found : string -> 'a
end
effect Validation =
  invalid_input : string -> 'a
end
try
  perform invalid_input "bad data"
with
| file_not_found path -> "missing: " ^ path
| invalid_input msg -> "invalid: " ^ msg
--- expect: invalid: bad data

--- test: try/with value passes through
effect Exn =
  raise : string -> 'a
end
try "hello" with
| raise msg -> "caught"
--- expect: hello

--- test: try/with unit arg
effect Exn =
  fail : unit -> 'a
end
try
  perform fail ()
with
| fail () -> 99
--- expect: 99

=== Effect Typing Tests ===

--- test: unhandled effect at top level
effect MyEff =
  my_op : unit -> int
end
perform my_op ()
--- expect-type-error

--- test: handled effect at top level
effect MyEff =
  my_op : unit -> int
end
handle
  perform my_op ()
with
| return x -> x
| my_op () k -> resume k 42
--- expect: 42

--- test: effectful function handled by caller
effect Ask =
  ask : unit -> int
end
let f () = perform ask () + 1
handle
  f ()
with
| return x -> x
| ask () k -> resume k 10
--- expect: 11

--- test: multiple effects partial handle
effect E1 =
  op1 : unit -> int
end
effect E2 =
  op2 : unit -> int
end
handle
  handle
    perform op1 () + perform op2 ()
  with
  | return x -> x
  | op1 () k -> resume k 10
with
| return x -> x
| op2 () k -> resume k 20
--- expect: 30

--- test: nested handlers
effect Outer =
  get_outer : unit -> int
end
effect Inner =
  get_inner : unit -> int
end
handle
  handle
    perform get_outer () + perform get_inner ()
  with
  | return x -> x
  | get_inner () k -> resume k 5
with
| return x -> x
| get_outer () k -> resume k 10
--- expect: 15

--- test: effectful callback in higher-order function
effect Counter =
  inc : unit -> unit
end
let apply f x = f x
handle
  let mut n = 0 in
  apply (fn x -> perform inc (); x + 1) 10;
  n
with
| return x -> x
| inc () k -> resume k ()
--- expect: 0

--- test: for loop break with effect tracking
let mut sum = 0 in
for x in [1; 2; 3; 4; 5] do
  if x > 3 do break
  else sum := sum + x
end;
sum
--- expect: 6

--- test: handler produces pure result
effect Tick =
  tick : unit -> unit
end
let result = handle
  perform tick ();
  perform tick ();
  42
with
| return x -> x
| tick () k -> resume k ()
in
result + 1
--- expect: 43

--- test: constrained fn performs effect
effect Log =
  log : string -> unit
end
let show_and_log (x: 'a) : string where Show 'a =
  let s = show x in
  perform log s;
  s
;;
handle
  show_and_log 42
with
| return x -> x
| log msg k -> resume k ()
--- expect: 42

--- test: multi-constraint fn with effect
effect Acc =
  add : int -> unit
end
let process (x: 'a) (y: 'a) : unit where Show 'a, Eq 'a =
  if x = y do perform add 1
  else perform add 2
;;
let mut total = 0 in
handle
  process 3 3;
  process 1 2;
  total
with
| return x -> x
| add n k -> total := total + n; resume k ()
--- expect: 3

--- test: typeclass method in effectful context
effect Collect =
  emit : string -> unit
end
let show_emit (x: 'a) : unit where Show 'a =
  perform emit (show x)
;;
let mut buf = "" in
handle
  show_emit 1;
  show_emit true;
  show_emit "hi"
with
| return _ -> buf
| emit s k -> buf := buf ^ s ^ ","; resume k ()
--- expect: 1,true,hi,

--- test: List.map with effectful callback
effect Counter =
  inc : unit -> unit
end
let mut count = 0 in
handle
  let result = List.map (fn x -> perform inc (); x * 2) [1; 2; 3] in
  List.fold (fn a b -> a + b) 0 result
with
| return x -> x + count
| inc () k -> count := count + 1; resume k ()
--- expect: 15

--- test: List.filter with effectful predicate
effect Log =
  log : int -> unit
end
let mut logged = 0 in
handle
  let evens = List.filter (fn x -> do
    perform log x;
    x mod 2 = 0
  end) [1; 2; 3; 4; 5] in
  List.length evens
with
| return x -> x * 100 + logged
| log n k -> logged := logged + n; resume k ()
--- expect: 215

--- test: nested HOFs with effects
effect Track =
  hit : unit -> unit
end
let mut hits = 0 in
handle
  let xs = [1; 2; 3; 4] in
  let doubled = List.map (fn x -> perform hit (); x * 2) xs in
  let big = List.filter (fn x -> perform hit (); x > 4) doubled in
  List.fold (fn a b -> a + b) 0 big
with
| return x -> x + hits
| hit () k -> hits := hits + 1; resume k ()
--- expect: 22

--- test: fold with effectful accumulator fn
effect Notify =
  notify : int -> unit
end
let mut notifications = 0 in
handle
  List.fold (fn acc x -> do
    (if x > 2 do perform notify x else ());
    acc + x
  end) 0 [1; 2; 3; 4; 5]
with
| return x -> x + notifications
| notify n k -> notifications := notifications + n; resume k ()
--- expect: 27

--- test: closure captures effect and called in handler
effect State =
  get : unit -> int
  put : int -> unit
end
let make_adder n = fn () ->
  let cur = perform get () in
  perform put (cur + n)
let add3 = make_adder 3 in
let add7 = make_adder 7 in
let mut st = 0 in
handle
  add3 ();
  add7 ();
  add3 ();
  perform get ()
with
| return x -> x
| get () k -> resume k st
| put n k -> st := n; resume k ()
--- expect: 13

--- test: HOF returns effectful closure
effect E =
  op : int -> int
end
let wrap f = fn x -> perform op (f x)
let double = wrap (fn x -> x * 2)
handle
  double 5 + double 3
with
| return x -> x
| op n k -> resume k (n + 1)
--- expect: 18

--- test: effects through pipe
effect Tap =
  tap : int -> unit
end
let mut tapped = 0 in
handle
  [1; 2; 3; 4; 5]
    |> List.map (fn x -> perform tap x; x * x)
    |> List.filter (fn x -> x > 5)
    |> List.fold (fn a b -> a + b) 0
with
| return x -> x + tapped
| tap n k -> tapped := tapped + n; resume k ()
--- expect: 65

--- test: effect in match arms
effect Log =
  log : string -> unit
end
type shape = Circle of int | Rect of int * int
let describe s =
  match s with
  | Circle r -> perform log "circle"; r * r
  | Rect (w, h) -> perform log "rect"; w * h
let mut msgs = "" in
handle
  describe (Circle 5) + describe (Rect (3, 4))
with
| return x -> x
| log s k -> msgs := msgs ^ s; resume k ()
--- expect: 37

--- test: mutual recursion with effects
effect Ping =
  ping : int -> unit
end
let mut pings = 0 in
let rec is_even n =
  if n = 0 do true
  else (perform ping n; is_odd (n - 1))
and is_odd n =
  if n = 0 do false
  else (perform ping n; is_even (n - 1))
in
handle
  if is_even 6 do 1 else 0
with
| return x -> x + pings
| ping n k -> pings := pings + 1; resume k ()
--- expect: 7

--- test: handler transforms result
effect Choose =
  choose : unit -> bool
end
let pick_path () =
  if perform choose () do 10 else 20
handle
  pick_path () + pick_path ()
with
| return x -> x
| choose () k ->
  let a = resume k true in
  a
--- expect: 20

--- test: layered handlers different effects
effect A =
  op_a : unit -> int
end
effect B =
  op_b : unit -> int
end
let f () =
  let a = perform op_a () in
  let b = perform op_b () in
  a + b
handle
  handle
    f ()
  with
  | return x -> x
  | op_a () k -> resume k 100
with
| return x -> x
| op_b () k -> resume k 7
--- expect: 107

--- test: handler inside for loop
effect Fail =
  fail : unit -> int
end
let safe_div a b =
  handle
    if b = 0 do perform fail ()
    else a / b
  with
  | return x -> x
  | fail () k -> resume k (0 - 1)
;;
let mut sum = 0 in
for b in [2; 0; 3; 0; 5] do
  sum := sum + safe_div 30 b
end;
sum
--- expect: 29

--- test: record with effectful function field
effect Log =
  log : string -> unit
end
let make_logger name = {
  info = fn msg -> perform log (name ^ ": " ^ msg);
  name = name
}
let lgr = make_logger "test"
let mut logged = "" in
handle
  lgr.info "hello";
  lgr.info "world";
  42
with
| return x -> x
| log s k -> logged := logged ^ s ^ ";"; resume k ()
--- expect: 42

--- test: effect inside for loop
effect Count =
  count : unit -> unit
end
handle
  for x in [1; 2; 3; 4; 5] with acc = 0 do
    perform count ();
    acc + 1
  end
with
| return x -> x
| count () k -> resume k ()
--- expect: 5

--- test: effect inside fold-for loop
effect Tap =
  tap : int -> unit
end
let mut tapped = 0 in
handle
  for x in [10; 20; 30] with acc = 0 do
    perform tap x;
    acc + x
  end
with
| return x -> x + tapped
| tap n k -> tapped := tapped + n; resume k ()
--- expect: 120

--- test: compose effectful functions
effect E =
  op : int -> int
end
let compose f g = fn x -> f (g x)
let double x = perform op (x * 2)
let inc x = perform op (x + 1)
let double_then_inc = compose inc double
handle
  double_then_inc 5
with
| return x -> x
| op n k -> resume k n
--- expect: 11

--- test: apply function n times with effects
effect Step =
  step : int -> int
end
let rec apply_n f n x =
  if n = 0 do x
  else apply_n f (n - 1) (f x)
in
handle
  apply_n (fn x -> perform step (x + 1)) 5 0
with
| return x -> x
| step n k -> resume k n
--- expect: 5

--- test: effectful let binding in handler
effect Gen =
  next : unit -> int
end
let mut counter = 0 in
handle
  let a = perform next () in
  let b = perform next () in
  let c = perform next () in
  a + b + c
with
| return x -> x
| next () k -> counter := counter + 1; resume k counter
--- expect: 6

--- test: unit effect in sequence
effect Log =
  log : string -> unit
end
let mut count = 0 in
handle
  perform log "a";
  perform log "b";
  perform log "c";
  99
with
| return x -> x + count
| log _ k -> count := count + 1; resume k ()
--- expect: 102

--- test: Seq with effects
effect E =
  observe : int -> unit
end
let mut observed = 0 in
handle
  Seq.range 1 4
    |> Seq.map (fn x -> perform observe x; x * x)
    |> Seq.fold (fn a b -> a + b) 0
with
| return x -> x + observed
| observe n k -> observed := observed + n; resume k ()
--- expect: 20

=== Perform Parsing Tests ===

--- test: perform with field access no parens
effect E = put : int -> unit end
let mut received = 0 in
handle
  let r = { x = 42; y = 10 } in
  perform put r.x;
  received
with
| return x -> x
| put v k -> received := v; resume k ()
--- expect: 42

--- test: perform with chained field access
effect E = send : int -> unit end
let mut received = 0 in
handle
  let r = { inner = { val_ = 99 } } in
  perform send r.inner.val_;
  received
with
| return x -> x
| send v k -> received := v; resume k ()
--- expect: 99

--- test: perform with indexing
effect E = send : int -> unit end
let mut received = 0 in
handle
  let arr = #[10; 20; 30] in
  perform send arr.[1];
  received
with
| return x -> x
| send v k -> received := v; resume k ()
--- expect: 20

=== Continuation Type Error Tests ===

--- test: direct continuation application rejected
effect Boom = boom : unit -> int end
handle perform boom () with
| return x -> x
| boom () k -> k 10
--- expect-type-error

--- test: continuation passed to higher-order function rejected
effect Ask = ask : unit -> int end
handle perform ask () with
| return x -> x
| ask () k -> (fn f -> f 42) k
--- expect-type-error

--- test: resume with continuation still works
effect Val = get_val : unit -> int end
let r = handle
  perform get_val () + 1
with
| return x -> x
| get_val () k -> resume k 10
in print (string_of_int r)
--- expect: 11
