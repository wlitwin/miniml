#!/usr/bin/env node
// Build script: bundles vm.js + builtins.js + loader.js into miniml.bundle.js

const fs = require("fs");
const path = require("path");

const dir = __dirname;
const vmSrc = fs.readFileSync(path.join(dir, "vm.js"), "utf-8");
const builtinsSrc = fs.readFileSync(path.join(dir, "builtins.js"), "utf-8");
const loaderSrc = fs.readFileSync(path.join(dir, "loader.js"), "utf-8");

// Embed stdlib sources needed by the self-hosted compiler at runtime
const stdlibDir = path.join(dir, "..", "stdlib");
const STDLIB_FILES = [
  "byte", "rune", "math", "list", "array_extra", "result", "option",
  "buffer", "iter", "hash", "hashtbl", "ref", "dynarray", "set",
  "enum", "seq", "fmt", "show", "iter_map", "compat",
];
const stdlibSources = {};
for (const name of STDLIB_FILES) {
  stdlibSources[`stdlib/${name}.mml`] = fs.readFileSync(path.join(stdlibDir, `${name}.mml`), "utf-8");
}

function strip(src) {
  return src
    // Remove require() lines
    .replace(/^const\s+\w+\s*=\s*require\([^)]*\);\s*$/gm, "")
    .replace(/^const\s+\{[^}]*\}\s*=\s*require\([^)]*\);\s*$/gm, "")
    // Remove module.exports = { ... };
    .replace(/^module\.exports\s*=\s*\{[^}]*\};?\s*$/m, "");
}

// Replace IO/Sys builtins that use fs/process with browser stubs
function stubNodeBuiltins(src) {
  // Replace entire IO section
  const ioStart = src.indexOf("// --- IO module ---");
  const ioEnd = src.indexOf("// --- Sys module ---");
  const sysEnd = src.indexOf("// --- Runtime.eval");

  if (ioStart === -1 || ioEnd === -1 || sysEnd === -1) {
    throw new Error("Could not find IO/Sys section markers in builtins.js");
  }

  const before = src.slice(0, ioStart);
  const after = src.slice(sysEnd);

  const stubs = `// --- IO module (browser stubs, configurable via globalThis) ---

reg("IO.read_file", 1, (args) => {
  if (typeof globalThis._vmReadFile === "function") {
    return vstring(globalThis._vmReadFile(asString(args[0])));
  }
  error("IO.read_file not supported in browser");
});
reg("IO.write_file", 2, () => { error("IO.write_file not supported in browser"); });
reg("IO.append_file", 2, () => { error("IO.append_file not supported in browser"); });
reg("IO.read_line", 1, () => { error("IO.read_line not supported in browser"); });
reg("IO.file_exists", 1, () => vbool(false));

// --- Sys module (browser stubs, configurable via globalThis) ---

reg("Sys.args", 1, () => {
  if (globalThis._vmArgs) {
    return vlist(globalThis._vmArgs.map(vstring));
  }
  return vlist([]);
});
reg("Sys.getenv", 1, () => vvariant(0, "None", null));
reg("Sys.exit", 1, () => { error("Sys.exit not supported in browser"); });
reg("Sys.time", 1, () => vfloat(performance.now() / 1000));

`;

  return before + stubs + after;
}

const bundle = `// MiniML VM - browser bundle (generated by browser.js)
(function(global) {
"use strict";

// ---- vm.js ----
${strip(vmSrc)}

// ---- builtins.js ----
${stubNodeBuiltins(strip(builtinsSrc)).replace(/\bvm\./g, "")}

// ---- loader.js ----
${strip(loaderSrc).replace(/\bvm\./g, "")}

// ---- Stdlib sources (embedded for self-hosted compiler) ----
const STDLIB_SOURCES = ${JSON.stringify(stdlibSources)};

// ---- Public API ----
global.MiniML = {
  loadBundle: loadBundle,
  loadBundleBinary: loadBundleBinary,
  callClosure: callClosure,
  ppValue: ppValue,
  RuntimeError: RuntimeError,
  VUNIT: VUNIT,
  STDLIB_SOURCES: STDLIB_SOURCES,
  resetProfile: resetProfile,
  dumpProfile: function() { dumpProfile(OPCODE_NAMES); },
};

})(typeof window !== "undefined" ? window : globalThis);
`;

const outPath = path.join(dir, "miniml.bundle.js");
fs.writeFileSync(outPath, bundle);
console.log(`Wrote ${outPath} (${(bundle.length / 1024).toFixed(1)} KB)`);
