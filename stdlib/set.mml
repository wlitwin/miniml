newtype 'a set = MSet of ('a, unit) map
;;
module Set =
  pub let empty () : 'a set = MSet (Map.empty ())

  pub let singleton (x : 'a) : 'a set = MSet (Map.set x () (Map.empty ()))

  pub let of_list xs : 'a set =
    MSet (List.fold (fn acc x -> Map.set x () acc) (Map.empty ()) xs)

  pub let add elem (MSet s) : 'a set = MSet (Map.set elem () s)

  pub let remove elem (MSet s) : 'a set = MSet (Map.remove elem s)

  pub let mem elem (MSet s) = Map.has elem s

  pub let size (MSet s) = Map.size s

  pub let to_list (MSet s) = Map.keys s

  pub let union (MSet s1) (MSet s2) : 'a set =
    MSet (List.fold (fn acc x -> Map.set x () acc) s2 (Map.keys s1))

  pub let inter (MSet s1) (MSet s2) : 'a set =
    MSet (List.fold (fn acc x ->
      if Map.has x s2 do Map.set x () acc else acc
    ) (Map.empty ()) (Map.keys s1))

  pub let diff (MSet s1) (MSet s2) : 'a set =
    MSet (List.fold (fn acc x ->
      if not (Map.has x s2) do Map.set x () acc else acc
    ) (Map.empty ()) (Map.keys s1))

  pub let is_empty (MSet s) = Map.size s = 0

  pub let is_subset (MSet s1) (MSet s2) =
    List.forall (fn x -> Map.has x s2) (Map.keys s1)
end
;;
instance Iter ('a set) 'a =
  let fold f acc (MSet s) =
    let rec go a l = match l with
      | [] -> a
      | x :: rest -> go (f a x) rest
    in go acc (Map.keys s)
end
;;
instance Show ('a set) where Show 'a =
  let show (MSet s) = match Map.keys s with
    | [] -> "#{}"
    | ks ->
      let inner = List.fold (fn acc x ->
        if acc = "" do show x else acc ^ "; " ^ show x
      ) "" ks in
      "#{" ^ inner ^ "}"
end
