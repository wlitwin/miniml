=== Let Bindings ===

--- test: integer binding
let x = 1
--- expect:
pub let x = 1
--- end

--- test: string binding
let s = "hello"
--- expect:
pub let s = "hello"
--- end

--- test: let rec
let rec f x = f x
--- expect:
pub let rec f x = f x
--- end

--- test: two let bindings
let a = 1
let b = 2
--- expect:
pub let a = 1

pub let b = 2
--- end

--- test: multi-param function
let add x y = x + y
--- expect:
pub let add x y = x + y
--- end

--- test: tuple binding
let (a, b) = (1, 2)
--- expect:
pub let (a, b) = (1, 2)
--- end

--- test: let-in expression
let f x =
  let y = x + 1 in
  y * 2
--- expect:
pub let f x =
  let y = x + 1 in
  y * 2
--- end

--- test: mutual recursion
let rec even n = if n = 0 then true else odd (n - 1)
and odd n = if n = 0 then false else even (n - 1)
--- expect:
pub let rec even n =
  if n = 0 do
    true
  else
    odd (n - 1)
and odd n =
  if n = 0 do
    false
  else
    even (n - 1)
--- end

=== Type Declarations ===

--- test: simple variant
type color = Red | Green | Blue
--- expect:
pub type color =
  | Red
  | Green
  | Blue
--- end

--- test: variant with payload
type expr = Num of int | Add of expr * expr
--- expect:
pub type expr =
  | Num of int
  | Add of expr * expr
--- end

--- test: record type
type point = {x: int; y: int}
--- expect:
pub type point = {
  x: int;
  y: int
}
--- end

--- test: type alias
type name = string
--- expect:
pub type name = string
--- end

--- test: type and
type a = A
and b = B
--- expect:
pub type a =
  | A

and b =
  | B
--- end

--- test: parametric type
type 'a box = Box of 'a
--- expect:
pub type 'a box =
  | Box of 'a
--- end

--- test: mutable record field
type t = {mutable x: int; y: string}
--- expect:
pub type t = {
  mut x: int;
  y: string
}
--- end

=== Functions ===

--- test: fun desugared to params
let f = fun x -> x + 1
--- expect:
pub let f x = x + 1
--- end

--- test: function with cases
let f = function
  | 0 -> "zero"
  | _ -> "other"
--- expect:
pub let f =
  fn
    | 0 -> "zero"
    | _ -> "other"
--- end

=== Control Flow ===

--- test: if-then-else
let f x = if x > 0 then "pos" else "neg"
--- expect:
pub let f x =
  if x > 0 do
    "pos"
  else
    "neg"
--- end

--- test: if without else
let f x = if x > 0 then print_endline "yes"
--- expect:
pub let f x =
  if x > 0 do
    print_endline "yes"
  end
--- end

--- test: begin-end to sequence
let f x = begin print_endline "a"; x + 1 end
--- expect:
pub let f x =
  print_endline "a";
  x + 1
--- end

--- test: while loop
let f () = while true do print_endline "loop" done
--- expect:
pub let f () = for true do
  print_endline "loop"
end
--- end

=== Ref to Mut ===

--- test: ref binding
let f () =
  let x = ref 0 in
  x := 1
--- expect:
pub let f () =
  let mut x = 0 in
  x := 1
--- end

--- test: incr
let f x = incr x
--- expect:
pub let f x = x := x + 1
--- end

--- test: decr
let f x = decr x
--- expect:
pub let f x = x := x - 1
--- end

=== Pattern Matching ===

--- test: basic match
let f x = match x with
  | 0 -> "zero"
  | n -> "other"
--- expect:
pub let f x =
  match x with
  | 0 -> "zero"
  | n -> "other"
--- end

--- test: match with guard
let f x = match x with
  | n when n > 0 -> "pos"
  | _ -> "other"
--- expect:
pub let f x =
  match x with
  | n when n > 0 -> "pos"
  | _ -> "other"
--- end

--- test: array pattern
let f x = match x with
  | [| a; b |] -> a + b
  | _ -> 0
--- expect:
pub let f x =
  match x with
  | #[a; b] -> a + b
  | _ -> 0
--- end

--- test: interval pattern
let is_digit c = match c with
  | '0'..'9' -> true
  | _ -> false
--- expect:
pub let is_digit c =
  match c with
  | _c when _c >= #30 && _c <= #39 -> true
  | _ -> false
--- end

=== Exceptions to Effects ===

--- test: exception no payload
exception Not_found
--- expect:
effect Not_foundExn =
  not_found : unit -> 'a
end
--- end

--- test: exception with payload
exception Error of string
--- expect:
effect ErrorExn =
  error : string -> 'a
end
--- end

--- test: raise no payload
exception MyError
let f () = raise MyError
--- expect:
effect MyErrorExn =
  myError : unit -> 'a
end

pub let f () = perform myError ()
--- end

--- test: try-with no payload
exception MyError
let f () = try 1 with MyError -> 0
--- expect:
effect MyErrorExn =
  myError : unit -> 'a
end

pub let f () = do try
  1
with
| myError -> 0
end
--- end

--- test: try-with with payload
exception Error of string
let f () = try 1 with Error msg -> 0
--- expect:
effect ErrorExn =
  error : string -> 'a
end

pub let f () = do try
  1
with
| error msg -> 0
end
--- end

=== Printf to String Interpolation ===

--- test: sprintf string
let f x = Printf.sprintf "hello %s" x
--- expect:
pub let f x = $"hello {x}"
--- end

--- test: sprintf mixed types
let f name n = Printf.sprintf "%s has %d items" name n
--- expect:
pub let f name n = $"{name} has {n} items"
--- end

--- test: sprintf int
let f n = Printf.sprintf "count: %d" n
--- expect:
pub let f n = $"count: {n}"
--- end

=== Stdlib Mappings ===

--- test: Char.code to Byte.to_int
let f c = Char.code c
--- expect:
pub let f c = Byte.to_int c
--- end

--- test: Buffer.add_char to Buffer.add_byte
let f buf c = Buffer.add_char buf c
--- expect:
pub let f buf c = Buffer.add_byte buf c
--- end

--- test: Hashtbl.replace to Hashtbl.set
let f h k v = Hashtbl.replace h k v
--- expect:
pub let f h k v = Hashtbl.set h k v
--- end

--- test: List.fold_left to List.fold
let f = List.fold_left (fun acc x -> acc + x) 0
--- expect:
pub let f = List.fold (fn acc x -> acc + x) 0
--- end

--- test: Char.uppercase_ascii to Byte.to_upper
let f c = Char.uppercase_ascii c
--- expect:
pub let f c = Byte.to_upper c
--- end

--- test: List.for_all to List.forall
let f = List.for_all (fun x -> x > 0)
--- expect:
pub let f = List.forall (fn x -> x > 0)
--- end

--- test: List.fold_left2 to List.fold2
let f = List.fold_left2 (fun acc a b -> acc + a + b) 0
--- expect:
pub let f = List.fold2 (fn acc a b -> (acc + a) + b) 0
--- end

=== Lazy ===

--- test: lazy expression
let x = lazy (1 + 2)
--- expect:
pub let x = (fn () -> 1 + 2)
--- end

--- test: Lazy.force
let f x = Lazy.force x
--- expect:
pub let f x = x ()
--- end

=== Mutable Field Assignment ===

--- test: field assignment
let f r = r.x <- 5
--- expect:
pub let f r = r.x := 5
--- end

=== Literals and Data ===

--- test: list literal
let xs = [1; 2; 3]
--- expect:
pub let xs = 1 :: 2 :: 3 :: []
--- end

--- test: array literal
let xs = [| 1; 2; 3 |]
--- expect:
pub let xs = #[1; 2; 3]
--- end

--- test: record update
let f r = { r with x = 5 }
--- expect:
pub let f r = {r with x = 5}
--- end

=== Modules ===

--- test: open module
open List
--- expect:
open List
--- end

--- test: nested module
module Inner = struct
  let x = 42
end
--- expect:
module Inner =
  pub let x = 42
end
--- end

=== Keyword Escaping ===

--- test: fn as variable name
let f fn = fn + 1
--- expect:
pub let f fn_ = fn_ + 1
--- end

--- test: continue as variable name
let f continue = continue + 1
--- expect:
pub let f continue_ = continue_ + 1
--- end

=== List Append ===

--- test: @ to List.concat
let f a b = a @ b
--- expect:
pub let f a b = List.concat a b
--- end

=== Physical Equality ===

--- test: == to =
let f a b = a == b
--- expect:
pub let f a b = a = b
--- end

--- test: != to <>
let f a b = a != b
--- expect:
pub let f a b = a <> b
--- end

=== Rune Patterns ===

--- test: char constant in match
let f x = match x with
  | 'a' -> 1
  | _ -> 0
--- expect:
pub let f x =
  match x with
  | _c when _c = #61 -> 1
  | _ -> 0
--- end

=== Try Catch-All ===

--- test: try with catch-all unit
exception E
let f () = try raise E with _ -> ()
--- expect:
effect EExn =
  e : unit -> 'a
end

pub let f () = (* try/catch-all *) perform e ()
--- end
--- end
