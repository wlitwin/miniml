module Types =
  effect Unify_errorExn =
    unify_error : string -> 'a
  end

  pub type tvar =
    | Unbound of int * int
    | Link of ty

  and ty =
    | TInt
    | TFloat
    | TBool
    | TString
    | TByte
    | TRune
    | TUnit
    | TArrow of ty * eff * ty
    | TCont of ty * eff * ty
    | TTuple of ty list
    | TList of ty
    | TRecord of record_row
    | TVariant of string * ty list
    | TArray of ty
    | TPolyVariant of pvrow
    | TVar of tvar Ref.t
    | TGen of int

  and eff =
    | EffVar of effvar Ref.t
    | EffEmpty
    | EffRow of string * ty list * eff
    | EffGen of int

  and effvar =
    | EffUnbound of int * int
    | EffLink of eff

  and pvrow =
    | PVRow of string * ty option * pvrow
    | PVVar of pvvar Ref.t
    | PVEmpty
    | PVGen of int

  and pvvar =
    | PVUnbound of int * int
    | PVLink of pvrow

  and record_row =
    | RRow of string * ty * record_row
    | RVar of rvar Ref.t
    | REmpty
    | RGen of int
    | RWild

  and rvar =
    | RUnbound of int * int
    | RLink of record_row


  pub type class_arg =
    | CATGen of int
    | CATy of ty
    | CAWild
    | CAPhantom of int * ty


  pub type class_constraint = {
    cc_class: string;
    cc_args: class_arg list
  }

  pub type record_evidence = {
    re_fields: string list;
    re_rgen: int
  }

  pub type scheme = {
    quant: int;
    equant: int;
    pvquant: int;
    rquant: int;
    constraints: class_constraint list;
    record_evidences: record_evidence list;
    body: ty
  }

  pub let mono ty = {quant = 0; equant = 0; pvquant = 0; rquant = 0; constraints = []; record_evidences = []; body = ty}

  pub let next_id = Ref.create 0

  pub let fresh_id () =
    let id = Ref.get next_id in
    Ref.set next_id (id + 1);
    id

  pub let new_tvar level = TVar (Ref.create (Unbound (fresh_id (), level)))

  pub let new_effvar level = EffVar (Ref.create (EffUnbound (fresh_id (), level)))

  pub let new_pvvar level = PVVar (Ref.create (PVUnbound (fresh_id (), level)))

  pub let new_rvar level = RVar (Ref.create (RUnbound (fresh_id (), level)))

  pub let rec repr =
    fn
      | TVar ({contents = Link ty} as r) -> 
        let ty = repr ty in
        Ref.set r (Link ty);
        ty
      | ty -> ty


  pub let rec is_concrete ty =
    match repr ty with
    | TVar {contents = Unbound _} -> false
    | TVar {contents = Link _} -> failwith "assert false"
    | TArrow ((a, eff, r)) | TCont ((a, eff, r)) -> (is_concrete a) && ((is_concrete_eff eff) && (is_concrete r))
    | TTuple ts -> List.forall is_concrete ts
    | TList t | TArray t -> is_concrete t
    | TVariant ((_, args)) -> List.forall is_concrete args
    | TInt | TFloat | TBool | TString | TByte | TRune | TUnit | TGen _ -> true
    | TRecord row -> is_concrete_rrow row
    | TPolyVariant row -> is_concrete_pv row

  and is_concrete_eff =
    fn
      | EffVar {contents = EffLink eff} -> is_concrete_eff eff
      | EffVar {contents = EffUnbound _} -> false
      | EffRow ((_, tys, tail)) -> (List.forall is_concrete tys) && (is_concrete_eff tail)
      | EffEmpty -> true
      | EffGen _ -> true

  and is_concrete_rrow =
    fn
      | RRow ((_, ty, tail)) -> (is_concrete ty) && (is_concrete_rrow tail)
      | RVar {contents = RLink row} -> is_concrete_rrow row
      | RVar {contents = RUnbound _} -> false
      | REmpty -> true
      | RGen _ | RWild -> true

  and is_concrete_pv =
    fn
      | PVRow ((_, Some ty, tail)) -> (is_concrete ty) && (is_concrete_pv tail)
      | PVRow ((_, None, tail)) -> is_concrete_pv tail
      | PVVar {contents = PVLink row} -> is_concrete_pv row
      | PVVar {contents = PVUnbound _} -> false
      | PVEmpty -> true
      | PVGen _ -> true


  pub let rec eff_repr =
    fn
      | EffVar ({contents = EffLink eff} as r) -> 
        let eff = eff_repr eff in
        Ref.set r (EffLink eff);
        eff
      | eff -> eff


  pub let rec pv_repr =
    fn
      | PVVar ({contents = PVLink row} as r) -> 
        let row = pv_repr row in
        Ref.set r (PVLink row);
        row
      | row -> row


  pub let rec rrow_repr =
    fn
      | RVar ({contents = RLink row} as r) -> 
        let row = rrow_repr row in
        Ref.set r (RLink row);
        row
      | row -> row


  pub let fields_to_closed_row fields = List.fold_right (fn (n, t) acc -> RRow (n, t, acc)) fields REmpty

  pub let record_row_to_fields row =
    let rec collect r =
      match rrow_repr r with
      | RRow ((n, t, tail)) -> (n, t) :: collect tail
      | _ -> []
     in
    collect row

  pub type variant_def = (string * ty option) list

  pub type ctor_info = {
    ctor_type_name: string;
    ctor_arg_ty: ty option;
    ctor_num_params: int;
    ctor_return_ty_params: ty list option;
    ctor_existentials: int
  }

  pub type fundep = {
    fd_from: int list;
    fd_to: int list
  }

  pub type class_def = {
    class_name: string;
    class_params: string list;
    class_methods: (string * ty) list;
    class_fundeps: fundep list
  }

  pub type instance_def = {
    inst_class: string;
    inst_tys: ty list;
    inst_dict_name: string;
    inst_constraints: class_constraint list
  }

  pub type effect_def = {
    effect_name: string;
    effect_params: string list;
    effect_ops: (string * ty) list
  }

  pub type module_info = {
    mod_name: string;
    mod_pub_vars: (string * scheme) list;
    mod_pub_mutable_vars: string list;
    mod_pub_types: string list;
    mod_opaque_types: string list;
    mod_newtypes: string list;
    mod_pub_constructors: (string * ctor_info) list;
    mod_instances: instance_def list;
    mod_submodules: (string * module_info) list;
    mod_pub_classes: string list
  }

  pub type type_env = {
    variants: (string * int * variant_def * bool) list;
    constructors: (string * ctor_info) list;
    records: (string * (string * ty) list) list;
    classes: class_def list;
    instances: instance_def list;
    effects: effect_def list;
    mutable_fields: string list;
    modules: (string * module_info) list;
    type_aliases: (string * string) list;
    type_synonyms: (string * int * ty) list;
    newtypes: string list;
    hidden_types: string list;
    hidden_ctor_types: string list
  }

  pub let empty_type_env = {variants = []; constructors = []; records = []; classes = []; instances = []; effects = []; mutable_fields = []; modules = []; type_aliases = []; type_synonyms = []; newtypes = []; hidden_types = []; hidden_ctor_types = []}

  pub let find_effect_op type_env op_name = List.find_map (fn (edef : effect_def) -> List.find_map (fn (name, ty) -> if name = op_name do
    Some (edef.effect_name, ty)
  else
    None) edef.effect_ops) type_env.effects

  pub let rec ty_to_str =
    fn
      | TInt -> "int"
      | TFloat -> "float"
      | TBool -> "bool"
      | TString -> "string"
      | TByte -> "byte"
      | TRune -> "rune"
      | TUnit -> "unit"
      | TVariant ((name, [])) -> name
      | TVariant ((name, args)) -> (String.concat "_" (List.map ty_to_str args)) ^ ("_" ^ name)
      | TList t -> (ty_to_str t) ^ "_list"
      | TArray t -> (ty_to_str t) ^ "_array"
      | TTuple ts -> (String.concat "_" (List.map ty_to_str ts)) ^ "_tup"
      | TPolyVariant _ -> "polyvar"
      | TGen i -> $"g{i}"
      | TArrow _ | TCont _ -> "arrow"
      | TVar _ -> "tvar"
      | _ -> "ty_other"


  pub let dict_name class_name tys =
    let ty_strs = List.map ty_to_str tys in
    $"__dict_{class_name}_{String.concat "__" ty_strs}"

  pub let find_method_class classes method_name = List.find (fn cls -> List.exists (fn (m, _) -> m = method_name) cls.class_methods) classes

  pub let rec occurs_check id level ty =
    match repr ty with
    | TVar {contents = Unbound ((id2, _))} when id = id2 -> perform unify_error "occurs check: infinite type"
    | TVar ({contents = Unbound ((id2, level2))} as r) -> 
      if level2 > level do
        Ref.set r (Unbound (id2, level))
      end
    | TVar {contents = Link _} -> failwith "assert false"
    | TArrow ((a, eff, b)) | TCont ((a, eff, b)) -> 
      occurs_check id level a;
      occurs_check_eff_for_ty id level eff;
      occurs_check id level b
    | TTuple ts -> List.iter (occurs_check id level) ts
    | TList t -> occurs_check id level t
    | TArray t -> occurs_check id level t
    | TRecord row -> occurs_check_rrow_for_ty id level row
    | TVariant ((_, args)) -> List.iter (occurs_check id level) args
    | TPolyVariant row -> occurs_check_pv_for_ty id level row
    | TInt | TFloat | TBool | TString | TByte | TRune | TUnit | TGen _ -> ()

  and occurs_check_pv_for_ty id level row =
    match pv_repr row with
    | PVRow ((_, ty_opt, tail)) -> 
      do
        match ty_opt with
        | Some t -> occurs_check id level t
        | None -> ()

      end;
      occurs_check_pv_for_ty id level tail
    | _ -> ()

  and occurs_check_rrow_for_ty id level row =
    match rrow_repr row with
    | RRow ((_, ty, tail)) -> 
      occurs_check id level ty;
      occurs_check_rrow_for_ty id level tail
    | _ -> ()

  and occurs_check_eff_for_ty id level eff =
    match eff_repr eff with
    | EffRow ((_, params, tail)) -> 
      List.iter (occurs_check id level) params;
      occurs_check_eff_for_ty id level tail
    | _ -> ()


  pub let rec occurs_check_eff id level eff =
    match eff_repr eff with
    | EffVar {contents = EffUnbound ((id2, _))} when id = id2 -> perform unify_error "occurs check: infinite effect row"
    | EffVar ({contents = EffUnbound ((id2, level2))} as r) -> 
      if level2 > level do
        Ref.set r (EffUnbound (id2, level))
      end
    | EffVar {contents = EffLink _} -> failwith "assert false"
    | EffRow ((_, _params, tail)) -> occurs_check_eff id level tail
    | EffEmpty | EffGen _ -> ()


  pub let rec occurs_check_pv id level row =
    match pv_repr row with
    | PVVar {contents = PVUnbound ((id2, _))} when id = id2 -> perform unify_error "occurs check: infinite polymorphic variant row"
    | PVVar ({contents = PVUnbound ((id2, level2))} as r) -> 
      if level2 > level do
        Ref.set r (PVUnbound (id2, level))
      end
    | PVVar {contents = PVLink _} -> failwith "assert false"
    | PVRow ((_, ty_opt, tail)) -> 
      do
        match ty_opt with
        | Some t -> occurs_check id level t
        | None -> ()

      end;
      occurs_check_pv id level tail
    | PVEmpty | PVGen _ -> ()


  pub let rec occurs_check_rrow id level row =
    match rrow_repr row with
    | RVar {contents = RUnbound ((id2, _))} when id = id2 -> perform unify_error "occurs check: infinite record row"
    | RVar ({contents = RUnbound ((id2, level2))} as r) -> 
      if level2 > level do
        Ref.set r (RUnbound (id2, level))
      end
    | RVar {contents = RLink _} -> failwith "assert false"
    | RRow ((_, ty, tail)) -> 
      occurs_check id level ty;
      occurs_check_rrow id level tail
    | REmpty | RGen _ | RWild -> ()


  pub let pp_synonyms = Ref.create []

  pub let pp_ty_arg_ref = Ref.create (fn _ -> "?")

  pub let try_match_synonym ty =
    let synonyms = Ref.get pp_synonyms in
    if synonyms = [] do
      None
    else
      List.find_map (fn (name, num_params, pattern) -> let bindings = Array.make num_params None in
      let rec go pat actual =
        let actual = repr actual in
        match (pat, actual) with
        | (TGen i, _) when i < num_params -> 
          do
            match Array.get bindings i with
            | None -> 
              Array.set bindings i (Some actual);
              true
            | Some prev -> prev = actual

          end
        | (TInt, TInt) | (TFloat, TFloat) | (TBool, TBool) | (TString, TString) | (TUnit, TUnit) | (TByte, TByte) | (TRune, TRune) -> true
        | (TArrow ((p1, _pe, p2)), TArrow ((a1, _ae, a2))) | (TCont ((p1, _pe, p2)), TCont ((a1, _ae, a2))) -> (go p1 a1) && (go p2 a2)
        | (TList p1, TList a1) -> go p1 a1
        | (TArray p1, TArray a1) -> go p1 a1
        | (TTuple ps, TTuple acts) when (List.length ps) = (List.length acts) -> List.forall2 go ps acts
        | (TVariant ((pn, ps)), TVariant ((an, acts))) when (pn = an) && ((List.length ps) = (List.length acts)) -> List.forall2 go ps acts
        | (TVar r1, TVar r2) when r1 = r2 -> true
        | (TGen i, TGen j) when i = j -> true
        | _ -> false
       in
      if (go pattern ty) && (Array.forall (fn x -> x <> None) bindings) do
        Some (name, Array.to_list (Array.map (fn x -> Option.unwrap x) bindings))
      else
        None) synonyms

  pub let rec pp_eff eff =
    match eff_repr eff with
    | EffEmpty -> ""
    | EffVar {contents = EffUnbound ((id, _))} -> "'" ^ (String.make 1 (Byte.of_int ((Byte.to_int #65) + (id mod 22))))
    | EffRow ((label, params, tail)) -> 
      let param_str =
        match params with
        | [] -> ""
        | ps -> " " ^ (String.concat " " (List.map (Ref.get pp_ty_arg_ref) ps))
       in
      let tail_str =
        match eff_repr tail with
        | EffEmpty -> ""
        | EffVar {contents = EffUnbound _} -> ", " ^ (pp_eff tail)
        | EffRow _ -> ", " ^ (pp_eff tail)
        | _ -> ""
       in
      label ^ (param_str ^ tail_str)
    | EffGen id -> "'" ^ (String.make 1 (Byte.of_int ((Byte.to_int #65) + (id mod 22))))
    | EffVar {contents = EffLink _} -> failwith "assert false"


  pub let eff_is_trivial eff =
    match eff_repr eff with
    | EffEmpty -> true
    | EffVar {contents = EffUnbound _} -> true
    | EffGen _ -> true
    | _ -> false


  pub let rec pp_ty ty =
    let ty = repr ty in
    match try_match_synonym ty with
    | Some ((name, args)) -> 
      do
        match ty with
        | TArrow ((a, _, _)) | TCont ((a, _, _)) when (try_match_synonym (repr a)) <> None -> pp_ty_raw ty
        | _ -> pp_type_con name args

      end
    | None -> pp_ty_raw ty

  and pp_type_con name =
    fn
      | [] -> name
      | arg :: [] -> (match repr arg with
      | TArrow _ | TCont _ | TTuple _ -> "(" ^ ((pp_ty arg) ^ ")")
      | _ -> pp_ty arg
      ) ^ (" " ^ name)
      | args -> "(" ^ ((String.concat ", " (List.map pp_ty args)) ^ (") " ^ name))

  and needs_parens ty =
    let ty = repr ty in
    match try_match_synonym ty with
    | Some _ -> false
    | None -> 
      do
        match ty with
        | TArrow _ | TCont _ | TTuple _ -> true
        | _ -> false

      end

  and pp_ty_arg ty =
    if needs_parens ty do
      "(" ^ ((pp_ty ty) ^ ")")
    else
      pp_ty ty
  and pp_ty_raw ty =
    match ty with
    | TInt -> "int"
    | TFloat -> "float"
    | TBool -> "bool"
    | TString -> "string"
    | TByte -> "byte"
    | TRune -> "rune"
    | TUnit -> "unit"
    | TArrow ((a, eff, r)) -> 
      let a_str =
        match repr a with
        | TArrow _ when (try_match_synonym (repr a)) = None -> "(" ^ ((pp_ty a) ^ ")")
        | _ -> pp_ty a
       in
      if eff_is_trivial eff do
        a_str ^ (" -> " ^ (pp_ty r))
      else
        a_str ^ (" -> " ^ ((pp_ty r) ^ (" / " ^ (pp_eff eff))))
    | TCont ((a, eff, r)) -> 
      let inner =
        let a_str =
          match repr a with
          | TArrow _ | TCont _ when (try_match_synonym (repr a)) = None -> "(" ^ ((pp_ty a) ^ ")")
          | _ -> pp_ty a
         in
        if eff_is_trivial eff do
          a_str ^ (" -> " ^ (pp_ty r))
        else
          a_str ^ (" -> " ^ ((pp_ty r) ^ (" / " ^ (pp_eff eff)))) in
      "continuation(" ^ (inner ^ ")")
    | TTuple ts -> String.concat " * " (List.map (fn t ->
      do
        match repr t with
        | TArrow _ | TCont _ when (try_match_synonym (repr t)) = None -> "(" ^ ((pp_ty t) ^ ")")
        | _ -> pp_ty t

      end) ts)
    | TList t -> (pp_ty_arg t) ^ " list"
    | TArray t -> (pp_ty_arg t) ^ " array"
    | TRecord row -> 
      let rec collect r =
        match rrow_repr r with
        | RRow ((name, ty, tail)) -> (name, ty) :: collect tail
        | _ -> []
       in
      let rec is_open r =
        match rrow_repr r with
        | RRow ((_, _, tail)) -> is_open tail
        | RVar {contents = RUnbound _} | RGen _ | RWild -> true
        | _ -> false
       in
      let fields_str = String.concat "; " (List.map (fn (n, t) -> n ^ (": " ^ (pp_ty t))) (collect row)) in
      if is_open row do
        "{ " ^ (fields_str ^ ((if fields_str = "" do
          ".."
        else
          "; ..") ^ " }"))
      else
        "{ " ^ (fields_str ^ " }")
    | TVariant ((name, [])) -> name
    | TVariant ((name, arg :: [])) -> (pp_ty_arg arg) ^ (" " ^ name)
    | TVariant ((name, args)) -> "(" ^ ((String.concat ", " (List.map pp_ty args)) ^ (") " ^ name))
    | TPolyVariant row -> 
      let rec collect_tags r =
        match pv_repr r with
        | PVRow ((tag, ty_opt, tail)) -> (tag, ty_opt) :: collect_tags tail
        | _ -> []
       in
      let is_open =
        match pv_repr row with
        | PVVar _ -> true
        | PVRow _ -> 
          let rec check r =
            match pv_repr r with
            | PVRow ((_, _, tail)) -> check tail
            | PVVar _ -> true
            | _ -> false
           in
          check row
        | _ -> false
       in
      let tags = collect_tags row in
      let tag_strs = List.map (fn (tag, ty_opt) ->
        do
          match ty_opt with
          | None -> "`" ^ tag
          | Some t -> "`" ^ (tag ^ (" of " ^ (pp_ty t)))

        end) tags in
      let marker =
        if is_open do
          "> "
        else
          "" in
      "[" ^ (marker ^ ((String.concat " | " tag_strs) ^ "]"))
    | TVar {contents = Unbound ((id, _))} -> "'" ^ (String.make 1 (Byte.of_int ((Byte.to_int #61) + (id mod 26))))
    | TVar {contents = Link _} -> failwith "assert false"
    | TGen id -> "'" ^ (String.make 1 (Byte.of_int ((Byte.to_int #61) + (id mod 26))))


  pub let () = Ref.set pp_ty_arg_ref pp_ty_arg

  pub let unify_error t1 t2 = perform unify_error ($"cannot unify {pp_ty t1} with {pp_ty t2}")

  pub let rec unify_eff e1 e2 =
    let e1 = eff_repr e1 in
    let e2 = eff_repr e2 in
    if e1 = e2 do
      ()
    else
      match (e1, e2) with
      | (EffVar ({contents = EffUnbound ((id, level))} as r), eff) | (eff, EffVar ({contents = EffUnbound ((id, level))} as r)) -> 
        occurs_check_eff id level eff;
        Ref.set r (EffLink eff)
      | (EffEmpty, EffEmpty) -> ()
      | (EffRow ((label1, params1, tail1)), EffRow ((label2, params2, tail2))) when (label1 = label2) && ((List.length params1) = (List.length params2)) -> 
        List.iter2 unify params1 params2;
        unify_eff tail1 tail2
      | (EffRow ((label1, params1, tail1)), _) -> 
        let tail2 = rewrite_row label1 params1 e2 in
        unify_eff tail1 tail2
      | (_, EffRow _) -> unify_eff e2 e1
      | (EffGen i, EffGen j) when i = j -> ()
      | _ -> perform unify_error ($"cannot unify effects {pp_eff e1} and {pp_eff e2}")

  and rewrite_row label params_to_unify eff =
    match eff_repr eff with
    | EffRow ((l, found_params, tail)) when l = label -> 
      if (List.length params_to_unify) = (List.length found_params) do
        List.iter2 unify params_to_unify found_params
      end;
      tail
    | EffRow ((l, params, tail)) -> EffRow (l, params, rewrite_row label params_to_unify tail)
    | EffVar ({contents = EffUnbound ((id, level))} as r) -> 
      let new_tail = new_effvar level in
      let new_row = EffRow (label, params_to_unify, new_tail) in
      occurs_check_eff id level new_row;
      Ref.set r (EffLink new_row);
      new_tail
    | EffEmpty -> perform unify_error ($"effect {label} not handled")
    | _ -> perform unify_error ($"cannot rewrite effect row for {label}")

  and subeffect source target =
    let source = eff_repr source in
    let target = eff_repr target in
    if source = target do
      ()
    else
      match source with
      | EffEmpty -> ()
      | EffVar {contents = EffUnbound _} -> unify_eff source target
      | EffRow ((label, params, tail)) -> 
        let target_tail = rewrite_row label params target in
        subeffect (eff_repr tail) target_tail
      | EffGen _ -> ()
      | _ -> unify_eff source target

  and unify_pv_row r1 r2 =
    let r1 = pv_repr r1 in
    let r2 = pv_repr r2 in
    if r1 = r2 do
      ()
    else
      match (r1, r2) with
      | (PVVar ({contents = PVUnbound ((id, level))} as r), row) | (row, PVVar ({contents = PVUnbound ((id, level))} as r)) -> 
        occurs_check_pv id level row;
        Ref.set r (PVLink row)
      | (PVEmpty, PVEmpty) -> ()
      | (PVRow ((tag1, ty1, tail1)), PVRow ((tag2, ty2, tail2))) when tag1 = tag2 -> 
        unify_pv_payload ty1 ty2;
        unify_pv_row tail1 tail2
      | (PVRow ((tag1, ty1, tail1)), _) -> 
        let (ty2, tail2) = rewrite_pv_row tag1 ty1 r2 in
        unify_pv_payload ty1 ty2;
        unify_pv_row tail1 tail2
      | (_, PVRow _) -> unify_pv_row r2 r1
      | (PVGen i, PVGen j) when i = j -> ()
      | _ -> perform unify_error "cannot unify polymorphic variant types"

  and unify_pv_payload ty1 ty2 =
    match (ty1, ty2) with
    | (None, None) -> ()
    | (Some t1, Some t2) -> unify t1 t2
    | _ -> perform unify_error "polymorphic variant payload mismatch"

  and rewrite_pv_row tag default_payload row =
    match pv_repr row with
    | PVRow ((t, ty_opt, tail)) when t = tag -> (ty_opt, tail)
    | PVRow ((t, ty_opt, tail)) -> 
      let (found, rest) = rewrite_pv_row tag default_payload tail in
      (found, PVRow (t, ty_opt, rest))
    | PVVar ({contents = PVUnbound ((id, level))} as r) -> 
      let new_tail = new_pvvar level in
      let new_row = PVRow (tag, default_payload, new_tail) in
      occurs_check_pv id level new_row;
      Ref.set r (PVLink new_row);
      (default_payload, new_tail)
    | PVEmpty -> perform unify_error ($"tag `{tag} not in closed polymorphic variant type")
    | _ -> perform unify_error ($"cannot rewrite polymorphic variant row for `{tag}")

  and unify_record_row r1 r2 =
    let r1 = rrow_repr r1 in
    let r2 = rrow_repr r2 in
    if r1 = r2 do
      ()
    else
      match (r1, r2) with
      | (RVar ({contents = RUnbound ((id, level))} as r), row) | (row, RVar ({contents = RUnbound ((id, level))} as r)) -> 
        occurs_check_rrow id level row;
        Ref.set r (RLink row)
      | (RWild, _) | (_, RWild) -> ()
      | (REmpty, REmpty) -> ()
      | (RRow ((f1, ty1, tail1)), RRow ((f2, ty2, tail2))) when f1 = f2 -> 
        unify ty1 ty2;
        unify_record_row tail1 tail2
      | (RRow ((f1, ty1, tail1)), _) -> 
        let (ty2, tail2) = rewrite_record_row f1 r2 in
        unify ty1 ty2;
        unify_record_row tail1 tail2
      | (_, RRow _) -> unify_record_row r2 r1
      | (RGen i, RGen j) when i = j -> ()
      | _ -> perform unify_error "cannot unify record types"

  and rewrite_record_row field row =
    match rrow_repr row with
    | RRow ((f, ty, tail)) when f = field -> (ty, tail)
    | RRow ((f, ty, tail)) -> 
      let (found, rest) = rewrite_record_row field tail in
      (found, RRow (f, ty, rest))
    | RVar ({contents = RUnbound ((id, level))} as r) -> 
      let new_tail = new_rvar level in
      let field_ty = new_tvar level in
      let new_row = RRow (field, field_ty, new_tail) in
      occurs_check_rrow id level new_row;
      Ref.set r (RLink new_row);
      (field_ty, new_tail)
    | RWild -> 
      let field_ty = new_tvar 0 in
      (field_ty, RWild)
    | REmpty -> perform unify_error ($"record has no field {field}")
    | _ -> perform unify_error ($"cannot rewrite record row for {field}")

  and unify t1 t2 =
    let t1 = repr t1 in
    let t2 = repr t2 in
    if t1 = t2 do
      ()
    else
      match (t1, t2) with
      | (TVar ({contents = Unbound ((id, level))} as r), ty) | (ty, TVar ({contents = Unbound ((id, level))} as r)) -> 
        occurs_check id level ty;
        Ref.set r (Link ty)
      | (TArrow ((a1, e1, r1)), TArrow ((a2, e2, r2))) | (TCont ((a1, e1, r1)), TCont ((a2, e2, r2))) -> 
        unify a1 a2;
        unify_eff e1 e2;
        unify r1 r2
      | (TTuple ts1, TTuple ts2) -> 
        if (List.length ts1) <> (List.length ts2) do
          unify_error t1 t2
        end;
        List.iter2 unify ts1 ts2
      | (TList t1', TList t2') -> unify t1' t2'
      | (TArray t1', TArray t2') -> unify t1' t2'
      | (TRecord r1, TRecord r2) -> unify_record_row r1 r2
      | (TInt, TInt) | (TFloat, TFloat) | (TBool, TBool) | (TString, TString) | (TByte, TByte) | (TRune, TRune) | (TUnit, TUnit) -> ()
      | (TVariant ((a, args_a)), TVariant ((b, args_b))) when a = b -> 
        if (List.length args_a) <> (List.length args_b) do
          unify_error t1 t2
        end;
        List.iter2 unify args_a args_b
      | (TPolyVariant r1, TPolyVariant r2) -> unify_pv_row r1 r2
      | _ -> unify_error t1 t2


  pub let generalize level ty =
    let (id_map : (int, int) Hashtbl.t) = Hashtbl.create 8 in
    let counter = Ref.create 0 in
    let (eff_id_map : (int, int) Hashtbl.t) = Hashtbl.create 4 in
    let ecounter = Ref.create 0 in
    let (pv_id_map : (int, int) Hashtbl.t) = Hashtbl.create 4 in
    let pvcounter = Ref.create 0 in
    let (r_id_map : (int, int) Hashtbl.t) = Hashtbl.create 4 in
    let rcounter = Ref.create 0 in
    let rec go ty =
      match repr ty with
      | TVar {contents = Unbound ((id, level'))} when level' > level -> 
        do
          match Hashtbl.get id_map id with
          | Some gen_id -> TGen gen_id
          | None -> 
            let gen_id = Ref.get counter in
            Ref.set counter (gen_id + 1);
            Hashtbl.set id_map id gen_id;
            TGen gen_id

        end
      | TVar {contents = Unbound _} as t -> t
      | TVar {contents = Link _} -> failwith "assert false"
      | TArrow ((a, eff, r)) -> TArrow (go a, go_eff eff, go r)
      | TCont ((a, eff, r)) -> TCont (go a, go_eff eff, go r)
      | TTuple ts -> TTuple (List.map go ts)
      | TList t -> TList (go t)
      | TArray t -> TArray (go t)
      | TRecord row -> TRecord (go_rrow row)
      | TVariant ((name, args)) -> TVariant (name, List.map go args)
      | TPolyVariant row -> TPolyVariant (go_pv row)
      | t -> t

    and go_eff eff =
      match eff_repr eff with
      | EffVar {contents = EffUnbound ((id, level'))} when level' > level -> 
        do
          match Hashtbl.get eff_id_map id with
          | Some gen_id -> EffGen gen_id
          | None -> 
            let gen_id = Ref.get ecounter in
            Ref.set ecounter (gen_id + 1);
            Hashtbl.set eff_id_map id gen_id;
            EffGen gen_id

        end
      | EffVar {contents = EffUnbound _} as e -> e
      | EffVar {contents = EffLink _} -> failwith "assert false"
      | EffRow ((label, params, tail)) -> EffRow (label, List.map go params, go_eff tail)
      | EffEmpty -> EffEmpty
      | EffGen _ as e -> e

    and go_pv row =
      match pv_repr row with
      | PVVar {contents = PVUnbound ((id, level'))} when level' > level -> 
        do
          match Hashtbl.get pv_id_map id with
          | Some gen_id -> PVGen gen_id
          | None -> 
            let gen_id = Ref.get pvcounter in
            Ref.set pvcounter (gen_id + 1);
            Hashtbl.set pv_id_map id gen_id;
            PVGen gen_id

        end
      | PVVar {contents = PVUnbound _} as r -> r
      | PVVar {contents = PVLink _} -> failwith "assert false"
      | PVRow ((tag, ty_opt, tail)) -> PVRow (tag, Option.map go ty_opt, go_pv tail)
      | PVEmpty -> PVEmpty
      | PVGen _ as r -> r

    and go_rrow row =
      match rrow_repr row with
      | RVar {contents = RUnbound ((id, level'))} when level' > level -> 
        do
          match Hashtbl.get r_id_map id with
          | Some gen_id -> RGen gen_id
          | None -> 
            let gen_id = Ref.get rcounter in
            Ref.set rcounter (gen_id + 1);
            Hashtbl.set r_id_map id gen_id;
            RGen gen_id

        end
      | RVar {contents = RUnbound _} as r -> r
      | RVar {contents = RLink _} -> failwith "assert false"
      | RRow ((name, ty, tail)) -> RRow (name, go ty, go_rrow tail)
      | REmpty -> REmpty
      | RGen _ as r -> r
      | RWild -> RWild
     in
    let body = go ty in
    {quant = Ref.get counter; equant = Ref.get ecounter; pvquant = Ref.get pvcounter; rquant = Ref.get rcounter; constraints = []; record_evidences = []; body}

  pub let generalize_with_map level ty =
    let counter = Ref.create 0 in
    let (id_map : (int, ty) Hashtbl.t) = Hashtbl.create 8 in
    let ecounter = Ref.create 0 in
    let (eff_id_map : (int, eff) Hashtbl.t) = Hashtbl.create 4 in
    let pvcounter = Ref.create 0 in
    let (pv_id_map : (int, pvrow) Hashtbl.t) = Hashtbl.create 4 in
    let rcounter = Ref.create 0 in
    let (r_id_map : (int, record_row) Hashtbl.t) = Hashtbl.create 4 in
    let rec go ty =
      match repr ty with
      | TVar {contents = Unbound ((id, l))} when l > level -> 
        do
          match Hashtbl.get id_map id with
          | Some gen -> gen
          | None -> 
            let gen = TGen (Ref.get counter) in
            Ref.set counter (Ref.get counter + 1);
            Hashtbl.set id_map id gen;
            gen

        end
      | TVar {contents = Unbound _} | TVar {contents = Link _} -> ty
      | TArrow ((a, eff, r)) -> TArrow (go a, go_eff eff, go r)
      | TCont ((a, eff, r)) -> TCont (go a, go_eff eff, go r)
      | TTuple ts -> TTuple (List.map go ts)
      | TList t -> TList (go t)
      | TArray t -> TArray (go t)
      | TRecord row -> TRecord (go_rrow row)
      | TVariant ((name, args)) -> TVariant (name, List.map go args)
      | TPolyVariant row -> TPolyVariant (go_pv row)
      | t -> t

    and go_eff eff =
      match eff_repr eff with
      | EffVar {contents = EffUnbound ((id, l))} when l > level -> 
        do
          match Hashtbl.get eff_id_map id with
          | Some gen -> gen
          | None -> 
            let gen = EffGen (Ref.get ecounter) in
            Ref.set ecounter (Ref.get ecounter + 1);
            Hashtbl.set eff_id_map id gen;
            gen

        end
      | EffVar {contents = EffUnbound _} | EffVar {contents = EffLink _} -> eff
      | EffRow ((label, params, tail)) -> EffRow (label, List.map go params, go_eff tail)
      | EffEmpty -> EffEmpty
      | EffGen _ as e -> e

    and go_pv row =
      match pv_repr row with
      | PVVar {contents = PVUnbound ((id, l))} when l > level -> 
        do
          match Hashtbl.get pv_id_map id with
          | Some gen -> gen
          | None -> 
            let gen = PVGen (Ref.get pvcounter) in
            Ref.set pvcounter (Ref.get pvcounter + 1);
            Hashtbl.set pv_id_map id gen;
            gen

        end
      | PVVar {contents = PVUnbound _} | PVVar {contents = PVLink _} -> row
      | PVRow ((tag, ty_opt, tail)) -> PVRow (tag, Option.map go ty_opt, go_pv tail)
      | PVEmpty -> PVEmpty
      | PVGen _ as r -> r

    and go_rrow row =
      match rrow_repr row with
      | RVar {contents = RUnbound ((id, l))} when l > level -> 
        do
          match Hashtbl.get r_id_map id with
          | Some gen -> gen
          | None -> 
            let gen = RGen (Ref.get rcounter) in
            Ref.set rcounter (Ref.get rcounter + 1);
            Hashtbl.set r_id_map id gen;
            gen

        end
      | RVar {contents = RUnbound _} | RVar {contents = RLink _} -> row
      | RRow ((name, ty, tail)) -> RRow (name, go ty, go_rrow tail)
      | REmpty -> REmpty
      | RGen _ as r -> r
      | RWild -> RWild
     in
    let body = go ty in
    ({quant = Ref.get counter; equant = Ref.get ecounter; pvquant = Ref.get pvcounter; rquant = Ref.get rcounter; constraints = []; record_evidences = []; body}, id_map)

  pub let instantiate_with_mapping level (s : scheme) =
    if (s.quant = 0) && ((s.equant = 0) && ((s.pvquant = 0) && (s.rquant = 0))) do
      (s.body, [])
    else do
      let vars = Array.init s.quant (fn _ -> new_tvar level) in
      let evars = Array.init s.equant (fn _ -> new_effvar level) in
      let pvvars = Array.init s.pvquant (fn _ -> new_pvvar level) in
      let rvars = Array.init s.rquant (fn _ -> new_rvar level) in
      let shared_eff = (fn () -> new_effvar level) in
      let mapping = List.init s.quant (fn i -> (i, Array.get vars i)) in
      let rec go =
        fn
          | TGen id when id < s.quant -> Array.get vars id
          | TArrow ((a, eff, r)) -> TArrow (go a, go_eff eff, go r)
          | TCont ((a, eff, r)) -> TCont (go a, go_eff eff, go r)
          | TTuple ts -> TTuple (List.map go ts)
          | TList t -> TList (go t)
          | TArray t -> TArray (go t)
          | TRecord row -> TRecord (go_rrow row)
          | TVariant ((name, args)) -> TVariant (name, List.map go args)
          | TPolyVariant row -> TPolyVariant (go_pv row)
          | t -> t

      and go_eff =
        fn
          | EffGen id when id < s.equant -> Array.get evars id
          | EffRow ((label, params, tail)) -> EffRow (label, List.map go params, go_eff tail)
          | EffEmpty -> shared_eff ()
          | e -> e

      and go_pv =
        fn
          | PVGen id when id < s.pvquant -> Array.get pvvars id
          | PVRow ((tag, ty_opt, tail)) -> PVRow (tag, Option.map go ty_opt, go_pv tail)
          | r -> r

      and go_rrow =
        fn
          | RGen id when id < s.rquant -> Array.get rvars id
          | RRow ((name, ty, tail)) -> RRow (name, go ty, go_rrow tail)
          | r -> r
       in
      (go s.body, mapping)
    end

  pub let instantiate level (s : scheme) =
    if (s.quant = 0) && ((s.equant = 0) && ((s.pvquant = 0) && (s.rquant = 0))) do
      s.body
    else do
      let vars = Array.init s.quant (fn _ -> new_tvar level) in
      let evars = Array.init s.equant (fn _ -> new_effvar level) in
      let pvvars = Array.init s.pvquant (fn _ -> new_pvvar level) in
      let rvars = Array.init s.rquant (fn _ -> new_rvar level) in
      let shared_eff = (fn () -> new_effvar level) in
      let rec go =
        fn
          | TGen id when id < s.quant -> Array.get vars id
          | TArrow ((a, eff, r)) -> TArrow (go a, go_eff eff, go r)
          | TCont ((a, eff, r)) -> TCont (go a, go_eff eff, go r)
          | TTuple ts -> TTuple (List.map go ts)
          | TList t -> TList (go t)
          | TArray t -> TArray (go t)
          | TRecord row -> TRecord (go_rrow row)
          | TVariant ((name, args)) -> TVariant (name, List.map go args)
          | TPolyVariant row -> TPolyVariant (go_pv row)
          | TVar {contents = Link ty} -> go ty
          | t -> t

      and go_eff =
        fn
          | EffGen id when id < s.equant -> Array.get evars id
          | EffRow ((label, params, tail)) -> EffRow (label, List.map go params, go_eff tail)
          | EffEmpty -> shared_eff ()
          | e -> e

      and go_pv =
        fn
          | PVGen id when id < s.pvquant -> Array.get pvvars id
          | PVRow ((tag, ty_opt, tail)) -> PVRow (tag, Option.map go ty_opt, go_pv tail)
          | r -> r

      and go_rrow =
        fn
          | RGen id when id < s.rquant -> Array.get rvars id
          | RRow ((name, ty, tail)) -> RRow (name, go ty, go_rrow tail)
          | r -> r
       in
      go s.body
    end

  pub let rec deep_repr ty =
    match repr ty with
    | TArrow ((a, eff, b)) -> TArrow (deep_repr a, deep_repr_eff eff, deep_repr b)
    | TCont ((a, eff, b)) -> TCont (deep_repr a, deep_repr_eff eff, deep_repr b)
    | TTuple ts -> TTuple (List.map deep_repr ts)
    | TList t -> TList (deep_repr t)
    | TArray t -> TArray (deep_repr t)
    | TRecord row -> TRecord (deep_repr_rrow row)
    | TVariant ((name, args)) -> TVariant (name, List.map deep_repr args)
    | TPolyVariant row -> TPolyVariant (deep_repr_pv row)
    | t -> t

  and deep_repr_eff eff =
    match eff_repr eff with
    | EffRow ((label, params, tail)) -> EffRow (label, List.map deep_repr params, deep_repr_eff tail)
    | e -> e

  and deep_repr_pv row =
    match pv_repr row with
    | PVRow ((tag, ty_opt, tail)) -> PVRow (tag, Option.map deep_repr ty_opt, deep_repr_pv tail)
    | r -> r

  and deep_repr_rrow row =
    match rrow_repr row with
    | RRow ((name, ty, tail)) -> RRow (name, deep_repr ty, deep_repr_rrow tail)
    | r -> r


  pub let rec types_compatible t1 t2 =
    let t1 = repr t1 in
    let t2 = repr t2 in
    match (t1, t2) with
    | (TVar _, _) | (_, TVar _) -> true
    | (TInt, TInt) | (TFloat, TFloat) | (TBool, TBool) | (TString, TString) | (TByte, TByte) | (TRune, TRune) | (TUnit, TUnit) -> true
    | (TArrow ((a1, _, r1)), TArrow ((a2, _, r2))) | (TCont ((a1, _, r1)), TCont ((a2, _, r2))) -> (types_compatible a1 a2) && (types_compatible r1 r2)
    | (TTuple ts1, TTuple ts2) -> ((List.length ts1) = (List.length ts2)) && (List.forall2 types_compatible ts1 ts2)
    | (TList t1, TList t2) -> types_compatible t1 t2
    | (TArray t1, TArray t2) -> types_compatible t1 t2
    | (TRecord r1, TRecord r2) -> 
      let f1 = record_row_to_fields r1 in
      let f2 = record_row_to_fields r2 in
      ((List.length f1) = (List.length f2)) && (List.forall2 (fn (n1, t1) (n2, t2) -> (n1 = n2) && (types_compatible t1 t2)) f1 f2)
    | (TVariant ((a, args_a)), TVariant ((b, args_b))) -> (a = b) && (((List.length args_a) = (List.length args_b)) && (List.forall2 types_compatible args_a args_b))
    | (TPolyVariant r1, TPolyVariant r2) -> pvrows_compatible r1 r2
    | _ -> false

  and pvrows_compatible r1 r2 =
    let rec collect r =
      match pv_repr r with
      | PVRow ((tag, ty_opt, tail)) -> (tag, ty_opt) :: collect tail
      | _ -> []
     in
    let tags1 = collect r1 in
    let tags2 = collect r2 in
    ((List.length tags1) = (List.length tags2)) && (List.forall2 (fn (t1, ty1) (t2, ty2) -> (t1 = t2) && (match (ty1, ty2) with
    | (None, None) -> true
    | (Some a, Some b) -> types_compatible a b
    | _ -> false
    )) tags1 tags2)

  pub let rec subtype t1 t2 =
    let t1 = repr t1 in
    let t2 = repr t2 in
    match (t1, t2) with
    | (TInt, TInt) | (TFloat, TFloat) | (TBool, TBool) | (TString, TString) | (TByte, TByte) | (TRune, TRune) | (TUnit, TUnit) -> true
    | (TVariant ((a, args_a)), TVariant ((b, args_b))) -> (a = b) && (((List.length args_a) = (List.length args_b)) && (List.forall2 subtype args_a args_b))
    | (TArrow ((a1, _e1, r1)), TArrow ((a2, _e2, r2))) | (TCont ((a1, _e1, r1)), TCont ((a2, _e2, r2))) -> (subtype a2 a1) && (subtype r1 r2)
    | (TRecord r1, TRecord r2) -> 
      let f1 = record_row_to_fields r1 in
      let f2 = record_row_to_fields r2 in
      List.forall (fn (f, t2') ->
        do
          match List.assoc_opt f f1 with
          | Some t1' -> subtype t1' t2'
          | None -> false

        end) f2
    | (TList t1', TList t2') -> subtype t1' t2'
    | (TArray t1', TArray t2') -> subtype t1' t2'
    | (TTuple ts1, TTuple ts2) -> ((List.length ts1) = (List.length ts2)) && (List.forall2 subtype ts1 ts2)
    | (TVar r1, TVar r2) when r1 = r2 -> true
    | _ -> false


  pub let rec equal_ty t1 t2 =
    let t1 = repr t1 in
    let t2 = repr t2 in
    match (t1, t2) with
    | (TInt, TInt) | (TFloat, TFloat) | (TBool, TBool) | (TString, TString) | (TByte, TByte) | (TRune, TRune) | (TUnit, TUnit) -> true
    | (TVariant ((a, args_a)), TVariant ((b, args_b))) -> (a = b) && (((List.length args_a) = (List.length args_b)) && (List.forall2 equal_ty args_a args_b))
    | (TArrow ((a1, _e1, r1)), TArrow ((a2, _e2, r2))) | (TCont ((a1, _e1, r1)), TCont ((a2, _e2, r2))) -> (equal_ty a1 a2) && (equal_ty r1 r2)
    | (TRecord r1, TRecord r2) -> 
      let f1 = record_row_to_fields r1 in
      let f2 = record_row_to_fields r2 in
      ((List.length f1) = (List.length f2)) && (List.forall2 (fn (n1, t1) (n2, t2) -> (n1 = n2) && (equal_ty t1 t2)) f1 f2)
    | (TList t1', TList t2') -> equal_ty t1' t2'
    | (TArray t1', TArray t2') -> equal_ty t1' t2'
    | (TTuple ts1, TTuple ts2) -> ((List.length ts1) = (List.length ts2)) && (List.forall2 equal_ty ts1 ts2)
    | (TVar r1, TVar r2) -> r1 = r2
    | _ -> false


  pub let freshen_unbound ty =
    let tbl = Hashtbl.create 4 in
    let rec go ty =
      match repr ty with
      | TVar {contents = Unbound ((id, level))} -> 
        do
          match Hashtbl.get tbl id with
          | Some tv -> tv
          | None -> 
            let tv = new_tvar level in
            Hashtbl.set tbl id tv;
            tv

        end
      | TArrow ((a, eff, r)) -> TArrow (go a, go_eff eff, go r)
      | TCont ((a, eff, r)) -> TCont (go a, go_eff eff, go r)
      | TTuple ts -> TTuple (List.map go ts)
      | TList t -> TList (go t)
      | TArray t -> TArray (go t)
      | TRecord row -> TRecord (go_rrow row)
      | TPolyVariant row -> TPolyVariant (go_pv row)
      | TVariant ((name, args)) -> TVariant (name, List.map go args)
      | t -> t

    and go_eff eff =
      match eff_repr eff with
      | EffRow ((label, tys, tail)) -> EffRow (label, List.map go tys, go_eff tail)
      | e -> e

    and go_rrow =
      fn
        | RRow ((name, ty, tail)) -> RRow (name, go ty, go_rrow tail)
        | r -> r

    and go_pv =
      fn
        | PVRow ((tag, payload, tail)) -> PVRow (tag, Option.map go payload, go_pv tail)
        | p -> p
     in
    go ty

  pub let match_partial_inst inst_tys partial =
    let (bindings : (int, ty) Hashtbl.t) = Hashtbl.create 4 in
    let rec match_one inst conc =
      match inst with
      | TGen i -> 
        do
          match Hashtbl.get bindings i with
          | Some prev -> 
            do
              if equal_ty prev conc do
                true
              else
                do try
                  unify prev conc;
                  true
                with
                | unify_error _ -> false
                end
            end
          | None -> 
            Hashtbl.set bindings i conc;
            true

        end
      | TInt -> 
        do
          match repr conc with
          | TInt -> true
          | _ -> false

        end
      | TFloat -> 
        do
          match repr conc with
          | TFloat -> true
          | _ -> false

        end
      | TBool -> 
        do
          match repr conc with
          | TBool -> true
          | _ -> false

        end
      | TString -> 
        do
          match repr conc with
          | TString -> true
          | _ -> false

        end
      | TUnit -> 
        do
          match repr conc with
          | TUnit -> true
          | _ -> false

        end
      | TList a -> 
        do
          match repr conc with
          | TList b -> match_one a b
          | _ -> false

        end
      | TArray a -> 
        do
          match repr conc with
          | TArray b -> match_one a b
          | _ -> false

        end
      | TTuple ts1 -> 
        do
          match repr conc with
          | TTuple ts2 when (List.length ts1) = (List.length ts2) -> List.forall2 match_one ts1 ts2
          | _ -> false

        end
      | TArrow ((a1, _e1, a2)) -> 
        do
          match repr conc with
          | TArrow ((b1, _e2, b2)) -> (match_one a1 b1) && (match_one a2 b2)
          | _ -> false

        end
      | TCont ((a1, _e1, a2)) -> 
        do
          match repr conc with
          | TCont ((b1, _e2, b2)) -> (match_one a1 b1) && (match_one a2 b2)
          | _ -> false

        end
      | TRecord r1 -> 
        do
          match repr conc with
          | TRecord r2 -> 
            let f1 = record_row_to_fields r1 in
            let f2 = record_row_to_fields r2 in
            ((List.length f1) = (List.length f2)) && (List.forall2 (fn (n1, t1) (n2, t2) -> (n1 = n2) && (match_one t1 t2)) f1 f2)
          | _ -> false

        end
      | TVariant ((a, args_inst)) -> 
        do
          match repr conc with
          | TVariant ((b, args_conc)) when (a = b) && ((List.length args_inst) = (List.length args_conc)) -> List.forall2 match_one args_inst args_conc
          | _ -> false

        end
      | _ -> equal_ty inst conc
     in
    ((List.length inst_tys) = (List.length partial)) && (List.forall2 (fn inst_ty found_opt ->
      do
        match found_opt with
        | None -> true
        | Some conc_ty -> match_one inst_ty conc_ty

      end) inst_tys partial)

  pub let inst_specificity (inst : instance_def) =
    let rec count =
      fn
        | TGen _ -> 0
        | TInt | TFloat | TBool | TString | TByte | TRune | TUnit -> 1
        | TArrow ((a, _, b)) | TCont ((a, _, b)) -> (count a) + (count b)
        | TTuple ts -> List.fold (fn acc t -> acc + (count t)) 0 ts
        | TList a | TArray a -> count a
        | TRecord row -> List.fold (fn acc (_, t) -> acc + (count t)) 0 (record_row_to_fields row)
        | TVariant ((_, ts)) -> List.fold (fn acc t -> acc + (count t)) 0 ts
        | TPolyVariant _ -> 0
        | TVar {contents = Link t} -> count t
        | TVar {contents = Unbound _} -> 0
     in
    List.fold (fn acc ty -> acc + (count ty)) 0 inst.inst_tys

  pub let most_specific_inst insts =
    match insts with
    | [] -> None
    | x :: [] -> Some x
    | _ -> 
      do
        let scored = List.map (fn i -> (inst_specificity i, i)) insts in
        let sorted = List.sort (fn (a, _) (b, _) -> compare b a) scored in
        match sorted with
        | (s1, i1) :: (s2, _) :: _ when s1 > s2 -> Some i1
        | _ -> None

      end


  pub let find_instance instances class_name tys = List.find (fn inst -> (inst.inst_class = class_name) && (match_partial_inst inst.inst_tys (List.map (fn t -> Some t) tys))) instances

  pub let check_fundep_consistency class_def new_inst existing_instances = List.iter (fn fd -> List.iter (fn existing -> if not (existing.inst_class = new_inst.inst_class) do
    ()
  else if (List.length existing.inst_tys) <> (List.length new_inst.inst_tys) do
    ()
  else do
    let from_match = List.forall (fn i -> let ex_ty = List.nth existing.inst_tys i in
    let new_ty = List.nth new_inst.inst_tys i in
    equal_ty ex_ty new_ty) fd.fd_from in
    if from_match do
      let to_match = List.forall (fn i -> let ex_ty = List.nth existing.inst_tys i in
      let new_ty = List.nth new_inst.inst_tys i in
      equal_ty ex_ty new_ty) fd.fd_to in
      if not to_match do
        let from_strs = List.map (fn i -> pp_ty (List.nth new_inst.inst_tys i)) fd.fd_from in
        let to_strs_new = List.map (fn i -> pp_ty (List.nth new_inst.inst_tys i)) fd.fd_to in
        let to_strs_ex = List.map (fn i -> pp_ty (List.nth existing.inst_tys i)) fd.fd_to in
        perform unify_error ($"functional dependency violation in class {class_def.class_name}: type(s) {String.concat ", " from_strs} determine {String.concat ", " to_strs_new}, but existing instance has {String.concat ", " to_strs_ex}")
      end
    end
  end) existing_instances) class_def.class_fundeps

  pub let improve_with_fundeps instances class_def partial = List.fold (fn partial fd -> let from_known = List.forall (fn i -> (i < (List.length partial)) && ((List.nth partial i) <> None)) fd.fd_from in
  if not from_known do
    partial
  else do
    let from_partial = List.mapi (fn i opt -> if List.mem i fd.fd_from do
      opt
    else
      None) partial in
    let matching = List.filter (fn inst -> (inst.inst_class = class_def.class_name) && (((List.length inst.inst_tys) = (List.length partial)) && (match_partial_inst inst.inst_tys from_partial))) instances in
    match matching with
    | inst :: [] -> 
      let (subst : (int, ty) Hashtbl.t) = Hashtbl.create 4 in
      List.iter (fn i -> let inst_ty = List.nth inst.inst_tys i in
      let conc_ty = Option.unwrap (List.nth partial i) in
      let rec extract_bindings pat conc =
        match (pat, repr conc) with
        | (TGen g, ty) -> Hashtbl.set subst g ty
        | (TList a, TList b) -> extract_bindings a b
        | (TArray a, TArray b) -> extract_bindings a b
        | (TTuple ts1, TTuple ts2) when (List.length ts1) = (List.length ts2) -> List.iter2 extract_bindings ts1 ts2
        | (TVariant ((_, args1)), TVariant ((_, args2))) when (List.length args1) = (List.length args2) -> List.iter2 extract_bindings args1 args2
        | (TArrow ((a1, _, r1)), TArrow ((a2, _, r2))) | (TCont ((a1, _, r1)), TCont ((a2, _, r2))) -> 
          extract_bindings a1 a2;
          extract_bindings r1 r2
        | _ -> ()
       in
      extract_bindings inst_ty conc_ty) fd.fd_from;
      let rec apply_subst ty =
        match ty with
        | TGen g -> 
          do
            match Hashtbl.get subst g with
            | Some t -> t
            | None -> ty

          end
        | TList a -> TList (apply_subst a)
        | TArray a -> TArray (apply_subst a)
        | TTuple ts -> TTuple (List.map apply_subst ts)
        | TVariant ((n, args)) -> TVariant (n, List.map apply_subst args)
        | TArrow ((a, e, r)) -> TArrow (apply_subst a, e, apply_subst r)
        | TCont ((a, e, r)) -> TCont (apply_subst a, e, apply_subst r)
        | _ -> ty
       in
      List.mapi (fn i opt -> if opt <> None do
        opt
      else if List.mem i fd.fd_to do
        Some (apply_subst (List.nth inst.inst_tys i))
      else
        opt) partial
    | _ -> partial

  end) partial class_def.class_fundeps

end
