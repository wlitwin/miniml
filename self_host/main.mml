module Main =
  open Token
  open Ast
  open Types
  open Typechecker
  open Bytecode
  open Compiler
  open Serialize
  open Js_codegen
  open Lexer
  open Parser

  -- ---- Helpers ----

  let rec list_iter f xs =
    match xs with
    | [] -> ()
    | x :: rest -> f x; list_iter f rest

  let rec list_iteri_aux f i xs =
    match xs with
    | [] -> ()
    | x :: rest -> f i x; list_iteri_aux f (i + 1) rest

  let list_iteri f xs = list_iteri_aux f 0 xs

  -- ---- Native global tracking ----
  -- We track native globals as a list of JSON fragments

  let mut native_global_entries = ([] : string list)

  let register_native_ext idx name arity =
    native_global_entries := serialize_native_ext idx name arity :: native_global_entries

  let register_native_dict idx fields =
    native_global_entries := serialize_native_dict idx fields :: native_global_entries

  let build_native_globals_json () =
    String.concat "," (List.rev native_global_entries)

  -- ---- Builtin registration helpers ----

  let add_global global_names name =
    let idx = Dynarray.length global_names in
    Dynarray.push global_names name;
    idx

  let register_builtin (ctx : Typechecker.ctx) global_names name ty quant arity =
    let scheme = { quant = quant; equant = 0; pvquant = 0; rquant = 0; constraints = []; record_evidences = []; body = ty } in
    let idx = add_global global_names name in
    register_native_ext idx name arity;
    -- Also register under Stdlib. prefix
    let stdlib_name = "Stdlib." ^ name in
    let sidx = add_global global_names stdlib_name in
    register_native_ext sidx name arity;
    let vars = (stdlib_name, scheme) :: (name, scheme) :: ctx.vars in
    (scheme, { ctx with vars = vars })

  let register_module_fn (ctx : Typechecker.ctx) global_names mod_name fn_name ty arity =
    let qualified = mod_name ^ "." ^ fn_name in
    let idx = add_global global_names qualified in
    register_native_ext idx qualified arity;
    let max_gen = Typechecker.max_tgen_in_ty ty in
    let scheme = if max_gen >= 0 do { quant = max_gen + 1; equant = 0; pvquant = 0; rquant = 0; constraints = []; record_evidences = []; body = ty }
                 else mono ty in
    let vars = (qualified, scheme) :: ctx.vars in
    ((fn_name, scheme), { ctx with vars = vars })

  let register_class_in_ctx (ctx : Typechecker.ctx) name tyvars methods =
    let num_params = List.length tyvars in
    let class_def = {
      class_name = name;
      class_params = tyvars;
      class_methods = methods;
      class_fundeps = [];
    } in
    let new_vars = List.fold (fn vars (mname, mty) ->
      let max_gen = Typechecker.max_tgen_in_ty mty in
      let quant = if max_gen + 1 > num_params do max_gen + 1 else num_params in
      (mname, { quant = quant; equant = 0; pvquant = 0; rquant = 0; constraints = []; record_evidences = []; body = mty }) :: vars
    ) ctx.vars methods in
    let type_env = { ctx.type_env with classes = class_def :: ctx.type_env.classes } in
    { ctx with vars = new_vars; type_env = type_env }

  let register_native_instance (ctx : Typechecker.ctx) global_names class_name tys methods =
    -- methods: (method_name, ext_name, arity) list
    let dname = dict_name class_name tys in
    let idx = add_global global_names dname in
    let dict_fields = List.map (fn (mname, ext_name, arity) -> (mname, ext_name, arity)) methods in
    register_native_dict idx dict_fields;
    -- Also register individual method globals for direct dispatch (sorted by method name)
    let sorted = List.sort (fn (a, _, _) (b, _, _) -> String.compare a b) methods in
    List.iter (fn (mname, ext_name, arity) ->
      let midx = add_global global_names (dname ^ "$" ^ mname) in
      register_native_ext midx ext_name arity
    ) sorted;
    let inst = {
      inst_class = class_name;
      inst_tys = tys;
      inst_dict_name = dname;
      inst_constraints = [];
    } in
    let type_env = { ctx.type_env with instances = inst :: ctx.type_env.instances } in
    { ctx with type_env = type_env }

  -- ---- JS capture mode ----
  -- When true, compile_setup captures typed ASTs and skips bytecode compilation

  let mut js_capture_mode = false
  let mut captured_typed_setups = ([] : (Types.type_env * Typechecker.tprogram) list)

  -- ---- Compile a setup source string ----

  let compile_setup (ctx : Typechecker.ctx) global_names mutable_globals source =
    let tokens = Lexer.tokenize source in
    let program = Parser.parse_program tokens in
    let (ctx2, typed_program) = Typechecker.check_program_in_ctx ctx program in
    let typed_program2 = Typechecker.transform_constraints ctx2 typed_program in
    if js_capture_mode do
      captured_typed_setups := List.concat captured_typed_setups [(ctx2.type_env, typed_program2)];
      (ctx2, { name = ""; arity = 0; num_locals = 0;
               code = Array.of_list []; constants = Array.of_list [];
               line_table = Array.of_list [] })
    else
      let compiled = Compiler.compile_program_with_globals ctx2.type_env global_names mutable_globals typed_program2 in
      (ctx2, compiled.main)

  -- ---- Arrow type helpers ----

  let arr a b = TArrow (a, EffEmpty, b)
  let arr2 a b c = arr a (arr b c)
  let arr3 a b c d = arr a (arr b (arr c d))

  -- ---- Setup builtins ----

  let setup_builtins () =
    let global_names = Dynarray.create 256 "" in
    let mutable_globals = Hashtbl.create 8 in
    let mut stdlib_pub_vars = ([] : (string * scheme) list) in

    let int2 = arr2 TInt TInt TInt in
    let bool2 = arr2 TBool TBool TBool in

    let mut ctx = Typechecker.empty_ctx in

    -- mod
    let (sch, ctx2) = register_builtin ctx global_names "mod" int2 0 2 in
    ctx := ctx2; stdlib_pub_vars := ("mod", sch) :: stdlib_pub_vars;
    -- print
    let (sch, ctx2) = register_builtin ctx global_names "print" (arr (TGen 0) TUnit) 1 1 in
    ctx := ctx2; stdlib_pub_vars := ("print", sch) :: stdlib_pub_vars;
    -- failwith
    let (sch, ctx2) = register_builtin ctx global_names "failwith" (arr TString (TGen 0)) 1 1 in
    ctx := ctx2; stdlib_pub_vars := ("failwith", sch) :: stdlib_pub_vars;
    -- ^
    let (sch, ctx2) = register_builtin ctx global_names "^" (arr2 TString TString TString) 0 2 in
    ctx := ctx2; stdlib_pub_vars := ("^", sch) :: stdlib_pub_vars;
    -- &&
    let (sch, ctx2) = register_builtin ctx global_names "&&" bool2 0 2 in
    ctx := ctx2; stdlib_pub_vars := ("&&", sch) :: stdlib_pub_vars;
    -- ||
    let (sch, ctx2) = register_builtin ctx global_names "||" bool2 0 2 in
    ctx := ctx2; stdlib_pub_vars := ("||", sch) :: stdlib_pub_vars;
    -- not
    let (sch, ctx2) = register_builtin ctx global_names "not" (arr TBool TBool) 0 1 in
    ctx := ctx2; stdlib_pub_vars := ("not", sch) :: stdlib_pub_vars;
    -- phys_equal
    let (sch, ctx2) = register_builtin ctx global_names "phys_equal" (arr2 (TGen 0) (TGen 0) TBool) 1 2 in
    ctx := ctx2; stdlib_pub_vars := ("phys_equal", sch) :: stdlib_pub_vars;
    -- float_of_int
    let (sch, ctx2) = register_builtin ctx global_names "float_of_int" (arr TInt TFloat) 0 1 in
    ctx := ctx2; stdlib_pub_vars := ("float_of_int", sch) :: stdlib_pub_vars;
    -- int_of_float
    let (sch, ctx2) = register_builtin ctx global_names "int_of_float" (arr TFloat TInt) 0 1 in
    ctx := ctx2; stdlib_pub_vars := ("int_of_float", sch) :: stdlib_pub_vars;
    -- string_of_int
    let (sch, ctx2) = register_builtin ctx global_names "string_of_int" (arr TInt TString) 0 1 in
    ctx := ctx2; stdlib_pub_vars := ("string_of_int", sch) :: stdlib_pub_vars;
    -- string_of_float
    let (sch, ctx2) = register_builtin ctx global_names "string_of_float" (arr TFloat TString) 0 1 in
    ctx := ctx2; stdlib_pub_vars := ("string_of_float", sch) :: stdlib_pub_vars;
    -- string_of_bool
    let (sch, ctx2) = register_builtin ctx global_names "string_of_bool" (arr TBool TString) 0 1 in
    ctx := ctx2; stdlib_pub_vars := ("string_of_bool", sch) :: stdlib_pub_vars;
    -- array_get
    let (sch, ctx2) = register_builtin ctx global_names "array_get" (arr2 (TArray (TGen 0)) TInt (TGen 0)) 1 2 in
    ctx := ctx2; stdlib_pub_vars := ("array_get", sch) :: stdlib_pub_vars;
    -- array_length
    let (sch, ctx2) = register_builtin ctx global_names "array_length" (arr (TArray (TGen 0)) TInt) 1 1 in
    ctx := ctx2; stdlib_pub_vars := ("array_length", sch) :: stdlib_pub_vars;
    -- __byte_to_int
    let (sch, ctx2) = register_builtin ctx global_names "__byte_to_int" (arr TByte TInt) 0 1 in
    ctx := ctx2; stdlib_pub_vars := ("__byte_to_int", sch) :: stdlib_pub_vars;
    -- __byte_of_int
    let (sch, ctx2) = register_builtin ctx global_names "__byte_of_int" (arr TInt TByte) 0 1 in
    ctx := ctx2; stdlib_pub_vars := ("__byte_of_int", sch) :: stdlib_pub_vars;
    -- __byte_to_string
    let (sch, ctx2) = register_builtin ctx global_names "__byte_to_string" (arr TByte TString) 0 1 in
    ctx := ctx2; stdlib_pub_vars := ("__byte_to_string", sch) :: stdlib_pub_vars;
    -- __rune_to_int
    let (sch, ctx2) = register_builtin ctx global_names "__rune_to_int" (arr TRune TInt) 0 1 in
    ctx := ctx2; stdlib_pub_vars := ("__rune_to_int", sch) :: stdlib_pub_vars;
    -- __rune_of_int
    let (sch, ctx2) = register_builtin ctx global_names "__rune_of_int" (arr TInt TRune) 0 1 in
    ctx := ctx2; stdlib_pub_vars := ("__rune_of_int", sch) :: stdlib_pub_vars;
    -- __rune_to_string
    let (sch, ctx2) = register_builtin ctx global_names "__rune_to_string" (arr TRune TString) 0 1 in
    ctx := ctx2; stdlib_pub_vars := ("__rune_to_string", sch) :: stdlib_pub_vars;
    -- __math_pow
    let (sch, ctx2) = register_builtin ctx global_names "__math_pow" (arr2 TFloat TFloat TFloat) 0 2 in
    ctx := ctx2; stdlib_pub_vars := ("__math_pow", sch) :: stdlib_pub_vars;
    -- __math_sqrt
    let (sch, ctx2) = register_builtin ctx global_names "__math_sqrt" (arr TFloat TFloat) 0 1 in
    ctx := ctx2; stdlib_pub_vars := ("__math_sqrt", sch) :: stdlib_pub_vars;
    -- __math_floor
    let (sch, ctx2) = register_builtin ctx global_names "__math_floor" (arr TFloat TInt) 0 1 in
    ctx := ctx2; stdlib_pub_vars := ("__math_floor", sch) :: stdlib_pub_vars;
    -- __math_ceil
    let (sch, ctx2) = register_builtin ctx global_names "__math_ceil" (arr TFloat TInt) 0 1 in
    ctx := ctx2; stdlib_pub_vars := ("__math_ceil", sch) :: stdlib_pub_vars;
    -- __math_round
    let (sch, ctx2) = register_builtin ctx global_names "__math_round" (arr TFloat TInt) 0 1 in
    ctx := ctx2; stdlib_pub_vars := ("__math_round", sch) :: stdlib_pub_vars;
    -- __fmt_float
    let (sch, ctx2) = register_builtin ctx global_names "__fmt_float" (arr2 TInt TFloat TString) 0 2 in
    ctx := ctx2; stdlib_pub_vars := ("__fmt_float", sch) :: stdlib_pub_vars;
    -- __fmt_hex
    let (sch, ctx2) = register_builtin ctx global_names "__fmt_hex" (arr TInt TString) 0 1 in
    ctx := ctx2; stdlib_pub_vars := ("__fmt_hex", sch) :: stdlib_pub_vars;
    -- __fmt_hex_upper
    let (sch, ctx2) = register_builtin ctx global_names "__fmt_hex_upper" (arr TInt TString) 0 1 in
    ctx := ctx2; stdlib_pub_vars := ("__fmt_hex_upper", sch) :: stdlib_pub_vars;
    -- __fmt_oct
    let (sch, ctx2) = register_builtin ctx global_names "__fmt_oct" (arr TInt TString) 0 1 in
    ctx := ctx2; stdlib_pub_vars := ("__fmt_oct", sch) :: stdlib_pub_vars;
    -- __fmt_bin
    let (sch, ctx2) = register_builtin ctx global_names "__fmt_bin" (arr TInt TString) 0 1 in
    ctx := ctx2; stdlib_pub_vars := ("__fmt_bin", sch) :: stdlib_pub_vars;
    -- __fmt_zero_pad
    let (sch, ctx2) = register_builtin ctx global_names "__fmt_zero_pad" (arr2 TInt TString TString) 0 2 in
    ctx := ctx2; stdlib_pub_vars := ("__fmt_zero_pad", sch) :: stdlib_pub_vars;
    -- __fmt_pad_left
    let (sch, ctx2) = register_builtin ctx global_names "__fmt_pad_left" (arr2 TInt TString TString) 0 2 in
    ctx := ctx2; stdlib_pub_vars := ("__fmt_pad_left", sch) :: stdlib_pub_vars;
    -- __fmt_pad_right
    let (sch, ctx2) = register_builtin ctx global_names "__fmt_pad_right" (arr2 TInt TString TString) 0 2 in
    ctx := ctx2; stdlib_pub_vars := ("__fmt_pad_right", sch) :: stdlib_pub_vars;
    -- __show_value
    let (sch, ctx2) = register_builtin ctx global_names "__show_value" (arr (TGen 0) TString) 1 1 in
    ctx := ctx2; stdlib_pub_vars := ("__show_value", sch) :: stdlib_pub_vars;

    -- Typeclass primitive externs (referenced by stdlib/classes.mml)
    -- Num
    let (sch, ctx2) = register_builtin ctx global_names "__num_add_int" (arr2 TInt TInt TInt) 0 2 in ctx := ctx2; stdlib_pub_vars := ("__num_add_int", sch) :: stdlib_pub_vars;
    let (sch, ctx2) = register_builtin ctx global_names "__num_sub_int" (arr2 TInt TInt TInt) 0 2 in ctx := ctx2; stdlib_pub_vars := ("__num_sub_int", sch) :: stdlib_pub_vars;
    let (sch, ctx2) = register_builtin ctx global_names "__num_mul_int" (arr2 TInt TInt TInt) 0 2 in ctx := ctx2; stdlib_pub_vars := ("__num_mul_int", sch) :: stdlib_pub_vars;
    let (sch, ctx2) = register_builtin ctx global_names "__num_div_int" (arr2 TInt TInt TInt) 0 2 in ctx := ctx2; stdlib_pub_vars := ("__num_div_int", sch) :: stdlib_pub_vars;
    let (sch, ctx2) = register_builtin ctx global_names "__num_neg_int" (arr TInt TInt) 0 1 in ctx := ctx2; stdlib_pub_vars := ("__num_neg_int", sch) :: stdlib_pub_vars;
    let (sch, ctx2) = register_builtin ctx global_names "__num_add_float" (arr2 TFloat TFloat TFloat) 0 2 in ctx := ctx2; stdlib_pub_vars := ("__num_add_float", sch) :: stdlib_pub_vars;
    let (sch, ctx2) = register_builtin ctx global_names "__num_sub_float" (arr2 TFloat TFloat TFloat) 0 2 in ctx := ctx2; stdlib_pub_vars := ("__num_sub_float", sch) :: stdlib_pub_vars;
    let (sch, ctx2) = register_builtin ctx global_names "__num_mul_float" (arr2 TFloat TFloat TFloat) 0 2 in ctx := ctx2; stdlib_pub_vars := ("__num_mul_float", sch) :: stdlib_pub_vars;
    let (sch, ctx2) = register_builtin ctx global_names "__num_div_float" (arr2 TFloat TFloat TFloat) 0 2 in ctx := ctx2; stdlib_pub_vars := ("__num_div_float", sch) :: stdlib_pub_vars;
    let (sch, ctx2) = register_builtin ctx global_names "__num_neg_float" (arr TFloat TFloat) 0 1 in ctx := ctx2; stdlib_pub_vars := ("__num_neg_float", sch) :: stdlib_pub_vars;
    -- Eq
    let (sch, ctx2) = register_builtin ctx global_names "__eq_int" (arr2 TInt TInt TBool) 0 2 in ctx := ctx2; stdlib_pub_vars := ("__eq_int", sch) :: stdlib_pub_vars;
    let (sch, ctx2) = register_builtin ctx global_names "__neq_int" (arr2 TInt TInt TBool) 0 2 in ctx := ctx2; stdlib_pub_vars := ("__neq_int", sch) :: stdlib_pub_vars;
    let (sch, ctx2) = register_builtin ctx global_names "__eq_float" (arr2 TFloat TFloat TBool) 0 2 in ctx := ctx2; stdlib_pub_vars := ("__eq_float", sch) :: stdlib_pub_vars;
    let (sch, ctx2) = register_builtin ctx global_names "__neq_float" (arr2 TFloat TFloat TBool) 0 2 in ctx := ctx2; stdlib_pub_vars := ("__neq_float", sch) :: stdlib_pub_vars;
    let (sch, ctx2) = register_builtin ctx global_names "__eq_string" (arr2 TString TString TBool) 0 2 in ctx := ctx2; stdlib_pub_vars := ("__eq_string", sch) :: stdlib_pub_vars;
    let (sch, ctx2) = register_builtin ctx global_names "__neq_string" (arr2 TString TString TBool) 0 2 in ctx := ctx2; stdlib_pub_vars := ("__neq_string", sch) :: stdlib_pub_vars;
    let (sch, ctx2) = register_builtin ctx global_names "__eq_bool" (arr2 TBool TBool TBool) 0 2 in ctx := ctx2; stdlib_pub_vars := ("__eq_bool", sch) :: stdlib_pub_vars;
    let (sch, ctx2) = register_builtin ctx global_names "__neq_bool" (arr2 TBool TBool TBool) 0 2 in ctx := ctx2; stdlib_pub_vars := ("__neq_bool", sch) :: stdlib_pub_vars;
    let (sch, ctx2) = register_builtin ctx global_names "__eq_byte" (arr2 TByte TByte TBool) 0 2 in ctx := ctx2; stdlib_pub_vars := ("__eq_byte", sch) :: stdlib_pub_vars;
    let (sch, ctx2) = register_builtin ctx global_names "__neq_byte" (arr2 TByte TByte TBool) 0 2 in ctx := ctx2; stdlib_pub_vars := ("__neq_byte", sch) :: stdlib_pub_vars;
    let (sch, ctx2) = register_builtin ctx global_names "__eq_rune" (arr2 TRune TRune TBool) 0 2 in ctx := ctx2; stdlib_pub_vars := ("__eq_rune", sch) :: stdlib_pub_vars;
    let (sch, ctx2) = register_builtin ctx global_names "__neq_rune" (arr2 TRune TRune TBool) 0 2 in ctx := ctx2; stdlib_pub_vars := ("__neq_rune", sch) :: stdlib_pub_vars;
    -- Ord
    let (sch, ctx2) = register_builtin ctx global_names "__lt_int" (arr2 TInt TInt TBool) 0 2 in ctx := ctx2; stdlib_pub_vars := ("__lt_int", sch) :: stdlib_pub_vars;
    let (sch, ctx2) = register_builtin ctx global_names "__gt_int" (arr2 TInt TInt TBool) 0 2 in ctx := ctx2; stdlib_pub_vars := ("__gt_int", sch) :: stdlib_pub_vars;
    let (sch, ctx2) = register_builtin ctx global_names "__le_int" (arr2 TInt TInt TBool) 0 2 in ctx := ctx2; stdlib_pub_vars := ("__le_int", sch) :: stdlib_pub_vars;
    let (sch, ctx2) = register_builtin ctx global_names "__ge_int" (arr2 TInt TInt TBool) 0 2 in ctx := ctx2; stdlib_pub_vars := ("__ge_int", sch) :: stdlib_pub_vars;
    let (sch, ctx2) = register_builtin ctx global_names "__lt_float" (arr2 TFloat TFloat TBool) 0 2 in ctx := ctx2; stdlib_pub_vars := ("__lt_float", sch) :: stdlib_pub_vars;
    let (sch, ctx2) = register_builtin ctx global_names "__gt_float" (arr2 TFloat TFloat TBool) 0 2 in ctx := ctx2; stdlib_pub_vars := ("__gt_float", sch) :: stdlib_pub_vars;
    let (sch, ctx2) = register_builtin ctx global_names "__le_float" (arr2 TFloat TFloat TBool) 0 2 in ctx := ctx2; stdlib_pub_vars := ("__le_float", sch) :: stdlib_pub_vars;
    let (sch, ctx2) = register_builtin ctx global_names "__ge_float" (arr2 TFloat TFloat TBool) 0 2 in ctx := ctx2; stdlib_pub_vars := ("__ge_float", sch) :: stdlib_pub_vars;
    let (sch, ctx2) = register_builtin ctx global_names "__lt_string" (arr2 TString TString TBool) 0 2 in ctx := ctx2; stdlib_pub_vars := ("__lt_string", sch) :: stdlib_pub_vars;
    let (sch, ctx2) = register_builtin ctx global_names "__gt_string" (arr2 TString TString TBool) 0 2 in ctx := ctx2; stdlib_pub_vars := ("__gt_string", sch) :: stdlib_pub_vars;
    let (sch, ctx2) = register_builtin ctx global_names "__le_string" (arr2 TString TString TBool) 0 2 in ctx := ctx2; stdlib_pub_vars := ("__le_string", sch) :: stdlib_pub_vars;
    let (sch, ctx2) = register_builtin ctx global_names "__ge_string" (arr2 TString TString TBool) 0 2 in ctx := ctx2; stdlib_pub_vars := ("__ge_string", sch) :: stdlib_pub_vars;
    let (sch, ctx2) = register_builtin ctx global_names "__lt_byte" (arr2 TByte TByte TBool) 0 2 in ctx := ctx2; stdlib_pub_vars := ("__lt_byte", sch) :: stdlib_pub_vars;
    let (sch, ctx2) = register_builtin ctx global_names "__gt_byte" (arr2 TByte TByte TBool) 0 2 in ctx := ctx2; stdlib_pub_vars := ("__gt_byte", sch) :: stdlib_pub_vars;
    let (sch, ctx2) = register_builtin ctx global_names "__le_byte" (arr2 TByte TByte TBool) 0 2 in ctx := ctx2; stdlib_pub_vars := ("__le_byte", sch) :: stdlib_pub_vars;
    let (sch, ctx2) = register_builtin ctx global_names "__ge_byte" (arr2 TByte TByte TBool) 0 2 in ctx := ctx2; stdlib_pub_vars := ("__ge_byte", sch) :: stdlib_pub_vars;
    let (sch, ctx2) = register_builtin ctx global_names "__lt_rune" (arr2 TRune TRune TBool) 0 2 in ctx := ctx2; stdlib_pub_vars := ("__lt_rune", sch) :: stdlib_pub_vars;
    let (sch, ctx2) = register_builtin ctx global_names "__gt_rune" (arr2 TRune TRune TBool) 0 2 in ctx := ctx2; stdlib_pub_vars := ("__gt_rune", sch) :: stdlib_pub_vars;
    let (sch, ctx2) = register_builtin ctx global_names "__le_rune" (arr2 TRune TRune TBool) 0 2 in ctx := ctx2; stdlib_pub_vars := ("__le_rune", sch) :: stdlib_pub_vars;
    let (sch, ctx2) = register_builtin ctx global_names "__ge_rune" (arr2 TRune TRune TBool) 0 2 in ctx := ctx2; stdlib_pub_vars := ("__ge_rune", sch) :: stdlib_pub_vars;
    -- Bitwise
    let (sch, ctx2) = register_builtin ctx global_names "__band_int" (arr2 TInt TInt TInt) 0 2 in ctx := ctx2; stdlib_pub_vars := ("__band_int", sch) :: stdlib_pub_vars;
    let (sch, ctx2) = register_builtin ctx global_names "__bor_int" (arr2 TInt TInt TInt) 0 2 in ctx := ctx2; stdlib_pub_vars := ("__bor_int", sch) :: stdlib_pub_vars;
    let (sch, ctx2) = register_builtin ctx global_names "__bxor_int" (arr2 TInt TInt TInt) 0 2 in ctx := ctx2; stdlib_pub_vars := ("__bxor_int", sch) :: stdlib_pub_vars;
    let (sch, ctx2) = register_builtin ctx global_names "__bshl_int" (arr2 TInt TInt TInt) 0 2 in ctx := ctx2; stdlib_pub_vars := ("__bshl_int", sch) :: stdlib_pub_vars;
    let (sch, ctx2) = register_builtin ctx global_names "__bshr_int" (arr2 TInt TInt TInt) 0 2 in ctx := ctx2; stdlib_pub_vars := ("__bshr_int", sch) :: stdlib_pub_vars;
    let (sch, ctx2) = register_builtin ctx global_names "__bnot_int" (arr TInt TInt) 0 1 in ctx := ctx2; stdlib_pub_vars := ("__bnot_int", sch) :: stdlib_pub_vars;
    -- Show
    let (sch, ctx2) = register_builtin ctx global_names "__show_int" (arr TInt TString) 0 1 in ctx := ctx2; stdlib_pub_vars := ("__show_int", sch) :: stdlib_pub_vars;
    let (sch, ctx2) = register_builtin ctx global_names "__show_float" (arr TFloat TString) 0 1 in ctx := ctx2; stdlib_pub_vars := ("__show_float", sch) :: stdlib_pub_vars;
    let (sch, ctx2) = register_builtin ctx global_names "__show_bool" (arr TBool TString) 0 1 in ctx := ctx2; stdlib_pub_vars := ("__show_bool", sch) :: stdlib_pub_vars;
    let (sch, ctx2) = register_builtin ctx global_names "__show_string" (arr TString TString) 0 1 in ctx := ctx2; stdlib_pub_vars := ("__show_string", sch) :: stdlib_pub_vars;
    let (sch, ctx2) = register_builtin ctx global_names "__show_unit" (arr TUnit TString) 0 1 in ctx := ctx2; stdlib_pub_vars := ("__show_unit", sch) :: stdlib_pub_vars;
    let (sch, ctx2) = register_builtin ctx global_names "__show_byte" (arr TByte TString) 0 1 in ctx := ctx2; stdlib_pub_vars := ("__show_byte", sch) :: stdlib_pub_vars;
    let (sch, ctx2) = register_builtin ctx global_names "__show_rune" (arr TRune TString) 0 1 in ctx := ctx2; stdlib_pub_vars := ("__show_rune", sch) :: stdlib_pub_vars;
    -- Index
    let (sch, ctx2) = register_builtin ctx global_names "__index_at_array" (arr2 TInt (TArray (TGen 0)) (TGen 0)) 1 2 in ctx := ctx2; stdlib_pub_vars := ("__index_at_array", sch) :: stdlib_pub_vars;
    let (sch, ctx2) = register_builtin ctx global_names "__index_at_string" (arr2 TInt TString TByte) 0 2 in ctx := ctx2; stdlib_pub_vars := ("__index_at_string", sch) :: stdlib_pub_vars;

    -- copy_continuation
    let copy_ty = arr (TGen 0) (TGen 0) in
    let copy_scheme = { quant = 1; equant = 0; pvquant = 0; rquant = 0; constraints = []; record_evidences = []; body = copy_ty } in
    let cidx = add_global global_names "copy_continuation" in
    register_native_ext cidx "copy_continuation" 1;
    let csidx = add_global global_names "Stdlib.copy_continuation" in
    register_native_ext csidx "copy_continuation" 1;
    stdlib_pub_vars := ("copy_continuation", copy_scheme) :: stdlib_pub_vars;
    ctx := { ctx with vars = ("Stdlib.copy_continuation", copy_scheme) :: ("copy_continuation", copy_scheme) :: ctx.vars };

    (ctx, global_names, mutable_globals, stdlib_pub_vars)

  -- ---- Setup type classes and instances from stdlib source ----

  let setup_classes (ctx : Typechecker.ctx) global_names mutable_globals stdlib_pub_vars =
    let mut ctx = ctx in
    let mut setup_protos = ([] : Bytecode.prototype list) in

    let load name =
      let (ctx2, proto) = compile_setup ctx global_names mutable_globals
        (IO.read_file ("stdlib/" ^ name ^ ".mml")) in
      ctx := ctx2; setup_protos := proto :: setup_protos
    in

    -- Load class definitions, primitive instances, and stdlib source
    -- (classes.mml defines Num, Eq, Ord, Bitwise, Show, Iter, Index classes
    --  and their primitive instances via extern declarations)
    load "classes";
    load "option_type";
    load "iter";
    load "map_class";
    load "show";
    -- Build Stdlib module_info
    let stdlib_constructors =
      List.filter (fn (name, _) ->
        name = "None" || name = "Some"
      ) ctx.type_env.constructors
    in
    let stdlib_info = {
      mod_name = "Stdlib"; mod_pub_vars = stdlib_pub_vars;
      mod_pub_mutable_vars = []; mod_pub_types = []; mod_opaque_types = [];
      mod_newtypes = [];
      mod_pub_constructors = stdlib_constructors;
      mod_instances = []; mod_submodules = []; mod_pub_classes = [];
    } in
    ctx := { ctx with type_env = { ctx.type_env with modules = ("Stdlib", stdlib_info) :: ctx.type_env.modules } };

    (ctx, List.rev setup_protos)

  -- ---- Setup all modules (interleaved native + source to match OCaml register_all order) ----

  let setup_modules (ctx : Typechecker.ctx) global_names mutable_globals =
    let mut pub_vars = ([] : (string * scheme) list) in
    let mut ctx = ctx in
    let mut setup_protos = ([] : Bytecode.prototype list) in

    let register_fn mod_name fn_name ty arity =
      let (pv, ctx2) = register_module_fn ctx global_names mod_name fn_name ty arity in
      pub_vars := pv :: pub_vars;
      ctx := ctx2
    in

    let load name =
      let (ctx2, proto) = compile_setup ctx global_names mutable_globals
        (IO.read_file ("stdlib/" ^ name ^ ".mml")) in
      ctx := ctx2; setup_protos := proto :: setup_protos
    in

    let load_source source =
      let (ctx2, proto) = compile_setup ctx global_names mutable_globals source in
      ctx := ctx2; setup_protos := proto :: setup_protos
    in

    -- String module (26 native fns)
    pub_vars := [];
    register_fn "String" "length" (arr TString TInt) 1;
    register_fn "String" "sub" (arr3 TString TInt TInt TString) 3;
    register_fn "String" "split" (arr2 TString TString (TList TString)) 2;
    register_fn "String" "trim" (arr TString TString) 1;
    register_fn "String" "starts_with" (arr2 TString TString TBool) 2;
    register_fn "String" "contains" (arr2 TString TString TBool) 2;
    register_fn "String" "replace" (arr3 TString TString TString TString) 3;
    register_fn "String" "to_int" (arr TString (TVariant ("option", [TInt]))) 1;
    register_fn "String" "to_float" (arr TString (TVariant ("option", [TFloat]))) 1;
    register_fn "String" "uppercase" (arr TString TString) 1;
    register_fn "String" "lowercase" (arr TString TString) 1;
    register_fn "String" "get" (arr2 TString TInt TByte) 2;
    register_fn "String" "to_bytes" (arr TString (TList TByte)) 1;
    register_fn "String" "of_bytes" (arr (TList TByte) TString) 1;
    register_fn "String" "to_byte_array" (arr TString (TArray TByte)) 1;
    register_fn "String" "of_byte_array" (arr (TArray TByte) TString) 1;
    register_fn "String" "to_runes" (arr TString (TList TRune)) 1;
    register_fn "String" "of_runes" (arr (TList TRune) TString) 1;
    register_fn "String" "get_rune" (arr2 TString TInt TRune) 2;
    register_fn "String" "of_byte" (arr TByte TString) 1;
    register_fn "String" "rune_length" (arr TString TInt) 1;
    register_fn "String" "make" (arr2 TInt TByte TString) 2;
    register_fn "String" "index_opt" (arr2 TString TByte (TVariant ("option", [TInt]))) 2;
    register_fn "String" "rindex_opt" (arr2 TString TByte (TVariant ("option", [TInt]))) 2;
    register_fn "String" "concat" (arr2 TString (TList TString) TString) 2;
    register_fn "String" "compare" (arr2 TString TString TInt) 2;
    let string_info = {
      mod_name = "String"; mod_pub_vars = pub_vars;
      mod_pub_mutable_vars = []; mod_pub_types = []; mod_opaque_types = [];
      mod_newtypes = []; mod_pub_constructors = []; mod_instances = []; mod_submodules = []; mod_pub_classes = [];
    } in
    ctx := { ctx with type_env = { ctx.type_env with modules = ("String", string_info) :: ctx.type_env.modules } };
    -- String.iter (source-defined, adds 1 global)
    load_source "module String = pub let iter f s = let n = String.length s in let rec go i = if i >= n do () else (f (String.get s i); go (i + 1)) in go 0 end";

    -- List module (source)
    load "list";

    -- Array module (8 native fns)
    pub_vars := [];
    register_fn "Array" "make" (arr2 TInt (TGen 0) (TArray (TGen 0))) 2;
    register_fn "Array" "get" (arr2 (TArray (TGen 0)) TInt (TGen 0)) 2;
    register_fn "Array" "set" (arr3 (TArray (TGen 0)) TInt (TGen 0) TUnit) 3;
    register_fn "Array" "length" (arr (TArray (TGen 0)) TInt) 1;
    register_fn "Array" "to_list" (arr (TArray (TGen 0)) (TList (TGen 0))) 1;
    register_fn "Array" "of_list" (arr (TList (TGen 0)) (TArray (TGen 0))) 1;
    register_fn "Array" "copy" (arr (TArray (TGen 0)) (TArray (TGen 0))) 1;
    register_fn "Array" "sub" (arr3 (TArray (TGen 0)) TInt TInt (TArray (TGen 0))) 3;
    let array_info = {
      mod_name = "Array"; mod_pub_vars = pub_vars;
      mod_pub_mutable_vars = []; mod_pub_types = []; mod_opaque_types = [];
      mod_newtypes = []; mod_pub_constructors = []; mod_instances = []; mod_submodules = []; mod_pub_classes = [];
    } in
    ctx := { ctx with type_env = { ctx.type_env with modules = ("Array", array_info) :: ctx.type_env.modules } };

    -- array_extra (source)
    load "array_extra";

    -- IO module (5 native fns)
    pub_vars := [];
    register_fn "IO" "read_file" (arr TString TString) 1;
    register_fn "IO" "write_file" (arr2 TString TString TUnit) 2;
    register_fn "IO" "append_file" (arr2 TString TString TUnit) 2;
    register_fn "IO" "read_line" (arr TUnit TString) 1;
    register_fn "IO" "file_exists" (arr TString TBool) 1;
    let io_info = {
      mod_name = "IO"; mod_pub_vars = pub_vars;
      mod_pub_mutable_vars = []; mod_pub_types = []; mod_opaque_types = [];
      mod_newtypes = []; mod_pub_constructors = []; mod_instances = []; mod_submodules = []; mod_pub_classes = [];
    } in
    ctx := { ctx with type_env = { ctx.type_env with modules = ("IO", io_info) :: ctx.type_env.modules } };

    -- Sys module (4 native fns)
    pub_vars := [];
    register_fn "Sys" "args" (arr TUnit (TList TString)) 1;
    register_fn "Sys" "getenv" (arr TString (TVariant ("option", [TString]))) 1;
    register_fn "Sys" "exit" (arr TInt TUnit) 1;
    register_fn "Sys" "time" (arr TUnit TFloat) 1;
    let sys_info = {
      mod_name = "Sys"; mod_pub_vars = pub_vars;
      mod_pub_mutable_vars = []; mod_pub_types = []; mod_opaque_types = [];
      mod_newtypes = []; mod_pub_constructors = []; mod_instances = []; mod_submodules = []; mod_pub_classes = [];
    } in
    ctx := { ctx with type_env = { ctx.type_env with modules = ("Sys", sys_info) :: ctx.type_env.modules } };

    -- Source-defined modules (matching OCaml register_all order)
    load "math";
    load "result";
    load "byte";
    load "rune";
    load "map";
    load "set";
    load "enum";
    load "seq";
    load "option";
    load "buffer";
    load "fmt";
    load "hash";
    load "hashtbl";
    load "ref";
    load "dynarray";
    load "compat";

    -- Runtime module (native, registered last to match OCaml ordering)
    pub_vars := [];
    register_fn "Runtime" "eval" (arr TString TUnit) 1;
    register_fn "Runtime" "eval_file" (arr TString TUnit) 1;
    let runtime_info = {
      mod_name = "Runtime"; mod_pub_vars = pub_vars;
      mod_pub_mutable_vars = []; mod_pub_types = []; mod_opaque_types = [];
      mod_newtypes = []; mod_pub_constructors = []; mod_instances = []; mod_submodules = []; mod_pub_classes = [];
    } in
    ctx := { ctx with type_env = { ctx.type_env with modules = ("Runtime", runtime_info) :: ctx.type_env.modules } };

    (ctx, List.rev setup_protos)

  -- ---- Batch compilation ----

  let run_batch manifest_file =
    handle
      let manifest = IO.read_file manifest_file in
      let files = List.filter (fn s -> s <> "") (String.split "\n" manifest) in

      -- Setup type environment (done once)
      let (ctx, global_names, mutable_globals, stdlib_pub_vars) = setup_builtins () in
      let (ctx, class_protos) = setup_classes ctx global_names mutable_globals stdlib_pub_vars in
      let (ctx, module_protos) = setup_modules ctx global_names mutable_globals in
      let setup_protos = List.concat class_protos module_protos in

      -- Snapshot post-setup mutable state
      let base_gn_len = Dynarray.length global_names in
      let base_native = native_global_entries in
      let base_mutable = Hashtbl.to_list mutable_globals in

      -- Compile each file
      list_iter (fn filename ->
        -- Reset state to post-setup snapshot
        global_names.count := base_gn_len;
        native_global_entries := base_native;
        Hashtbl.clear mutable_globals;
        list_iter (fn (k, v) -> Hashtbl.set mutable_globals k v) base_mutable;

        handle
          let source = IO.read_file filename in
          let tokens = Lexer.tokenize source in
          let program = Parser.parse_program tokens in
          let (ctx2, typed_program) = Typechecker.check_program_in_ctx ctx program in
          let typed_program2 = Typechecker.transform_constraints ctx2 typed_program in
          let compiled = Compiler.compile_program_with_globals ctx2.type_env global_names mutable_globals typed_program2 in
          let ng_json = build_native_globals_json () in
          let json = Serialize.serialize_bundle global_names ng_json setup_protos compiled.main in
          print json;
          print "===BATCH-SEP==="
        with
        | return x -> x
        | lex_error arg _k -> let (msg, _loc) = arg in print ("COMPILE-ERROR:" ^ msg); print "===BATCH-SEP==="
        | parse_error arg _k -> let (msg, _loc) = arg in print ("COMPILE-ERROR:" ^ msg); print "===BATCH-SEP==="
        | type_error arg _k -> let (msg, _loc) = arg in print ("COMPILE-ERROR:" ^ msg); print "===BATCH-SEP==="
        | compile_error msg _k -> print ("COMPILE-ERROR:" ^ msg); print "===BATCH-SEP==="
        | unify_error msg _k -> print ("COMPILE-ERROR:" ^ msg); print "===BATCH-SEP==="
      ) files
    with
    | return x -> x
    | lex_error arg _k -> let (msg, _loc) = arg in failwith msg
    | parse_error arg _k -> let (msg, _loc) = arg in failwith msg
    | type_error arg _k -> let (msg, _loc) = arg in failwith msg
    | compile_error msg _k -> failwith msg
    | unify_error msg _k -> failwith msg

  -- ---- Emit JS ----

  let run_emit_js args =
    handle
      -- Enable JS capture mode â€” compile_setup will capture typed ASTs
      -- and skip bytecode compilation
      js_capture_mode := true;
      captured_typed_setups := [];

      -- Setup type environment (reuses existing setup, but compile_setup
      -- captures typed ASTs instead of producing bytecode)
      let (ctx, global_names, mutable_globals, stdlib_pub_vars) = setup_builtins () in
      let (ctx, _class_protos) = setup_classes ctx global_names mutable_globals stdlib_pub_vars in
      let (ctx, _module_protos) = setup_modules ctx global_names mutable_globals in

      let filename = match args with
        | _ :: file :: _ -> file
        | _ -> failwith "Usage: compiler --emit-js <source-file>"
      in
      let source = IO.read_file filename in

      -- Typecheck user source
      let tokens = Lexer.tokenize source in
      let program = Parser.parse_program tokens in
      let (ctx2, typed_program) = Typechecker.check_program_in_ctx ctx program in
      let typed_program2 = Typechecker.transform_constraints ctx2 typed_program in

      -- Generate JS
      let js = Js_codegen.compile_program_with_stdlib ctx2.type_env captured_typed_setups typed_program2 in
      print js
    with
    | return x -> x
    | lex_error arg _k -> let (msg, _loc) = arg in failwith msg
    | parse_error arg _k -> let (msg, _loc) = arg in failwith msg
    | type_error arg _k -> let (msg, _loc) = arg in failwith msg
    | compile_error msg _k -> failwith msg
    | unify_error msg _k -> failwith msg
    | codegen_error msg _k -> failwith ("JS codegen error: " ^ msg)

  -- ---- Main entry point ----

  let () =
    let args = Sys.args () in
    let batch_file = match args with
      | _ :: "--batch" :: f :: _ -> Some f
      | _ -> None
    in
    let emit_js = List.exists (fn a -> a = "--emit-js") args in
    let no_optimize = List.exists (fn a -> a = "--no-optimize") args in
    if no_optimize do Ref.set Compiler.optimize_enabled false end;
    let args = List.filter (fn a -> a <> "--no-optimize" && a <> "--emit-js") args in
    match batch_file with
    | Some f -> run_batch f
    | None ->
      if emit_js do
        run_emit_js args
      else
        handle
          let filename = match args with
            | _ :: "--emit-json" :: file :: _ -> file
            | _ :: file :: _ -> file
            | _ -> failwith "Usage: compiler [--emit-json | --emit-js | --batch <manifest>] <source-file>"
          in
          let source = IO.read_file filename in

          -- Setup type environment
          let (ctx, global_names, mutable_globals, stdlib_pub_vars) = setup_builtins () in
          let (ctx, class_protos) = setup_classes ctx global_names mutable_globals stdlib_pub_vars in
          let (ctx, module_protos) = setup_modules ctx global_names mutable_globals in
          let setup_protos = List.concat class_protos module_protos in

          -- Compile user source
          let tokens = Lexer.tokenize source in
          let program = Parser.parse_program tokens in
          let (ctx2, typed_program) = Typechecker.check_program_in_ctx ctx program in
          let typed_program2 = Typechecker.transform_constraints ctx2 typed_program in
          let compiled = Compiler.compile_program_with_globals ctx2.type_env global_names mutable_globals typed_program2 in

          -- Serialize
          let ng_json = build_native_globals_json () in
          let json = Serialize.serialize_bundle global_names ng_json setup_protos compiled.main in
          print json
        with
        | return x -> x
        | lex_error arg _k -> let (msg, _loc) = arg in failwith msg
        | parse_error arg _k -> let (msg, _loc) = arg in failwith msg
        | type_error arg _k -> let (msg, _loc) = arg in failwith msg
        | compile_error msg _k -> failwith msg
        | unify_error msg _k -> failwith msg
end
