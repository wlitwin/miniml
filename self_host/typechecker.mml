module Typechecker =
  effect Type_errorExn =
    type_error : string * Token.loc -> 'a
  end

  pub type texpr = {
    expr: texpr_kind;
    ty: Types.ty;
    loc: Token.loc
  }
  and texpr_kind =
    | TEInt of int
    | TEFloat of float
    | TEBool of bool
    | TEString of string
    | TEByte of int
    | TERune of int
    | TEUnit
    | TEVar of string
    | TELet of string * Types.scheme option * texpr * texpr
    | TELetRec of string * Types.scheme option * texpr * texpr
    | TEFun of string * texpr * bool
    | TEApp of texpr * texpr
    | TEIf of texpr * texpr * texpr
    | TEBinop of Ast.binop * texpr * texpr
    | TEUnop of Ast.unop * texpr
    | TETuple of texpr list
    | TERecord of (string * texpr) list
    | TERecordUpdate of texpr * (string * texpr) list
    | TERecordUpdateIdx of texpr * (texpr * texpr) list
    | TEField of texpr * string
    | TEIndex of texpr * texpr
    | TECons of texpr * texpr
    | TENil
    | TEConstruct of string * texpr option
    | TEMatch of texpr * (Ast.pattern * texpr option * texpr) list * bool
    | TELetMut of string * texpr * texpr
    | TEAssign of string * texpr
    | TEFieldAssign of texpr * string * texpr
    | TESeq of texpr * texpr
    | TEPerform of string * texpr
    | TEHandle of texpr * thandle_arm list
    | TEResume of texpr * texpr
    | TEWhile of texpr * texpr
    | TEBreak of texpr
    | TEContinueLoop
    | TEFoldContinue of texpr
    | TEForLoop of texpr
    | TELetRecAnd of (string * texpr) list * texpr
    | TEMap of (texpr * texpr) list
    | TEArray of texpr list
    | TEReturn of texpr

  and thandle_arm =
    | THReturn of string * texpr
    | THOp of string * string * string * texpr


  pub type tdecl =
    | TDLet of string * texpr
    | TDLetMut of string * texpr
    | TDLetRec of string * texpr
    | TDLetRecAnd of (string * texpr) list
    | TDType of string * Ast.type_def
    | TDExpr of texpr
    | TDClass of string
    | TDEffect of string
    | TDExtern of string * Types.scheme
    | TDModule of string * tdecl list
    | TDOpen of (string * string) list


  pub type tprogram = tdecl list

  pub type loop_info =
    | WhileLoop
    | UnitLoop
    | FoldLoop of string


  pub type ctx = {
    vars: (string * Types.scheme) list;
    mutable_vars: string list;
    type_env: Types.type_env;
    loop_info: loop_info option;
    current_module: string option;
    constraint_tvars: int list;
    current_eff: Types.eff;
    return_type: Types.ty option;
    inside_handler: bool;
    return_used: bool Ref.t
  }

  pub let current_loc = Ref.create {line = 0; col = 0; offset = 0}

  pub let error msg = perform type_error (msg, Ref.get current_loc)

  pub let rec strip_loc (expr : Ast.expr) =
    match expr with
    | Ast.ELoc ((_, inner)) -> strip_loc inner
    | e -> e


  pub let try_unify t1 t2 = do try
    Types.unify t1 t2
  with
  | unify_error msg -> error msg
  end

  pub let try_unify_eff e1 e2 = do try
    Types.unify_eff e1 e2
  with
  | unify_error msg -> error msg
  end

  pub let try_subeffect source target = do try
    Types.subeffect source target
  with
  | unify_error msg -> error msg
  end

  pub let rec max_tgen_in_ty =
    fn
      | Types.TGen i -> i
      | Types.TArrow ((a, _, b)) | Types.TCont ((a, _, b)) -> max (max_tgen_in_ty a) (max_tgen_in_ty b)
      | Types.TTuple ts -> List.fold (fn acc t -> max acc (max_tgen_in_ty t)) (-1) ts
      | Types.TList t -> max_tgen_in_ty t
      | Types.TRecord row -> max_tgen_in_rrow row
      | Types.TVariant ((_, args)) -> List.fold (fn acc t -> max acc (max_tgen_in_ty t)) (-1) args
      | Types.TMap ((k, v)) -> max (max_tgen_in_ty k) (max_tgen_in_ty v)
      | Types.TArray t -> max_tgen_in_ty t
      | _ -> (-1)

  and max_tgen_in_rrow =
    fn
      | Types.RRow ((_, ty, tail)) -> max (max_tgen_in_ty ty) (max_tgen_in_rrow tail)
      | Types.RGen _ -> (-1)
      | _ -> (-1)


  pub let rec max_effgen_in_eff =
    fn
      | Types.EffGen i -> i
      | Types.EffRow ((_, params, tail)) -> 
        let ty_max = List.fold (fn acc t -> max acc (max_tgen_in_ty t)) (-1) params in
        max ty_max (max_effgen_in_eff tail)
      | _ -> (-1)


  pub let max_effgen_in_ty =
    fn
      | Types.TArrow ((a, eff, b)) | Types.TCont ((a, eff, b)) -> max (max (max_tgen_in_ty a) (max_tgen_in_ty b)) (max_effgen_in_eff eff)
      | _ -> (-1)


  pub let lookup_var ctx level name =
    match List.assoc_opt name ctx.vars with
    | Some scheme -> Types.instantiate level scheme
    | None -> 
      do
        match String.rindex_opt name #2e with
        | Some i -> 
          do
            let class_prefix = String.sub name 0 i in
            let method_name = String.sub name (i + 1) (((String.length name) - i) - 1) in
            match List.find (fn cls -> (cls.class_name = class_prefix) && (List.exists (fn (m, _) -> m = method_name) cls.class_methods)) ctx.type_env.classes with
            | Some class_def -> 
              let method_ty = List.assoc method_name class_def.class_methods in
              let num_class_params = List.length class_def.class_params in
              let max_gen = max_tgen_in_ty method_ty in
              let quant = max (max_gen + 1) num_class_params in
              let max_effgen = max_effgen_in_ty method_ty in
              let equant =
                if max_effgen >= 0 do
                  max_effgen + 1
                else
                  0 in
              let scheme = {quant; equant; pvquant = 0; rquant = 0; constraints = []; record_evidences = []; body = method_ty} in
              Types.instantiate level scheme
            | None -> error ($"unbound variable: {name}")

          end
        | None -> error ($"unbound variable: {name}")

      end


  pub let extend_var ctx name scheme = {ctx with vars = (name, scheme) :: ctx.vars; mutable_vars = List.filter (fn n -> n <> name) ctx.mutable_vars}

  pub let extend_var_mono ctx name ty = extend_var ctx name (Types.mono ty)

  pub let extend_var_mutable ctx name scheme = {ctx with vars = (name, scheme) :: ctx.vars; mutable_vars = name :: List.filter (fn n -> n <> name) ctx.mutable_vars}

  pub let resolve_type_alias type_env name =
    match List.assoc_opt name type_env.type_aliases with
    | Some canonical -> canonical
    | None -> name


  pub let find_variant_info type_env name =
    let name = resolve_type_alias type_env name in
    List.find (fn (n, _, _, _) -> n = name) type_env.variants

  pub let subst_tgens inst_tys ty =
    let arr = Array.of_list inst_tys in
    let rec go =
      fn
        | Types.TGen i when i < (Array.length arr) -> Array.get arr i
        | Types.TArrow ((a, eff, b)) -> Types.TArrow (go a, go_eff eff, go b)
        | Types.TCont ((a, eff, b)) -> Types.TCont (go a, go_eff eff, go b)
        | Types.TTuple ts -> Types.TTuple (List.map go ts)
        | Types.TList t -> Types.TList (go t)
        | Types.TArray t -> Types.TArray (go t)
        | Types.TRecord row -> Types.TRecord (go_rrow row)
        | Types.TVariant ((name, args)) -> Types.TVariant (name, List.map go args)
        | Types.TPolyVariant row -> Types.TPolyVariant (go_pv row)
        | Types.TMap ((k, v)) -> Types.TMap (go k, go v)
        | t -> t

    and go_eff =
      fn
        | Types.EffRow ((label, params, tail)) -> Types.EffRow (label, List.map go params, go_eff tail)
        | e -> e

    and go_pv =
      fn
        | Types.PVRow ((tag, ty_opt, tail)) -> Types.PVRow (tag, Option.map go ty_opt, go_pv tail)
        | r -> r

    and go_rrow =
      fn
        | Types.RRow ((name, ty, tail)) -> Types.RRow (name, go ty, go_rrow tail)
        | r -> r
     in
    go ty

  pub let freshen_arrow_effects level ty =
    let rec go =
      fn
        | Types.TArrow ((a, eff, b)) -> 
          let eff' =
            match eff with
            | Types.EffEmpty -> Types.new_effvar level
            | e -> e
           in
          Types.TArrow (go a, eff', go b)
        | Types.TCont ((a, eff, b)) -> 
          let eff' =
            match eff with
            | Types.EffEmpty -> Types.new_effvar level
            | e -> e
           in
          Types.TCont (go a, eff', go b)
        | Types.TTuple ts -> Types.TTuple (List.map go ts)
        | Types.TList t -> Types.TList (go t)
        | Types.TArray t -> Types.TArray (go t)
        | Types.TRecord row -> Types.TRecord (go_rrow row)
        | Types.TVariant ((name, args)) -> Types.TVariant (name, List.map go args)
        | Types.TPolyVariant row -> Types.TPolyVariant (go_pv row)
        | Types.TMap ((k, v)) -> Types.TMap (go k, go v)
        | t -> t

    and go_pv =
      fn
        | Types.PVRow ((tag, ty_opt, tail)) -> Types.PVRow (tag, Option.map go ty_opt, go_pv tail)
        | r -> r

    and go_rrow =
      fn
        | Types.RRow ((name, ty, tail)) -> Types.RRow (name, go ty, go_rrow tail)
        | r -> r
     in
    go ty

  pub let freshen_tvars level ty =
    let mapping = Hashtbl.create 4 in
    let rec go =
      fn
        | Types.TVar {contents = Types.Unbound ((id, _))} -> 
          do
            match Hashtbl.get mapping id with
            | Some fresh -> fresh
            | None -> 
              let fresh = Types.new_tvar level in
              Hashtbl.set mapping id fresh;
              fresh

          end
        | Types.TVar {contents = Types.Link t} -> go t
        | Types.TArrow ((a, eff, b)) -> Types.TArrow (go a, go_eff eff, go b)
        | Types.TCont ((a, eff, b)) -> Types.TCont (go a, go_eff eff, go b)
        | Types.TTuple ts -> Types.TTuple (List.map go ts)
        | Types.TList t -> Types.TList (go t)
        | Types.TArray t -> Types.TArray (go t)
        | Types.TRecord row -> Types.TRecord (go_rrow row)
        | Types.TVariant ((name, args)) -> Types.TVariant (name, List.map go args)
        | Types.TPolyVariant row -> Types.TPolyVariant (go_pv row)
        | Types.TMap ((k, v)) -> Types.TMap (go k, go v)
        | t -> t

    and go_eff =
      fn
        | Types.EffVar {contents = Types.EffUnbound _} as e -> e
        | Types.EffVar {contents = Types.EffLink e} -> go_eff e
        | Types.EffRow ((label, params, tail)) -> Types.EffRow (label, List.map go params, go_eff tail)
        | e -> e

    and go_pv =
      fn
        | Types.PVRow ((tag, ty_opt, tail)) -> Types.PVRow (tag, Option.map go ty_opt, go_pv tail)
        | r -> r

    and go_rrow =
      fn
        | Types.RRow ((name, ty, tail)) -> Types.RRow (name, go ty, go_rrow tail)
        | Types.RVar {contents = Types.RUnbound _} -> Types.new_rvar level
        | Types.RVar {contents = Types.RLink r} -> go_rrow r
        | r -> r
     in
    go ty

  pub let rec resolve_ty_annot_shared ctx level tvars (annot : Ast.ty_annot) : Types.ty =
    let rec go =
      fn
        | Ast.TyVar name -> 
          do
            match Hashtbl.get tvars name with
            | Some tv -> tv
            | None -> 
              let tv = Types.new_tvar level in
              Hashtbl.set tvars name tv;
              tv

          end
        | Ast.TyName "int" -> Types.TInt
        | Ast.TyName "float" -> Types.TFloat
        | Ast.TyName "bool" -> Types.TBool
        | Ast.TyName "string" -> Types.TString
        | Ast.TyName "byte" -> Types.TByte
        | Ast.TyName "rune" -> Types.TRune
        | Ast.TyName "unit" -> Types.TUnit
        | Ast.TyName name -> 
          do
            let canonical = resolve_type_alias ctx.type_env name in
            match List.find (fn (n, _, _) -> n = canonical) ctx.type_env.type_synonyms with
            | Some ((_, 0, ty)) -> freshen_tvars level (freshen_arrow_effects level ty)
            | Some ((_, n, _)) -> error ($"type {name} expects {n} type argument(s)")
            | None -> 
              do
                match find_variant_info ctx.type_env name with
                | Some ((_, 0, _, _)) -> Types.TVariant (canonical, [])
                | Some ((_, n, _, _)) -> error ($"type {name} expects {n} type argument(s)")
                | None -> 
                  if (List.assoc_opt canonical ctx.type_env.records) <> None do
                    let fields = List.assoc canonical ctx.type_env.records in
                    if fields = [] do
                      Types.TRecord Types.RWild
                    else
                      Types.TRecord (Types.fields_to_closed_row fields)
                  else
                    error ($"unknown type: {name}")

              end

          end
        | Ast.TyArrow ((a, b, eff_opt)) -> 
          let eff =
            match eff_opt with
            | None -> Types.new_effvar level
            | Some Ast.EffAnnotPure -> Types.EffEmpty
            | Some (Ast.EffAnnotRow items) -> resolve_eff_items ctx level tvars items
           in
          Types.TArrow (go a, eff, go b)
        | Ast.TyTuple ts -> Types.TTuple (List.map go ts)
        | Ast.TyList t -> Types.TList (go t)
        | Ast.TyArray t -> Types.TArray (go t)
        | Ast.TyMap ((k, v)) -> Types.TMap (go k, go v)
        | Ast.TyApp ((args, name)) -> 
          do
            let canonical = resolve_type_alias ctx.type_env name in
            let arg_tys = List.map go args in
            match List.find (fn (n, _, _) -> n = canonical) ctx.type_env.type_synonyms with
            | Some ((_, np, ty)) -> 
              if (List.length arg_tys) <> np do
                error ($"type {name} expects {np} type argument(s), got {List.length arg_tys}")
              end;
              freshen_tvars level (freshen_arrow_effects level (subst_tgens arg_tys ty))
            | None -> 
              do
                match find_variant_info ctx.type_env name with
                | Some ((_, np, _, _)) -> 
                  if (List.length arg_tys) <> np do
                    error ($"type {name} expects {np} type argument(s), got {List.length arg_tys}")
                  end;
                  Types.TVariant (canonical, arg_tys)
                | None -> error ($"unknown type constructor: {name}")

              end

          end
        | Ast.TyRecord ((fields, is_open)) -> 
          let fields = List.map (fn (n, t) -> (n, go t)) fields in
          let fields = List.sort (fn (a, _) (b, _) -> String.compare a b) fields in
          let tail =
            if is_open do
              Types.new_rvar level
            else
              Types.REmpty in
          Types.TRecord (List.fold_right (fn (n, t) acc -> Types.RRow (n, t, acc)) fields tail)
        | Ast.TyQualified ((path, name)) -> 
          let qualified = (String.concat "." path) ^ ("." ^ name) in
          go (Ast.TyName qualified)
        | Ast.TyPolyVariant ((kind, tags)) -> 
          let tail =
            match kind with
            | Ast.PVExact | Ast.PVUpper -> Types.PVEmpty
            | Ast.PVLower -> Types.new_pvvar level
           in
          let row = List.fold_right (fn (tag, payload_annot) acc -> Types.PVRow (tag, Option.map go payload_annot, acc)) tags tail in
          Types.TPolyVariant row
        | Ast.TyWithEffect ((ty, _eff)) -> go ty
     in
    go annot
  and resolve_eff_items ctx level tvars (items : Ast.eff_item list) : Types.eff =
    let labels = Ref.create [] in
    let row_var = Ref.create None in
    List.iter (fn item ->
      do
        match item with
        | Ast.EffLabel ((name, param_annots)) -> 
          if (Ref.get row_var) <> None do
            error "effect labels must come before row variable"
          end;
          let edef =
            match List.find (fn e -> e.effect_name = name) ctx.type_env.effects with
            | Some e -> e
            | None -> error ($"unknown effect: {name}")
           in
          let expected_params = List.length edef.effect_params in
          let actual_params = List.length param_annots in
          if expected_params <> actual_params do
            error ($"effect {name} expects {expected_params} type parameter(s), got {actual_params}")
          end;
          Ref.set labels ((name, param_annots) :: Ref.get labels)
        | Ast.EffVar name -> 
          if (Ref.get row_var) <> None do
            error "at most one effect row variable allowed"
          end;
          Ref.set row_var (Some name)

      end) items;
    let labels = List.rev (Ref.get labels) in
    let tail =
      match Ref.get row_var with
      | None -> Types.new_effvar level
      | Some _name -> Types.new_effvar level
     in
    List.fold_right (fn (name, param_annots) acc -> let resolved_params = List.map (resolve_ty_annot_shared ctx level tvars) param_annots in
    Types.EffRow (name, resolved_params, acc)) labels tail

  pub let resolve_ty_annot ctx level (annot : Ast.ty_annot) : Types.ty =
    let tvars = Hashtbl.create 4 in
    resolve_ty_annot_shared ctx level tvars annot

  pub let instantiate_record_fields level fields =
    let max_gen = List.fold (fn acc (_, ty) -> max acc (max_tgen_in_ty ty)) (-1) fields in
    if max_gen < 0 do
      fields
    else do
      let fresh = List.init (max_gen + 1) (fn _ -> Types.new_tvar level) in
      List.map (fn (n, ty) -> (n, freshen_arrow_effects level (subst_tgens fresh ty))) fields
    end

  pub let instantiate_record_row level fields =
    let fields = instantiate_record_fields level fields in
    Types.fields_to_closed_row fields

  pub let find_module_in_env_ref = Ref.create (fn _ _ -> failwith "find_module_in_env not yet initialized")

  pub let open_module_into_ctx_ref = Ref.create (fn _ _ _ -> failwith "open_module_into_ctx not yet initialized")

  pub let exhaustiveness_check_ref = Ref.create (fn _ _ _ -> ())

  pub let mk te ty = {expr = te; ty; loc = Ref.get current_loc}

  pub let rec extract_fn_info (expr : Ast.expr) =
    match expr with
    | Ast.ELoc ((_, inner)) -> extract_fn_info inner
    | Ast.EAnnot ((inner, _)) when match inner with
    | Ast.EFun _ | Ast.ELoc ((_, Ast.EFun _)) -> true
    | _ -> false
     -> extract_fn_info inner
    | Ast.EFun ((param, body)) -> 
      let (params, ret, inner) = extract_fn_info body in
      (param :: params, ret, inner)
    | Ast.EAnnot ((inner, annot)) -> ([], Some annot, inner)
    | _ -> ([], None, expr)


  pub let resolve_module_name ctx name =
    match ctx.current_module with
    | Some prefix -> 
      let rec try_prefix p =
        let qualified = p ^ name in
        if List.exists (fn (n, _) -> n = qualified) ctx.vars do
          qualified
        else do
          let p' = String.sub p 0 (max 0 ((String.length p) - 1)) in
          match String.rindex_opt p' #2e with
          | Some idx -> try_prefix (String.sub p' 0 (idx + 1))
          | None -> name

        end in
      try_prefix prefix
    | None -> name


  pub let find_var_type_in target_name te =
    let result = Ref.create None in
    let rec go te =
      if Option.is_some (Ref.get result) do
        ()
      else
        match te.expr with
        | TEVar n when n = target_name -> Ref.set result (Some (te.ty))
        | TEVar _ | TEInt _ | TEFloat _ | TEBool _ | TEString _ | TEByte _ | TERune _ | TEUnit | TENil | TEContinueLoop -> ()
        | TEApp ((fn_, arg)) -> 
          go fn_;
          go arg
        | TEFun ((_, body, _)) | TEUnop ((_, body)) | TEField ((body, _)) | TEBreak body | TEFoldContinue body | TEForLoop body | TEReturn body | TEAssign ((_, body)) | TEPerform ((_, body)) -> go body
        | TELet ((_, _, e1, e2)) | TELetRec ((_, _, e1, e2)) | TELetMut ((_, e1, e2)) | TEBinop ((_, e1, e2)) | TECons ((e1, e2)) | TESeq ((e1, e2)) | TEWhile ((e1, e2)) | TEResume ((e1, e2)) | TEFieldAssign ((e1, _, e2)) | TEIndex ((e1, e2)) -> 
          go e1;
          go e2
        | TEIf ((c, t, e)) -> 
          go c;
          go t;
          go e
        | TETuple es | TEArray es -> List.iter go es
        | TEMap kvs -> List.iter (fn (k, v) -> go k;
        go v) kvs
        | TERecord fields -> List.iter (fn (_, e) -> go e) fields
        | TERecordUpdate ((base, overrides)) -> 
          go base;
          List.iter (fn (_, e) -> go e) overrides
        | TERecordUpdateIdx ((base, pairs)) -> 
          go base;
          List.iter (fn (i, v) -> go i;
          go v) pairs
        | TEConstruct ((_, arg)) -> Option.iter go arg
        | TEMatch ((scr, arms, _)) -> 
          go scr;
          List.iter (fn (_, g, body) -> Option.iter go g;
          go body) arms
        | TEHandle ((body, arms)) -> 
          go body;
          List.iter (fn arm ->
            do
              match arm with
              | THReturn ((_, e)) -> go e
              | THOp ((_, _, _, e)) -> go e

            end) arms
        | TELetRecAnd ((bindings, body)) -> 
          List.iter (fn (_, e) -> go e) bindings;
          go body
     in
    go te;
    Ref.get result

  pub let infer_implicit_constraints binding_name type_env vars te scheme =
    if (scheme.constraints <> []) || (scheme.quant = 0) do
      scheme
    else do
      let id_map = Hashtbl.create 8 in
      let rec build_map s a =
        let a = Types.repr a in
        match s with
        | Types.TGen i -> 
          do
            match a with
            | Types.TVar {contents = Types.Unbound ((id, _))} -> Hashtbl.set id_map id (Types.TGen i)
            | _ -> ()

          end
        | Types.TArrow ((s1, _, s2)) -> 
          do
            match a with
            | Types.TArrow ((a1, _, a2)) -> 
              build_map s1 a1;
              build_map s2 a2
            | _ -> ()

          end
        | Types.TCont ((s1, _, s2)) -> 
          do
            match a with
            | Types.TCont ((a1, _, a2)) -> 
              build_map s1 a1;
              build_map s2 a2
            | _ -> ()

          end
        | Types.TTuple ss -> 
          do
            match a with
            | Types.TTuple aa when (List.length ss) = (List.length aa) -> List.iter2 build_map ss aa
            | _ -> ()

          end
        | Types.TList s1 -> 
          do
            match a with
            | Types.TList a1 -> build_map s1 a1
            | _ -> ()

          end
        | Types.TArray s1 -> 
          do
            match a with
            | Types.TArray a1 -> build_map s1 a1
            | _ -> ()

          end
        | Types.TMap ((sk, sv)) -> 
          do
            match a with
            | Types.TMap ((ak, av)) -> 
              build_map sk ak;
              build_map sv av
            | _ -> ()

          end
        | Types.TVariant ((_, ss)) -> 
          do
            match a with
            | Types.TVariant ((_, aa)) when (List.length ss) = (List.length aa) -> List.iter2 build_map ss aa
            | _ -> ()

          end
        | Types.TPolyVariant srow -> 
          do
            match a with
            | Types.TPolyVariant arow -> build_map_pvrows srow arow
            | _ -> ()

          end
        | Types.TRecord srow -> 
          do
            match a with
            | Types.TRecord arow -> build_map_rrows srow arow
            | _ -> ()

          end
        | _ -> ()

      and build_map_rrows srow arow =
        let sf = Types.record_row_to_fields srow in
        let af = Types.record_row_to_fields arow in
        if (List.length sf) = (List.length af) do
          List.iter2 (fn (_, st) (_, at_) -> build_map st at_) sf af
        end
      and build_map_pvrows srow arow =
        let rec collect_tags row =
          match row with
          | Types.PVRow ((tag, ty_opt, tail)) -> (tag, ty_opt) :: collect_tags tail
          | Types.PVVar {contents = Types.PVLink r} -> collect_tags r
          | _ -> []
         in
        let atags = collect_tags arow in
        let rec go row =
          match row with
          | Types.PVRow ((stag, sty_opt, stail)) -> 
            do
              match List.assoc_opt stag atags with
              | Some aty_opt -> 
                do
                  match (sty_opt, aty_opt) with
                  | (Some sty, Some aty) -> build_map sty aty
                  | _ -> ()

                end
              | None -> ()

            end;
            go stail
          | Types.PVVar {contents = Types.PVLink r} -> go r
          | _ -> ()
         in
        go srow in
      build_map scheme.body te.ty;
      let found_multi = Ref.create [] in
      let pending_caty = Ref.create [] in
      let phantom_counter = Ref.create scheme.quant in
      let tvar_to_phantom = Hashtbl.create 4 in
      let set_add tbl key =
        if not (List.exists (fn k -> k = key) (Ref.get tbl)) do
          Ref.set tbl (key :: Ref.get tbl)
        end in
      let propagate_constrained_ref local_sch actual_ty =
        let call_map = Hashtbl.create 4 in
        let phantom_remap = Hashtbl.create 4 in
        let rec map_tgens s a =
          let a = Types.repr a in
          match s with
          | Types.TGen i -> 
            if not (Hashtbl.has call_map i) do
              Hashtbl.set call_map i a
            end
          | Types.TArrow ((s1, _, s2)) -> 
            do
              match a with
              | Types.TArrow ((a1, _, a2)) -> 
                map_tgens s1 a1;
                map_tgens s2 a2
              | _ -> ()

            end
          | Types.TCont ((s1, _, s2)) -> 
            do
              match a with
              | Types.TCont ((a1, _, a2)) -> 
                map_tgens s1 a1;
                map_tgens s2 a2
              | _ -> ()

            end
          | Types.TTuple ss -> 
            do
              match a with
              | Types.TTuple aa when (List.length ss) = (List.length aa) -> List.iter2 map_tgens ss aa
              | _ -> ()

            end
          | Types.TList s1 -> 
            do
              match a with
              | Types.TList a1 -> map_tgens s1 a1
              | _ -> ()

            end
          | Types.TArray s1 -> 
            do
              match a with
              | Types.TArray a1 -> map_tgens s1 a1
              | _ -> ()

            end
          | Types.TMap ((sk, sv)) -> 
            do
              match a with
              | Types.TMap ((ak, av)) -> 
                map_tgens sk ak;
                map_tgens sv av
              | _ -> ()

            end
          | Types.TVariant ((_, ss)) -> 
            do
              match a with
              | Types.TVariant ((_, aa)) when (List.length ss) = (List.length aa) -> List.iter2 map_tgens ss aa
              | _ -> ()

            end
          | _ -> ()
         in
        map_tgens local_sch.body actual_ty;
        List.iter (fn (cc : Types.class_constraint) -> let outer_tgens = List.filter_map (fn (ca : Types.class_arg) ->
          do
            match ca with
            | CATGen tgen_idx -> 
              do
                match Hashtbl.get call_map tgen_idx with
                | Some (Types.TVar {contents = Types.Unbound ((id, _))} as tv) -> 
                  do
                    match Hashtbl.get id_map id with
                    | Some (Types.TGen outer_tgen) -> Some (Types.CATGen outer_tgen)
                    | _ -> Some (Types.CATy tv)

                  end
                | Some _ -> None
                | None -> None

              end
            | CATy ty -> 
              do
                match Types.repr ty with
                | Types.TVar {contents = Types.Unbound ((id, _))} -> 
                  do
                    match Hashtbl.get id_map id with
                    | Some (Types.TGen outer_tgen) -> Some (Types.CATGen outer_tgen)
                    | _ -> Some ca

                  end
                | _ -> Some ca

              end
            | CAWild -> Some Types.CAWild
            | CAPhantom ((inner_idx, _)) -> 
              let (outer_idx, outer_tv) =
                match Hashtbl.get phantom_remap inner_idx with
                | Some pair -> pair
                | None -> 
                  let idx = Ref.get phantom_counter in
                  Ref.set phantom_counter (Ref.get phantom_counter + 1);
                  let tv = Types.new_tvar 1 in
                  Hashtbl.set phantom_remap inner_idx (idx, tv);
                  (idx, tv)
               in
              Some (Types.CAPhantom (outer_idx, outer_tv))

          end) cc.cc_args in
        if (List.length outer_tgens) = (List.length cc.cc_args) do
          set_add found_multi (cc.cc_class, outer_tgens)
        end) local_sch.constraints in
      let rec walk locals te =
        do
          match te.expr with
          | TEVar name -> 
            do
              do
                match List.assoc_opt name locals with
                | Some local_sch when local_sch.constraints <> [] -> propagate_constrained_ref local_sch te.ty
                | _ -> ()

              end;
              do
                match List.assoc_opt name vars with
                | Some var_sch when var_sch.constraints <> [] -> propagate_constrained_ref var_sch te.ty
                | _ -> ()

              end;
              let (class_match, method_name) =
                match Types.find_method_class type_env.classes name with
                | Some class_def when not (name = binding_name) -> 
                  do
                    let method_ty = List.assoc name class_def.class_methods in
                    match List.assoc_opt name vars with
                    | Some s -> 
                      if s.body = method_ty do
                        (Some class_def, name)
                      else
                        (None, name)
                    | None -> (None, name)

                  end
                | _ -> 
                  do
                    match String.rindex_opt name #2e with
                    | None -> (None, name)
                    | Some i -> 
                      do
                        let short = String.sub name (i + 1) (((String.length name) - i) - 1) in
                        let class_prefix = String.sub name 0 i in
                        let mod_prefix = String.sub name 0 (i + 1) in
                        match Types.find_method_class type_env.classes short with
                        | Some class_def when (not (short = binding_name)) && ((class_def.class_name = class_prefix) || (((String.length class_def.class_name) > (String.length mod_prefix)) && ((String.sub class_def.class_name 0 (String.length mod_prefix)) = mod_prefix))) -> 
                          do
                            let method_ty = List.assoc short class_def.class_methods in
                            let var_sch =
                              match List.assoc_opt name vars with
                              | Some _ as r -> r
                              | None -> List.assoc_opt short vars
                             in
                            match var_sch with
                            | Some s -> 
                              if s.body = method_ty do
                                (Some class_def, short)
                              else
                                (None, name)
                            | None -> (None, name)

                          end
                        | _ -> (None, name)

                      end

                  end
               in
              match class_match with
              | Some class_def -> 
                let method_schema_ty = List.assoc method_name class_def.class_methods in
                let num_params = List.length class_def.class_params in
                let param_map = Hashtbl.create num_params in
                let rec go s r =
                  let r = Types.repr r in
                  match (s, r) with
                  | (Types.TGen i, _) when i < num_params -> 
                    if not (Hashtbl.has param_map i) do
                      Hashtbl.set param_map i r
                    end
                  | (Types.TArrow ((s1, _, s2)), Types.TArrow ((r1, _, r2))) | (Types.TCont ((s1, _, s2)), Types.TCont ((r1, _, r2))) -> 
                    go s1 r1;
                    go s2 r2
                  | (Types.TTuple ss, Types.TTuple rs) when (List.length ss) = (List.length rs) -> List.iter2 go ss rs
                  | (Types.TList s1, Types.TList r1) -> go s1 r1
                  | (Types.TArray s1, Types.TArray r1) -> go s1 r1
                  | (Types.TMap ((sk, sv)), Types.TMap ((rk, rv))) -> 
                    go sk rk;
                    go sv rv
                  | (Types.TVariant ((_, ss)), Types.TVariant ((_, rs))) when (List.length ss) = (List.length rs) -> List.iter2 go ss rs
                  | _ -> ()
                 in
                go method_schema_ty te.ty;
                let cc_args = List.init num_params (fn i ->
                  do
                    match Hashtbl.get param_map i with
                    | Some (Types.TVar {contents = Types.Unbound ((id, _))} as tv) -> 
                      do
                        match Hashtbl.get id_map id with
                        | Some (Types.TGen tgen_idx) -> Some (Types.CATGen tgen_idx)
                        | _ -> 
                          let is_fundep_target = List.exists (fn (fd : Types.fundep) -> List.mem i fd.fd_to) class_def.class_fundeps in
                          if is_fundep_target do
                            let phantom_idx =
                              match Hashtbl.get tvar_to_phantom id with
                              | Some idx -> idx
                              | None -> 
                                let idx = Ref.get phantom_counter in
                                Ref.set phantom_counter (Ref.get phantom_counter + 1);
                                Hashtbl.set tvar_to_phantom id idx;
                                idx
                             in
                            Some (Types.CAPhantom (phantom_idx, tv))
                          else
                            Some (Types.CATy tv)

                      end
                    | Some ty -> Some (Types.CATy ty)
                    | None -> 
                      let is_fundep_target = List.exists (fn (fd : Types.fundep) -> List.mem i fd.fd_to) class_def.class_fundeps in
                      if is_fundep_target do
                        Some Types.CAWild
                      else
                        None

                  end) in
                let has_nonconc_caty = List.exists (fn opt ->
                  do
                    match opt with
                    | Some (Types.CATy ty) -> not (Types.is_concrete ty)
                    | _ -> false

                  end) cc_args in
                let has_any_caty = List.exists (fn opt ->
                  do
                    match opt with
                    | Some (Types.CATy _) -> true
                    | _ -> false

                  end) cc_args in
                let cc_args =
                  if has_nonconc_caty do
                    List.map (fn opt ->
                      do
                        match opt with
                        | Some Types.CAWild -> None
                        | Some (Types.CAPhantom _) -> None
                        | _ -> opt

                      end) cc_args
                  else
                    cc_args in
                let has_tgen = List.exists (fn opt ->
                  do
                    match opt with
                    | Some (Types.CATGen _) -> true
                    | _ -> false

                  end) cc_args in
                let has_caty = has_any_caty in
                let all_resolved = List.forall (fn opt -> opt <> None) cc_args in
                let allow = has_tgen && (all_resolved && ((not has_caty) || (match scheme.body with
                | Types.TArrow _ | Types.TCont _ -> true
                | _ -> false
                ))) in
                if allow do
                  let cc_args = List.filter_map (fn x -> x) cc_args in
                  set_add found_multi (class_def.class_name, cc_args)
                else if (not has_tgen) && all_resolved do
                  let has_unbound_caty = List.exists (fn opt ->
                    do
                      match opt with
                      | Some (Types.CATy (Types.TVar {contents = Types.Unbound _})) -> true
                      | _ -> false

                    end) cc_args in
                  let is_arrow =
                    match scheme.body with
                    | Types.TArrow _ | Types.TCont _ -> true
                    | _ -> false
                   in
                  if has_unbound_caty && is_arrow do
                    let cc_args = List.filter_map (fn x -> x) cc_args in
                    set_add pending_caty (class_def.class_name, cc_args)
                  end
                end
              | None -> ()

            end
          | _ -> ()

        end;
        walk_children locals te
      and walk_children locals te =
        match te.expr with
        | TEInt _ | TEFloat _ | TEBool _ | TEString _ | TEByte _ | TERune _ | TEUnit | TEVar _ | TENil | TEContinueLoop -> ()
        | TELet ((name, Some sch, _e1, e2)) | TELetRec ((name, Some sch, _e1, e2)) -> walk ((name, sch) :: locals) e2
        | TELet ((name, None, e1, e2)) | TELetRec ((name, None, e1, e2)) -> 
          do
            match Types.repr e1.ty with
            | Types.TVar {contents = Types.Unbound _} -> 
              do
                match find_var_type_in name e2 with
                | Some inst_ty -> 
                  do
                    match Types.repr inst_ty with
                    | Types.TVar {contents = Types.Unbound _} -> (* try/catch-all *) Types.unify e1.ty inst_ty
                    | _ -> ()

                  end
                | None -> ()

              end
            | _ -> ()

          end;
          walk locals e1;
          walk locals e2
        | TELetMut ((_, e1, e2)) | TEBinop ((_, e1, e2)) | TECons ((e1, e2)) | TESeq ((e1, e2)) | TEWhile ((e1, e2)) | TEResume ((e1, e2)) | TEFieldAssign ((e1, _, e2)) | TEIndex ((e1, e2)) -> 
          walk locals e1;
          walk locals e2
        | TEApp ((fn_, arg)) -> 
          walk locals fn_;
          walk locals arg
        | TEPerform ((_, e)) | TEUnop ((_, e)) | TEFun ((_, e, _)) | TEField ((e, _)) | TEBreak e | TEFoldContinue e | TEForLoop e | TEReturn e | TEAssign ((_, e)) -> walk locals e
        | TEIf ((c, t, e)) -> 
          walk locals c;
          walk locals t;
          walk locals e
        | TETuple es | TEArray es -> List.iter (walk locals) es
        | TEMap kvs -> List.iter (fn (k, v) -> walk locals k;
        walk locals v) kvs
        | TERecord fields -> List.iter (fn (_, e) -> walk locals e) fields
        | TERecordUpdate ((base, overrides)) -> 
          walk locals base;
          List.iter (fn (_, e) -> walk locals e) overrides
        | TERecordUpdateIdx ((base, pairs)) -> 
          walk locals base;
          List.iter (fn (i, v) -> walk locals i;
          walk locals v) pairs
        | TEConstruct ((_, arg)) -> Option.iter (walk locals) arg
        | TEMatch ((scrutinee, arms, _)) -> 
          walk locals scrutinee;
          List.iter (fn (_, guard, body) -> Option.iter (walk locals) guard;
          walk locals body) arms
        | TEHandle ((body, arms)) -> 
          walk locals body;
          List.iter (fn arm ->
            do
              match arm with
              | THReturn ((_, e)) -> walk locals e
              | THOp ((_, _, _, e)) -> walk locals e

            end) arms
        | TELetRecAnd ((bindings, body)) -> 
          List.iter (fn (_, e) -> walk locals e) bindings;
          walk locals body
       in
      walk [] te;
      let changed = Ref.create true in
      for Ref.get changed do
        Ref.set changed false;
        let to_promote = List.fold (fn acc (cls, args) -> let dominated = List.exists (fn (ca : Types.class_arg) ->
          do
            match ca with
            | Types.CATy (Types.TVar {contents = Types.Unbound ((id, _))}) -> List.exists (fn (_c, fargs) -> List.exists (fn (fa : Types.class_arg) ->
              do
                match fa with
                | Types.CATy (Types.TVar {contents = Types.Unbound ((fid, _))}) -> fid = id
                | Types.CAPhantom ((_, Types.TVar {contents = Types.Unbound ((fid, _))})) -> fid = id
                | _ -> false

              end) fargs) (Ref.get found_multi)
            | _ -> false

          end) args in
        if dominated do
          (cls, args) :: acc
        else
          acc) [] (Ref.get pending_caty) in
        List.iter (fn (cls, args) -> let promoted_args = List.map (fn (ca : Types.class_arg) ->
          do
            match ca with
            | Types.CATy (Types.TVar {contents = Types.Unbound ((id, _))} as tv) -> 
              do
                let phantom_idx = Ref.create None in
                List.iter (fn (_c, fargs) -> List.iter (fn (fa : Types.class_arg) ->
                  do
                    match fa with
                    | Types.CAPhantom ((idx, Types.TVar {contents = Types.Unbound ((fid, _))})) when fid = id -> Ref.set phantom_idx (Some idx)
                    | _ -> ()

                  end) fargs) (Ref.get found_multi);
                match Ref.get phantom_idx with
                | Some idx -> Types.CAPhantom (idx, tv)
                | None -> ca

              end
            | _ -> ca

          end) args in
        Ref.set pending_caty (List.filter (fn k -> k <> (cls, args)) (Ref.get pending_caty));
        set_add found_multi (cls, promoted_args);
        Ref.set changed true) to_promote
      end;
      let cc_list = List.fold (fn acc (class_name, cc_args) -> let exists = List.exists (fn (cc : Types.class_constraint) -> (cc.cc_class = class_name) && (cc.cc_args = cc_args)) acc in
      if exists do
        acc
      else
        {cc_class = class_name; cc_args} :: acc) [] (Ref.get found_multi) in
      if cc_list = [] do
        scheme
      else do
        let cc_list = List.sort (fn (a : Types.class_constraint) (b : Types.class_constraint) -> let count_catgen args = List.length (List.filter (fn (ca : Types.class_arg) ->
          do
            match ca with
            | Types.CATGen _ -> true
            | _ -> false

          end) args) in
        compare (count_catgen b.cc_args) (count_catgen a.cc_args)) cc_list in
        {scheme with constraints = cc_list}
      end
    end

  pub let build_rgen_map schema_ty actual_ty =
    let map = Hashtbl.create 4 in
    let rec walk s a =
      let a = Types.repr a in
      match s with
      | Types.TArrow ((s1, _, s2)) -> 
        do
          match a with
          | Types.TArrow ((a1, _, a2)) -> 
            walk s1 a1;
            walk s2 a2
          | _ -> ()

        end
      | Types.TCont ((s1, _, s2)) -> 
        do
          match a with
          | Types.TCont ((a1, _, a2)) -> 
            walk s1 a1;
            walk s2 a2
          | _ -> ()

        end
      | Types.TTuple ss -> 
        do
          match a with
          | Types.TTuple aa when (List.length ss) = (List.length aa) -> List.iter2 walk ss aa
          | _ -> ()

        end
      | Types.TList s1 -> 
        do
          match a with
          | Types.TList a1 -> walk s1 a1
          | _ -> ()

        end
      | Types.TArray s1 -> 
        do
          match a with
          | Types.TArray a1 -> walk s1 a1
          | _ -> ()

        end
      | Types.TMap ((sk, sv)) -> 
        do
          match a with
          | Types.TMap ((ak, av)) -> 
            walk sk ak;
            walk sv av
          | _ -> ()

        end
      | Types.TVariant ((_, ss)) -> 
        do
          match a with
          | Types.TVariant ((_, aa)) when (List.length ss) = (List.length aa) -> List.iter2 walk ss aa
          | _ -> ()

        end
      | Types.TRecord srow -> 
        do
          match a with
          | Types.TRecord arow -> 
            walk_rrows srow arow;
            let sf = Types.record_row_to_fields srow in
            let af = Types.record_row_to_fields arow in
            List.iter (fn (name, sty) ->
              do
                match List.assoc_opt name af with
                | Some aty -> walk sty aty
                | None -> ()

              end) sf
          | _ -> ()

        end
      | _ -> ()

    and walk_rrows srow arow =
      match srow with
      | Types.RGen i -> 
        if not (Hashtbl.has map i) do
          Hashtbl.set map i arow
        end
      | Types.RRow ((_, _, stail)) -> walk_rrows stail arow
      | _ -> ()
     in
    walk schema_ty actual_ty;
    map

  pub let infer_record_evidence vars te scheme =
    if scheme.rquant = 0 do
      scheme
    else do
      let rvar_to_rgen = Hashtbl.create 4 in
      let rec walk_rmap s a =
        let a = Types.repr a in
        match s with
        | Types.TArrow ((s1, _, s2)) -> 
          do
            match a with
            | Types.TArrow ((a1, _, a2)) -> 
              walk_rmap s1 a1;
              walk_rmap s2 a2
            | _ -> ()

          end
        | Types.TCont ((s1, _, s2)) -> 
          do
            match a with
            | Types.TCont ((a1, _, a2)) -> 
              walk_rmap s1 a1;
              walk_rmap s2 a2
            | _ -> ()

          end
        | Types.TTuple ss -> 
          do
            match a with
            | Types.TTuple aa when (List.length ss) = (List.length aa) -> List.iter2 walk_rmap ss aa
            | _ -> ()

          end
        | Types.TList s1 -> 
          do
            match a with
            | Types.TList a1 -> walk_rmap s1 a1
            | _ -> ()

          end
        | Types.TArray s1 -> 
          do
            match a with
            | Types.TArray a1 -> walk_rmap s1 a1
            | _ -> ()

          end
        | Types.TMap ((sk, sv)) -> 
          do
            match a with
            | Types.TMap ((ak, av)) -> 
              walk_rmap sk ak;
              walk_rmap sv av
            | _ -> ()

          end
        | Types.TVariant ((_, ss)) -> 
          do
            match a with
            | Types.TVariant ((_, aa)) when (List.length ss) = (List.length aa) -> List.iter2 walk_rmap ss aa
            | _ -> ()

          end
        | Types.TRecord srow -> 
          do
            match a with
            | Types.TRecord arow -> walk_rmap_rrows srow arow
            | _ -> ()

          end
        | _ -> ()

      and walk_rmap_rrows srow arow =
        match (srow, Types.rrow_repr arow) with
        | (Types.RGen i, Types.RVar {contents = Types.RUnbound ((id, _))}) -> Hashtbl.set rvar_to_rgen id i
        | (Types.RRow ((_, sty, stail)), Types.RRow ((_, aty, atail))) -> 
          walk_rmap sty aty;
          walk_rmap_rrows stail atail
        | _ -> ()
       in
      walk_rmap scheme.body te.ty;
      let found_evidences = Hashtbl.create 4 in
      let add_evidence rgen_idx fields =
        let existing =
          match Hashtbl.get found_evidences rgen_idx with
          | Some fs -> fs
          | None -> []
         in
        let merged = List.fold (fn fs f -> if List.mem f fs do
          fs
        else
          f :: fs) existing fields in
        Hashtbl.set found_evidences rgen_idx merged in
      let rec get_row_tail row =
        match Types.rrow_repr row with
        | Types.RRow ((_, _, tail)) -> get_row_tail tail
        | tail -> tail
       in
      let rec walk te =
        do
          match te.expr with
          | TERecordUpdate ((_base, overrides)) -> 
            do
              match Types.repr te.ty with
              | Types.TRecord row -> 
                do
                  match get_row_tail row with
                  | Types.RVar {contents = Types.RUnbound ((id, _))} -> 
                    do
                      match Hashtbl.get rvar_to_rgen id with
                      | Some rgen_idx -> add_evidence rgen_idx (List.map fst overrides)
                      | None -> ()

                    end
                  | _ -> ()

                end
              | _ -> ()

            end
          | TEVar name -> 
            do
              match List.assoc_opt name vars with
              | Some callee_sch when callee_sch.record_evidences <> [] -> 
                let rgen_map = build_rgen_map callee_sch.body te.ty in
                List.iter (fn (re : Types.record_evidence) ->
                  do
                    match Hashtbl.get rgen_map re.re_rgen with
                    | Some arow -> 
                      do
                        let rec is_open r =
                          match Types.rrow_repr r with
                          | Types.RRow ((_, _, tail)) -> is_open tail
                          | Types.RVar {contents = Types.RUnbound _} -> true
                          | _ -> false
                         in
                        if is_open arow do
                          match get_row_tail arow with
                          | Types.RVar {contents = Types.RUnbound ((id, _))} -> 
                            do
                              match Hashtbl.get rvar_to_rgen id with
                              | Some caller_rgen -> add_evidence caller_rgen re.re_fields
                              | None -> ()

                            end
                          | _ -> ()

                        end
                      end
                    | None -> ()

                  end) callee_sch.record_evidences
              | _ -> ()

            end
          | _ -> ()

        end;
        walk_children te
      and walk_children te =
        match te.expr with
        | TEInt _ | TEFloat _ | TEBool _ | TEString _ | TEByte _ | TERune _ | TEUnit | TEVar _ | TENil | TEContinueLoop -> ()
        | TELet ((_, _, e1, e2)) | TELetRec ((_, _, e1, e2)) | TELetMut ((_, e1, e2)) -> 
          walk e1;
          walk e2
        | TEBinop ((_, e1, e2)) | TECons ((e1, e2)) | TESeq ((e1, e2)) | TEWhile ((e1, e2)) | TEResume ((e1, e2)) | TEFieldAssign ((e1, _, e2)) | TEIndex ((e1, e2)) -> 
          walk e1;
          walk e2
        | TEApp ((fn_, arg)) -> 
          walk fn_;
          walk arg
        | TEPerform ((_, e)) | TEUnop ((_, e)) | TEFun ((_, e, _)) | TEField ((e, _)) | TEBreak e | TEFoldContinue e | TEForLoop e | TEReturn e | TEAssign ((_, e)) -> walk e
        | TEIf ((c, t, e)) -> 
          walk c;
          walk t;
          walk e
        | TETuple es | TEArray es -> List.iter walk es
        | TEMap kvs -> List.iter (fn (k, v) -> walk k;
        walk v) kvs
        | TERecord fields -> List.iter (fn (_, e) -> walk e) fields
        | TERecordUpdate ((base, overrides)) -> 
          walk base;
          List.iter (fn (_, e) -> walk e) overrides
        | TERecordUpdateIdx ((base, pairs)) -> 
          walk base;
          List.iter (fn (i, v) -> walk i;
          walk v) pairs
        | TEConstruct ((_, arg)) -> Option.iter walk arg
        | TEMatch ((scrutinee, arms, _)) -> 
          walk scrutinee;
          List.iter (fn (_, guard, body) -> Option.iter walk guard;
          walk body) arms
        | TEHandle ((body, arms)) -> 
          walk body;
          List.iter (fn arm ->
            do
              match arm with
              | THReturn ((_, e)) -> walk e
              | THOp ((_, _, _, e)) -> walk e

            end) arms
        | TELetRecAnd ((bindings, body)) -> 
          List.iter (fn (_, e) -> walk e) bindings;
          walk body
       in
      walk te;
      let ev_list = Hashtbl.fold (fn rgen_idx fields acc -> {re_fields = List.sort String.compare fields; re_rgen = rgen_idx} :: acc) found_evidences [] in
      if ev_list = [] do
        scheme
      else
        {scheme with record_evidences = ev_list}
    end

  pub let scheme_needs_xform (scheme : Types.scheme) = (scheme.constraints <> []) || (scheme.record_evidences <> [])

  pub let improve_fundeps_in_expr vars type_env te =
    let classes = type_env.classes in
    let instances = type_env.instances in
    let improve_constrained_call_with_scheme sch ty =
      let tgen_to_actual = Hashtbl.create sch.quant in
      let rec map_tgens s a =
        let a = Types.repr a in
        match s with
        | Types.TGen i -> 
          if not (Hashtbl.has tgen_to_actual i) do
            Hashtbl.set tgen_to_actual i a
          end
        | Types.TArrow ((s1, _, s2)) -> 
          do
            match a with
            | Types.TArrow ((a1, _, a2)) -> 
              map_tgens s1 a1;
              map_tgens s2 a2
            | _ -> ()

          end
        | Types.TCont ((s1, _, s2)) -> 
          do
            match a with
            | Types.TCont ((a1, _, a2)) -> 
              map_tgens s1 a1;
              map_tgens s2 a2
            | _ -> ()

          end
        | Types.TTuple ss -> 
          do
            match a with
            | Types.TTuple aa when (List.length ss) = (List.length aa) -> List.iter2 map_tgens ss aa
            | _ -> ()

          end
        | Types.TList s1 -> 
          do
            match a with
            | Types.TList a1 -> map_tgens s1 a1
            | _ -> ()

          end
        | Types.TArray s1 -> 
          do
            match a with
            | Types.TArray a1 -> map_tgens s1 a1
            | _ -> ()

          end
        | Types.TMap ((sk, sv)) -> 
          do
            match a with
            | Types.TMap ((ak, av)) -> 
              map_tgens sk ak;
              map_tgens sv av
            | _ -> ()

          end
        | Types.TVariant ((_, ss)) -> 
          do
            match a with
            | Types.TVariant ((_, aa)) when (List.length ss) = (List.length aa) -> List.iter2 map_tgens ss aa
            | _ -> ()

          end
        | _ -> ()
       in
      map_tgens sch.body ty;
      List.iter (fn (cc : Types.class_constraint) ->
        do
          match List.find (fn cls -> cls.class_name = cc.cc_class) classes with
          | None -> ()
          | Some class_def when class_def.class_fundeps = [] -> ()
          | Some class_def -> 
            let num_params = List.length class_def.class_params in
            let partial = List.map (fn (ca : Types.class_arg) ->
              do
                match ca with
                | CATGen tgen_idx -> 
                  do
                    match Hashtbl.get tgen_to_actual tgen_idx with
                    | Some (Types.TVar {contents = Types.Unbound _}) -> None
                    | Some t -> Some t
                    | None -> None

                  end
                | CATy ty -> 
                  do
                    match Types.repr ty with
                    | Types.TVar {contents = Types.Unbound _} -> None
                    | t -> Some t

                  end
                | CAWild -> None
                | CAPhantom _ -> None

              end) cc.cc_args in
            let improved = Types.improve_with_fundeps instances class_def partial in
            List.iteri (fn i opt -> if i < num_params do
              match (opt, List.nth partial i) with
              | (Some resolved_ty, None) -> 
                do
                  let ca = List.nth cc.cc_args i in
                  let tvar_opt =
                    match ca with
                    | Types.CATGen tgen_idx -> Hashtbl.get tgen_to_actual tgen_idx
                    | Types.CATy ty -> Some ty
                    | Types.CAWild -> None
                    | Types.CAPhantom _ -> None
                   in
                  match tvar_opt with
                  | Some (Types.TVar ({contents = Types.Unbound _} as r)) -> (* try/catch-all *) Types.unify (Types.TVar r) resolved_ty
                  | _ -> ()

                end
              | _ -> ()

            end) improved

        end) sch.constraints in
    let improve_method_call name ty =
      let (class_opt, method_name) =
        match Types.find_method_class classes name with
        | Some _ as result -> (result, name)
        | None -> 
          do
            match String.rindex_opt name #2e with
            | None -> (None, name)
            | Some i -> 
              do
                let mod_prefix = String.sub name 0 (i + 1) in
                let short = String.sub name (i + 1) (((String.length name) - i) - 1) in
                let class_prefix = String.sub name 0 i in
                match Types.find_method_class classes short with
                | Some class_def when class_def.class_name = class_prefix -> (Some class_def, short)
                | Some class_def when ((String.length class_def.class_name) > (String.length mod_prefix)) && ((String.sub class_def.class_name 0 (String.length mod_prefix)) = mod_prefix) -> (Some class_def, short)
                | _ -> (None, name)

              end

          end
       in
      match class_opt with
      | Some class_def when class_def.class_fundeps <> [] -> 
        let method_schema_ty = List.assoc method_name class_def.class_methods in
        let num_params = List.length class_def.class_params in
        let found = Hashtbl.create num_params in
        let rec go s r =
          let r = Types.repr r in
          match (s, r) with
          | (Types.TGen i, _) when i < num_params -> 
            if not (Hashtbl.has found i) do
              Hashtbl.set found i r
            end
          | (Types.TArrow ((s1, _, s2)), Types.TArrow ((r1, _, r2))) | (Types.TCont ((s1, _, s2)), Types.TCont ((r1, _, r2))) -> 
            go s1 r1;
            go s2 r2
          | (Types.TTuple ss, Types.TTuple rs) when (List.length ss) = (List.length rs) -> List.iter2 go ss rs
          | (Types.TList s1, Types.TList r1) -> go s1 r1
          | (Types.TArray s1, Types.TArray r1) -> go s1 r1
          | (Types.TMap ((sk, sv)), Types.TMap ((rk, rv))) -> 
            go sk rk;
            go sv rv
          | (Types.TVariant ((_, ss)), Types.TVariant ((_, rs))) when (List.length ss) = (List.length rs) -> List.iter2 go ss rs
          | _ -> ()
         in
        go method_schema_ty ty;
        let partial = List.init num_params (fn i ->
          do
            match Hashtbl.get found i with
            | Some (Types.TVar {contents = Types.Unbound _}) -> None
            | Some t -> Some t
            | None -> None

          end) in
        let improved = Types.improve_with_fundeps instances class_def partial in
        List.iteri (fn i opt ->
          do
            match (opt, List.nth partial i) with
            | (Some resolved_ty, None) -> 
              do
                match Hashtbl.get found i with
                | Some (Types.TVar ({contents = Types.Unbound _} as r)) -> (* try/catch-all *) Types.unify (Types.TVar r) resolved_ty
                | _ -> ()

              end
            | _ -> ()

          end) improved
      | _ -> ()
     in
    let rec walk locals te =
      do
        match te.expr with
        | TEVar name -> 
          improve_method_call name te.ty;
          improve_constrained_call_local locals name te.ty
        | _ -> ()

      end;
      walk_children locals te
    and improve_constrained_call_local locals name ty =
      let scheme =
        match List.assoc_opt name locals with
        | Some _ as s -> s
        | None -> 
          do
            match List.assoc_opt name vars with
            | Some s when s.constraints <> [] -> Some s
            | _ -> None

          end
       in
      match scheme with
      | None -> ()
      | Some sch -> improve_constrained_call_with_scheme sch ty

    and walk_children locals te =
      match te.expr with
      | TEInt _ | TEFloat _ | TEBool _ | TEString _ | TEByte _ | TERune _ | TEUnit | TEVar _ | TENil -> ()
      | TELet ((name, sch_opt, e1, e2)) -> 
        walk locals e1;
        let locals' =
          match sch_opt with
          | Some sch when sch.constraints <> [] -> (name, sch) :: locals
          | _ -> locals
         in
        walk locals' e2
      | TELetRec ((name, sch_opt, e1, e2)) -> 
        let locals' =
          match sch_opt with
          | Some sch when sch.constraints <> [] -> (name, sch) :: locals
          | _ -> locals
         in
        walk locals' e1;
        walk locals' e2
      | TELetMut ((_, e1, e2)) -> 
        walk locals e1;
        walk locals e2
      | TEFun ((_, body, _)) -> walk locals body
      | TEApp ((f, a)) -> 
        walk locals f;
        walk locals a
      | TEIf ((c, t, e)) -> 
        walk locals c;
        walk locals t;
        walk locals e
      | TEBinop ((_, l, r)) -> 
        walk locals l;
        walk locals r
      | TEUnop ((_, e)) -> walk locals e
      | TETuple es -> List.iter (walk locals) es
      | TERecord fs -> List.iter (fn (_, e) -> walk locals e) fs
      | TERecordUpdate ((base, overrides)) -> 
        walk locals base;
        List.iter (fn (_, e) -> walk locals e) overrides
      | TERecordUpdateIdx ((base, pairs)) -> 
        walk locals base;
        List.iter (fn (i, v) -> walk locals i;
        walk locals v) pairs
      | TEField ((e, _)) -> walk locals e
      | TEIndex ((e, i)) -> 
        walk locals e;
        walk locals i
      | TECons ((h, t)) -> 
        walk locals h;
        walk locals t
      | TEConstruct ((_, arg)) -> Option.iter (walk locals) arg
      | TEMatch ((s, arms, _)) -> 
        walk locals s;
        List.iter (fn (_, g, b) -> Option.iter (walk locals) g;
        walk locals b) arms
      | TEAssign ((_, e)) -> walk locals e
      | TEFieldAssign ((e, _, v)) -> 
        walk locals e;
        walk locals v
      | TESeq ((e1, e2)) -> 
        walk locals e1;
        walk locals e2
      | TEArray es -> List.iter (walk locals) es
      | TEMap kvs -> List.iter (fn (k, v) -> walk locals k;
      walk locals v) kvs
      | TEWhile ((c, b)) -> 
        walk locals c;
        walk locals b
      | TEForLoop e -> walk locals e
      | TEReturn e -> walk locals e
      | TEBreak e -> walk locals e
      | TEContinueLoop | TEFoldContinue _ -> ()
      | TEPerform ((_, e)) -> walk locals e
      | TEHandle ((e, arms)) -> 
        walk locals e;
        List.iter (fn arm ->
          do
            match arm with
            | THReturn ((_, body)) -> walk locals body
            | THOp ((_, _, _, body)) -> walk locals body

          end) arms
      | TEResume ((e1, e2)) -> 
        walk locals e1;
        walk locals e2
      | TELetRecAnd ((bindings, body)) -> 
        List.iter (fn (_, e) -> walk locals e) bindings;
        walk locals body
     in
    walk [] te

  pub let rec is_syntactic_value (expr : Ast.expr) : bool =
    match expr with
    | Ast.EInt _ | Ast.EFloat _ | Ast.EBool _ | Ast.EString _ | Ast.EByte _ | Ast.ERune _ | Ast.EUnit -> true
    | Ast.EVar _ -> true
    | Ast.EFun _ -> true
    | Ast.ENil -> true
    | Ast.EConstruct ((_, None)) -> true
    | Ast.EConstruct ((_, Some e)) -> is_syntactic_value e
    | Ast.ETuple es | Ast.EList es -> List.forall is_syntactic_value es
    | Ast.ERecord fields -> List.forall (fn (_, e) -> is_syntactic_value e) fields
    | Ast.ECons ((a, b)) -> (is_syntactic_value a) && (is_syntactic_value b)
    | Ast.EPolyVariant ((_, None)) -> true
    | Ast.EPolyVariant ((_, Some e)) -> is_syntactic_value e
    | Ast.EAnnot ((e, _)) | Ast.ECoerce ((e, _)) | Ast.ELoc ((_, e)) -> is_syntactic_value e
    | _ -> false


  pub let mono_scheme ty = {quant = 0; equant = 0; pvquant = 0; rquant = 0; constraints = []; record_evidences = []; body = ty}

  pub let rec synth ctx level (expr : Ast.expr) : texpr =
    match expr with
    | Ast.ELoc ((loc, inner)) -> 
      Ref.set current_loc loc;
      synth ctx level inner
    | Ast.EInt n -> mk (TEInt n) Types.TInt
    | Ast.EFloat f -> mk (TEFloat f) Types.TFloat
    | Ast.EBool b -> mk (TEBool b) Types.TBool
    | Ast.EString s -> mk (TEString s) Types.TString
    | Ast.EByte n -> mk (TEByte n) Types.TByte
    | Ast.ERune n -> mk (TERune n) Types.TRune
    | Ast.EUnit -> mk TEUnit Types.TUnit
    | Ast.ENil -> mk TENil (Types.TList (Types.new_tvar level))
    | Ast.EVar name -> 
      let ty = lookup_var ctx level name in
      let resolved_name = resolve_module_name ctx name in
      mk (TEVar resolved_name) ty
    | Ast.EBinop ((op, e1, e2)) -> synth_binop ctx level op e1 e2
    | Ast.EUnop ((op, e)) -> synth_unop ctx level op e
    | Ast.EApp ((fn_, arg)) -> 
      let fn_te = synth ctx level fn_ in
      let arg_te = synth ctx level arg in
      let ret_ty = Types.new_tvar level in
      let call_eff = Types.new_effvar level in
      try_unify fn_te.ty (Types.TArrow (arg_te.ty, call_eff, ret_ty));
      try_subeffect call_eff ctx.current_eff;
      mk (TEApp (fn_te, arg_te)) ret_ty
    | Ast.EFun ((param, body)) -> 
      let param_ty =
        match param.annot with
        | Some annot -> resolve_ty_annot ctx level annot
        | None -> Types.new_tvar level
       in
      let body_eff = Types.new_effvar level in
      let ret_ty = Types.new_tvar level in
      let ctx' =
        if param.is_generated do
          {ctx with current_eff = body_eff}
        else do
          let return_used = Ref.create false in
          {ctx with current_eff = body_eff; return_type = Some ret_ty; inside_handler = false; return_used}
        end in
      let ctx' = extend_var_mono ctx' param.name param_ty in
      let body_te = synth ctx' level body in
      try_unify body_te.ty ret_ty;
      let has_return =
        if param.is_generated do
          false
        else
          Ref.get ctx'.return_used in
      mk (TEFun (param.name, body_te, has_return)) (Types.TArrow (param_ty, body_eff, ret_ty))
    | Ast.ELet ((name, e1, e2)) -> 
      let e1_te = synth ctx (level + 1) e1 in
      improve_fundeps_in_expr ctx.vars ctx.type_env e1_te;
      let scheme =
        if is_syntactic_value e1 do
          Types.generalize level e1_te.ty
        else
          mono_scheme e1_te.ty in
      let scheme = infer_implicit_constraints "" ctx.type_env ctx.vars e1_te scheme in
      let scheme = infer_record_evidence ctx.vars e1_te scheme in
      let stored_scheme =
        if scheme_needs_xform scheme do
          Some scheme
        else
          None in
      let ctx' = extend_var ctx name scheme in
      let e2_te = synth ctx' level e2 in
      mk (TELet (name, stored_scheme, e1_te, e2_te)) e2_te.ty
    | Ast.ELetMut ((name, e1, e2)) -> 
      let e1_te = synth ctx (level + 1) e1 in
      let scheme = {quant = 0; equant = 0; pvquant = 0; rquant = 0; constraints = []; record_evidences = []; body = e1_te.ty} in
      let ctx' = extend_var_mutable ctx name scheme in
      let e2_te = synth ctx' level e2 in
      mk (TELetMut (name, e1_te, e2_te)) e2_te.ty
    | Ast.EAssign ((name, e)) -> 
      if not (List.mem name ctx.mutable_vars) do
        error ($"variable {name} is not mutable")
      end;
      let var_ty = lookup_var ctx level name in
      let e_te = check ctx level e var_ty in
      let resolved_name = resolve_module_name ctx name in
      mk (TEAssign (resolved_name, e_te)) Types.TUnit
    | Ast.EFieldAssign ((record_expr, field, value_expr)) -> 
      let r_te = synth ctx level record_expr in
      let field_ty = Types.new_tvar level in
      let row_tail = Types.new_rvar level in
      do
        match Types.repr r_te.ty with
        | Types.TVar _ -> 
          do
            let candidates = List.filter (fn (_name, fields) -> List.mem_assoc field fields) ctx.type_env.records in
            match candidates with
            | (_name, fields) :: [] -> 
              let row = instantiate_record_row level fields in
              try_unify r_te.ty (Types.TRecord row)
            | _ -> try_unify r_te.ty (Types.TRecord (Types.RRow (field, field_ty, row_tail)))

          end
        | _ -> try_unify r_te.ty (Types.TRecord (Types.RRow (field, field_ty, row_tail)))

      end;
      let actual_field_ty =
        match Types.repr r_te.ty with
        | Types.TRecord row -> 
          do
            let fields = Types.record_row_to_fields row in
            match List.assoc_opt field fields with
            | Some ty -> ty
            | None -> error ($"record has no field {field}")

          end
        | _ -> error "field assignment on non-record type"
       in
      if not (List.mem field ctx.type_env.mutable_fields) do
        error ($"field {field} is not mutable")
      end;
      let v_te = check ctx level value_expr actual_field_ty in
      mk (TEFieldAssign (r_te, field, v_te)) Types.TUnit
    | Ast.ELetRec ((name, type_params, e1, e2)) -> 
      do
        match strip_loc e1 with
        | Ast.EFun _ | Ast.EAnnot ((Ast.EFun _, _)) -> 
          if type_params <> [] do
            let (params, ret_annot, body) = extract_fn_info e1 in
            let (e1_te, scheme) = synth_poly_rec_fn ctx level name "" type_params params ret_annot body in
            let ctx' = extend_var ctx name scheme in
            let e2_te = synth ctx' level e2 in
            mk (TELetRec (name, None, e1_te, e2_te)) e2_te.ty
          else do
            let fn_var = Types.new_tvar (level + 1) in
            let ctx' = extend_var_mono ctx name fn_var in
            let e1_te = synth ctx' (level + 1) e1 in
            try_unify fn_var e1_te.ty;
            improve_fundeps_in_expr ctx.vars ctx.type_env e1_te;
            let scheme = Types.generalize level e1_te.ty in
            let scheme = infer_implicit_constraints name ctx.type_env ctx.vars e1_te scheme in
            let scheme = infer_record_evidence ctx.vars e1_te scheme in
            let stored_scheme =
              if scheme_needs_xform scheme do
                Some scheme
              else
                None in
            let ctx'' = extend_var ctx name scheme in
            let e2_te = synth ctx'' level e2 in
            mk (TELetRec (name, stored_scheme, e1_te, e2_te)) e2_te.ty
          end
        | _ -> error "let rec binding must be a function"

      end
    | Ast.EIf ((cond, then_e, else_e)) -> 
      let cond_te = check ctx level cond Types.TBool in
      let then_te = synth ctx level then_e in
      let else_te = check ctx level else_e then_te.ty in
      mk (TEIf (cond_te, then_te, else_te)) then_te.ty
    | Ast.ETuple exprs -> 
      let tes = List.map (synth ctx level) exprs in
      let tys = List.map (fn te -> te.ty) tes in
      mk (TETuple tes) (Types.TTuple tys)
    | Ast.ERecord fields -> 
      let typed_fields = List.map (fn (n, e) -> let te = synth ctx level e in
      (n, te)) fields in
      let field_tys = List.map (fn (n, te) -> (n, te.ty)) typed_fields in
      let field_tys = List.sort (fn (a, _) (b, _) -> String.compare a b) field_tys in
      let row = Types.fields_to_closed_row field_tys in
      mk (TERecord typed_fields) (Types.TRecord row)
    | Ast.ERecordUpdate ((base, overrides)) -> 
      let base_te = synth ctx level base in
      do
        match Types.repr base_te.ty with
        | Types.TVar _ -> 
          do
            let override_names = List.map fst overrides in
            let candidates = List.filter (fn (_name, rfields) -> List.forall (fn f -> List.mem_assoc f rfields) override_names) ctx.type_env.records in
            match candidates with
            | (_, rfields) :: [] -> 
              let row = instantiate_record_row level rfields in
              try_unify base_te.ty (Types.TRecord row)
            | _ -> 
              let row_tail = Types.new_rvar level in
              let row = List.fold_right (fn name acc -> Types.RRow (name, Types.new_tvar level, acc)) override_names row_tail in
              try_unify base_te.ty (Types.TRecord row)

          end
        | Types.TRecord _ -> ()
        | _ -> error "record update on non-record type"

      end;
      let override_field_tys = List.map (fn (name, _) -> let field_ty = Types.new_tvar level in
      let row_tail = Types.new_rvar level in
      try_unify base_te.ty (Types.TRecord (Types.RRow (name, field_ty, row_tail)));
      let actual_ty =
        match Types.repr base_te.ty with
        | Types.TRecord row -> 
          do
            let fields = Types.record_row_to_fields row in
            match List.assoc_opt name fields with
            | Some ty -> ty
            | None -> field_ty

          end
        | _ -> field_ty
       in
      (name, actual_ty)) overrides in
      let typed_overrides = List.map2 (fn (name, e) (_, expected_ty) -> let te = check ctx level e expected_ty in
      (name, te)) overrides override_field_tys in
      let rec has_open_tail row =
        match Types.rrow_repr row with
        | Types.RRow ((_, _, tail)) -> has_open_tail tail
        | Types.RVar {contents = Types.RUnbound _} -> true
        | _ -> false
       in
      let is_open =
        match Types.repr base_te.ty with
        | Types.TRecord row -> has_open_tail row
        | _ -> false
       in
      if is_open do
        mk (TERecordUpdate (base_te, typed_overrides)) base_te.ty
      else do
        let field_tys =
          match Types.repr base_te.ty with
          | Types.TRecord row -> Types.record_row_to_fields row
          | _ -> error "record update on non-record type"
         in
        let tmp = "__rec_upd" in
        let tmp_ty = base_te.ty in
        let all_fields = List.map (fn (name, ty) ->
          do
            match List.assoc_opt name typed_overrides with
            | Some te -> (name, te)
            | None -> (name, mk (TEField (mk (TEVar tmp) tmp_ty, name)) ty)

          end) field_tys in
        let record_row = Types.fields_to_closed_row field_tys in
        let record_expr = mk (TERecord all_fields) (Types.TRecord record_row) in
        mk (TELet (tmp, None, base_te, record_expr)) (Types.TRecord record_row)
      end
    | Ast.EField ((e, field)) -> 
      let te = synth ctx level e in
      let field_ty = Types.new_tvar level in
      let row_tail = Types.new_rvar level in
      do
        match Types.repr te.ty with
        | Types.TVar _ -> 
          do
            let candidates = List.filter (fn (_name, fields) -> List.mem_assoc field fields) ctx.type_env.records in
            match candidates with
            | (_name, fields) :: [] -> 
              let row = instantiate_record_row level fields in
              try_unify te.ty (Types.TRecord row)
            | _ -> try_unify te.ty (Types.TRecord (Types.RRow (field, field_ty, row_tail)))

          end
        | _ -> try_unify te.ty (Types.TRecord (Types.RRow (field, field_ty, row_tail)))

      end;
      let actual_field_ty =
        match Types.repr te.ty with
        | Types.TRecord row -> 
          do
            let fields = Types.record_row_to_fields row in
            match List.assoc_opt field fields with
            | Some ty -> ty
            | None -> field_ty

          end
        | _ -> field_ty
       in
      mk (TEField (te, field)) actual_field_ty
    | Ast.EIndex ((base, idx)) -> 
      do
        let te_base = synth ctx level base in
        match Types.repr te_base.ty with
        | Types.TString -> 
          let te_idx = check ctx level idx Types.TInt in
          mk (TEIndex (te_base, te_idx)) Types.TByte
        | Types.TArray t -> 
          let te_idx = check ctx level idx Types.TInt in
          mk (TEIndex (te_base, te_idx)) t
        | _ -> 
          let te = synth ctx level (Ast.EApp (Ast.EApp (Ast.EVar "at", idx), base)) in
          do
            match List.find (fn c -> c.class_name = "Index") ctx.type_env.classes with
            | Some class_def when class_def.class_fundeps <> [] -> 
              do
                let container_ty = Types.repr te_base.ty in
                let partial = Some container_ty :: None :: None :: [] in
                let improved = Types.improve_with_fundeps ctx.type_env.instances class_def partial in
                match List.nth_opt improved 2 with
                | Some (Some val_ty) -> try_unify te.ty val_ty
                | _ -> ()

              end
            | _ -> ()

          end;
          te

      end
    | Ast.ECons ((hd, tl)) -> 
      let hd_te = synth ctx level hd in
      let list_ty = Types.TList (hd_te.ty) in
      let tl_te = check ctx level tl list_ty in
      mk (TECons (hd_te, tl_te)) list_ty
    | Ast.EList (first :: rest) -> 
      let first_te = synth ctx level first in
      let rest_tes = List.map (fn e -> check ctx level e first_te.ty) rest in
      let list_ty = Types.TList (first_te.ty) in
      mk (TECons (first_te, List.fold_right (fn te acc -> mk (TECons (te, acc)) list_ty) rest_tes (mk TENil list_ty))) list_ty
    | Ast.EList [] -> mk TENil (Types.TList (Types.new_tvar level))
    | Ast.EArray (first :: rest) -> 
      let first_te = synth ctx level first in
      let rest_tes = List.map (fn e -> check ctx level e first_te.ty) rest in
      mk (TEArray (first_te :: rest_tes)) (Types.TArray (first_te.ty))
    | Ast.EArray [] -> mk (TEArray []) (Types.TArray (Types.new_tvar level))
    | Ast.EConstruct ((name, arg)) -> synth_construct ctx level name arg
    | Ast.EMatch ((scrut, arms, partial)) -> synth_match None ctx level scrut arms partial
    | Ast.ESeq ((e1, e2)) -> 
      let e1_te = synth ctx level e1 in
      let e2_te = synth ctx level e2 in
      mk (TESeq (e1_te, e2_te)) e2_te.ty
    | Ast.EAnnot ((e, annot)) -> 
      let ty = resolve_ty_annot ctx level annot in
      let te = check ctx level e ty in
      te
    | Ast.EPolyVariant ((tag, None)) -> 
      let tail = Types.new_pvvar level in
      let row = Types.PVRow (tag, None, tail) in
      mk (TEConstruct ("`" ^ tag, None)) (Types.TPolyVariant row)
    | Ast.EPolyVariant ((tag, Some arg)) -> 
      let arg_te = synth ctx level arg in
      let tail = Types.new_pvvar level in
      let row = Types.PVRow (tag, Some (arg_te.ty), tail) in
      mk (TEConstruct ("`" ^ tag, Some arg_te)) (Types.TPolyVariant row)
    | Ast.ECoerce ((inner, target_annot)) -> 
      let inner_te = synth ctx level inner in
      let target_ty = resolve_ty_annot ctx level target_annot in
      try_unify inner_te.ty target_ty;
      {inner_te with ty = target_ty}
    | Ast.EPerform ((op_name, arg)) -> synth_perform ctx level op_name arg
    | Ast.EHandle ((body, arms)) -> synth_handle ctx level body arms
    | Ast.EWhile ((cond, body)) -> 
      let ctx' = {ctx with loop_info = Some WhileLoop} in
      let cond_te = check ctx' level cond Types.TBool in
      let body_te = check ctx' level body Types.TUnit in
      mk (TEWhile (cond_te, body_te)) Types.TUnit
    | Ast.EFor ((var_name, coll_expr, body_expr)) -> 
      let ctx' = {ctx with loop_info = Some UnitLoop} in
      let desugared = Ast.EApp (Ast.EApp (Ast.EApp (Ast.EVar "fold", Ast.EFun ({name = "_"; annot = None; is_generated = true}, Ast.EFun ({name = var_name; annot = None; is_generated = true}, Ast.ESeq (body_expr, Ast.EUnit)))), Ast.EUnit), coll_expr) in
      let fold_te = synth ctx' level desugared in
      mk (TEForLoop fold_te) Types.TUnit
    | Ast.EForFold ((var_name, coll_expr, acc_name, init_expr, body_expr)) -> 
      let ctx' = {ctx with loop_info = Some (FoldLoop acc_name)} in
      let desugared = Ast.EApp (Ast.EApp (Ast.EApp (Ast.EVar "fold", Ast.EFun ({name = acc_name; annot = None; is_generated = true}, Ast.EFun ({name = var_name; annot = None; is_generated = true}, body_expr))), init_expr), coll_expr) in
      let fold_te = synth ctx' level desugared in
      mk (TEForLoop fold_te) fold_te.ty
    | Ast.EBreak value_opt -> 
      do
        match ctx.loop_info with
        | None -> error "break outside of loop"
        | Some WhileLoop -> 
          if value_opt <> None do
            error "break with value only allowed in fold loops"
          end;
          mk (TEBreak (mk TEUnit Types.TUnit)) Types.TUnit
        | Some UnitLoop -> 
          if value_opt <> None do
            error "break with value only allowed in fold loops"
          end;
          mk (TEBreak (mk TEUnit Types.TUnit)) Types.TUnit
        | Some (FoldLoop acc_name) -> 
          let v_te =
            match value_opt with
            | Some e -> synth ctx level e
            | None -> synth ctx level (Ast.EVar acc_name)
           in
          mk (TEBreak v_te) (Types.new_tvar level)

      end
    | Ast.EContinueLoop -> 
      do
        match ctx.loop_info with
        | None -> error "continue outside of loop"
        | Some WhileLoop -> mk TEContinueLoop Types.TUnit
        | Some UnitLoop -> mk (TEFoldContinue (mk TEUnit Types.TUnit)) Types.TUnit
        | Some (FoldLoop acc_name) -> 
          let acc_te = synth ctx level (Ast.EVar acc_name) in
          mk (TEFoldContinue acc_te) (Types.new_tvar level)

      end
    | Ast.EReturn e -> 
      do
        match ctx.return_type with
        | None -> error "return outside of function"
        | Some ret_ty -> 
          if ctx.inside_handler do
            error "Type error: return inside try/with is not supported"
          end;
          Ref.set ctx.return_used true;
          let e_te = synth ctx level e in
          try_unify e_te.ty ret_ty;
          mk (TEReturn e_te) (Types.new_tvar level)

      end
    | Ast.EWhileLet ((pat, scrutinee, body)) -> 
      let desugared = Ast.EWhile (Ast.EBool true, Ast.EMatch (scrutinee, (pat, None, body) :: (Ast.PatWild, None, Ast.EBreak None) :: [], false)) in
      synth ctx level desugared
    | Ast.EResume ((k_expr, v_expr)) -> 
      let k_te = synth ctx level k_expr in
      let v_te = synth ctx level v_expr in
      let ret_ty = Types.new_tvar level in
      let call_eff = Types.new_effvar level in
      try_unify k_te.ty (Types.TCont (v_te.ty, call_eff, ret_ty));
      try_subeffect call_eff ctx.current_eff;
      mk (TEResume (k_te, v_te)) ret_ty
    | Ast.EMap [] -> 
      let kt = Types.new_tvar level in
      let vt = Types.new_tvar level in
      mk (TEMap []) (Types.TMap (kt, vt))
    | Ast.EMap ((k1, v1) :: rest) -> 
      let k1_te = synth ctx level k1 in
      let v1_te = synth ctx level v1 in
      let rest_tes = List.map (fn (k, v) -> let kt = check ctx level k k1_te.ty in
      let vt = check ctx level v v1_te.ty in
      (kt, vt)) rest in
      mk (TEMap ((k1_te, v1_te) :: rest_tes)) (Types.TMap (k1_te.ty, v1_te.ty))
    | Ast.EMapTyped ((mod_name, pairs)) -> 
      let pair_list = Ast.EList (List.map (fn (k, v) -> Ast.ETuple (k :: v :: [])) pairs) in
      let desugared = Ast.EApp (Ast.EVar (mod_name ^ ".of_list"), pair_list) in
      synth ctx level desugared
    | Ast.ESet elems -> 
      let list_expr = Ast.EList elems in
      let desugared = Ast.EApp (Ast.EVar "Set.of_list", list_expr) in
      synth ctx level desugared
    | Ast.ECollTyped ((mod_name, elems)) -> 
      let list_expr = Ast.EList elems in
      let desugared = Ast.EApp (Ast.EVar (mod_name ^ ".of_list"), list_expr) in
      synth ctx level desugared
    | Ast.ELocalOpen ((mod_name, inner_expr)) -> 
      let minfo =
        match Ref.get find_module_in_env_ref ctx.type_env mod_name with
        | Some m -> m
        | None -> error ($"unknown module: {mod_name}")
       in
      let desugared = List.fold (fn body (short, _scheme) -> let qualified = mod_name ^ ("." ^ short) in
      Ast.ELet (short, Ast.EVar qualified, body)) inner_expr minfo.mod_pub_vars in
      synth ctx level desugared
    | Ast.ELetRecAnd ((bindings, body)) -> 
      let has_poly = List.exists (fn (_, tp, _) -> tp <> []) bindings in
      if has_poly do
        let infos = List.map (fn (name, type_params, fn_expr) -> let (params, ret_annot, inner_body) = extract_fn_info fn_expr in
        (name, type_params, params, ret_annot, inner_body)) bindings in
        let tvars_list = List.map (fn (_, type_params, params, ret_annot, _) -> let shared_tvars = Hashtbl.create 4 in
        List.iter (fn tp -> Hashtbl.set shared_tvars tp (Types.new_tvar (level + 1))) type_params;
        let param_tys = List.map (fn (p : Ast.param) ->
          do
            match p.annot with
            | Some annot -> resolve_ty_annot_shared ctx (level + 1) shared_tvars annot
            | None -> Types.new_tvar (level + 1)

          end) params in
        let (ret_ty, body_eff) =
          match ret_annot with
          | Some (Ast.TyWithEffect ((ty, eff_annot))) -> 
            let ty' = resolve_ty_annot_shared ctx (level + 1) shared_tvars ty in
            let eff =
              match eff_annot with
              | Ast.EffAnnotPure -> Types.EffEmpty
              | Ast.EffAnnotRow items -> resolve_eff_items ctx (level + 1) shared_tvars items
             in
            (ty', eff)
          | Some annot -> (resolve_ty_annot_shared ctx (level + 1) shared_tvars annot, Types.new_effvar (level + 1))
          | None -> (Types.new_tvar (level + 1), Types.new_effvar (level + 1))
         in
        let fn_ty =
          match List.rev param_tys with
          | [] -> ret_ty
          | last :: rest -> 
            let inner = Types.TArrow (last, body_eff, ret_ty) in
            List.fold (fn acc pty -> Types.TArrow (pty, Types.EffEmpty, acc)) inner rest
         in
        (param_tys, ret_ty, body_eff, fn_ty)) infos in
        let schemes = List.map (fn (_, _, _, fn_ty) -> Types.generalize level fn_ty) tvars_list in
        let ctx' = List.fold2 (fn ctx (name, _, _, _, _) scheme -> extend_var ctx name scheme) ctx infos schemes in
        let body_tes = List.map2 (fn (_, _, params, _, inner_body) (param_tys, ret_ty, body_eff, _) -> let inner_ctx = List.fold2 (fn c (p : Ast.param) ty -> extend_var_mono c p.name ty) {ctx' with current_eff = body_eff} params param_tys in
        let body_te = check inner_ctx (level + 1) inner_body ret_ty in
        match (List.rev params, List.rev param_tys) with
        | ([], []) -> body_te
        | (last_p :: rest_ps, last_pty :: rest_ptys) -> 
          let inner = mk (TEFun (last_p.name, body_te, false)) (Types.TArrow (last_pty, body_eff, body_te.ty)) in
          List.fold2 (fn acc (p : Ast.param) pty -> mk (TEFun (p.name, acc, false)) (Types.TArrow (pty, Types.EffEmpty, acc.ty))) inner rest_ps rest_ptys
        | _ -> failwith "assert false"
        ) infos tvars_list in
        let ctx'' = List.fold2 (fn ctx (name, _, _, _, _) scheme -> extend_var ctx name scheme) ctx infos schemes in
        let body_te = synth ctx'' level body in
        let typed_bindings = List.map2 (fn (name, _, _, _, _) te -> (name, te)) infos body_tes in
        mk (TELetRecAnd (typed_bindings, body_te)) body_te.ty
      else do
        let fn_vars = List.map (fn (name, _, _) -> (name, Types.new_tvar (level + 1))) bindings in
        let ctx' = List.fold (fn ctx (name, tv) -> extend_var_mono ctx name tv) ctx fn_vars in
        let body_tes = List.map2 (fn (_, _, fn_expr) (_, tv) -> let te = synth ctx' (level + 1) fn_expr in
        try_unify tv te.ty;
        te) bindings fn_vars in
        let ctx'' = List.fold2 (fn ctx (name, _, _) (_, tv) -> let scheme = Types.generalize level tv in
        extend_var ctx name scheme) ctx bindings fn_vars in
        let body_te = synth ctx'' level body in
        let typed_bindings = List.map2 (fn (name, _, _) te -> (name, te)) bindings body_tes in
        mk (TELetRecAnd (typed_bindings, body_te)) body_te.ty
      end

  and synth_perform ctx level op_name arg =
    match Types.find_effect_op ctx.type_env op_name with
    | None -> error ($"unknown effect operation: {op_name}")
    | Some ((effect_name, op_ty)) -> 
      do
        let edef = list_find (fn e -> e.effect_name = effect_name) ctx.type_env.effects in
        let fresh_params = List.map (fn _ -> Types.new_tvar level) edef.effect_params in
        let concrete_op_ty = freshen_tvars level op_ty in
        let concrete_op_ty =
          if fresh_params = [] do
            concrete_op_ty
          else
            subst_tgens fresh_params concrete_op_ty in
        match Types.repr concrete_op_ty with
        | Types.TArrow ((param_ty, _, ret_ty)) -> 
          let arg_te = check ctx level arg param_ty in
          let fresh_tail = Types.new_effvar level in
          try_unify_eff ctx.current_eff (Types.EffRow (effect_name, fresh_params, fresh_tail));
          mk (TEPerform (op_name, arg_te)) ret_ty
        | _ -> error ($"effect operation {op_name} must have function type")

      end

  and synth_handle ctx level body arms =
    let body_eff = Types.new_effvar level in
    let body_ctx = {ctx with current_eff = body_eff; inside_handler = true} in
    let body_te = synth body_ctx level body in
    let result_ty = Types.new_tvar level in
    let handled_effects = List.filter_map (fn arm ->
      do
        match arm with
        | Ast.HOp ((op_name, _, _, _)) -> 
          do
            match Types.find_effect_op ctx.type_env op_name with
            | Some ((effect_name, _)) -> Some effect_name
            | None -> error ($"unknown effect operation in handler: {op_name}")

          end
        | _ -> None

      end) arms in
    let unique_effects = List.sort_uniq String.compare handled_effects in
    let effect_fresh_params = List.map (fn effect_name -> let edef = list_find (fn e -> e.effect_name = effect_name) ctx.type_env.effects in
    let fresh_params = List.map (fn _ -> Types.new_tvar level) edef.effect_params in
    (effect_name, fresh_params)) unique_effects in
    let remaining_eff = List.fold (fn eff (effect_name, fresh_params) -> do try
      Types.rewrite_row effect_name fresh_params eff
    with
    | unify_error msg -> error msg
    end) (Types.eff_repr body_eff) effect_fresh_params in
    try_unify_eff remaining_eff ctx.current_eff;
    let typed_arms = List.map (fn arm ->
      do
        match arm with
        | Ast.HReturn ((name, handler_body)) -> 
          let ctx' = extend_var_mono ctx name body_te.ty in
          let handler_te = check ctx' level handler_body result_ty in
          THReturn (name, handler_te)
        | Ast.HOp ((op_name, arg_name, k_name, handler_body)) -> 
          do
            match Types.find_effect_op ctx.type_env op_name with
            | None -> error ($"unknown effect operation in handler: {op_name}")
            | Some ((effect_name, op_ty)) -> 
              let fresh_params =
                match List.assoc_opt effect_name effect_fresh_params with
                | Some p -> p
                | None -> []
               in
              let concrete_op_ty =
                if fresh_params = [] do
                  op_ty
                else
                  subst_tgens fresh_params op_ty in
              let (param_ty, ret_ty_op) =
                match Types.repr concrete_op_ty with
                | Types.TArrow ((a, _, b)) -> (a, b)
                | _ -> error ($"effect operation {op_name} must have function type")
               in
              let k_ty = Types.TCont (ret_ty_op, ctx.current_eff, result_ty) in
              let ctx' = extend_var_mono ctx arg_name param_ty in
              let ctx' = extend_var_mono ctx' k_name k_ty in
              let handler_te = check ctx' level handler_body result_ty in
              THOp (op_name, arg_name, k_name, handler_te)

          end

      end) arms in
    mk (TEHandle (body_te, typed_arms)) result_ty
  and synth_binop ctx level op e1 e2 =
    match op with
    | Ast.Add | Ast.Sub | Ast.Mul | Ast.Div -> 
      do
        let te1 = synth ctx level e1 in
        let te2 = synth ctx level e2 in
        try_unify te1.ty te2.ty;
        let resolved = Types.repr te1.ty in
        match resolved with
        | Types.TFloat -> mk (TEBinop (op, te1, te2)) Types.TFloat
        | Types.TVar {contents = Types.Unbound ((id, _))} -> 
          if List.mem id ctx.constraint_tvars do
            mk (TEBinop (op, te1, te2)) (Types.repr te1.ty)
          else do
            try_unify te1.ty Types.TInt;
            mk (TEBinop (op, te1, te2)) Types.TInt
          end
        | Types.TInt -> mk (TEBinop (op, te1, te2)) Types.TInt
        | _ -> mk (TEBinop (op, te1, te2)) (Types.repr te1.ty)

      end
    | Ast.Mod -> 
      let te1 = check ctx level e1 Types.TInt in
      let te2 = check ctx level e2 Types.TInt in
      mk (TEBinop (op, te1, te2)) Types.TInt
    | Ast.Lt | Ast.Gt | Ast.Le | Ast.Ge -> 
      let te1 = synth ctx level e1 in
      let te2 = synth ctx level e2 in
      try_unify te1.ty te2.ty;
      mk (TEBinop (op, te1, te2)) Types.TBool
    | Ast.Eq | Ast.Neq -> 
      let te1 = synth ctx level e1 in
      let te2 = synth ctx level e2 in
      try_unify te1.ty te2.ty;
      mk (TEBinop (op, te1, te2)) Types.TBool
    | Ast.And | Ast.Or -> 
      let te1 = check ctx level e1 Types.TBool in
      let te2 = check ctx level e2 Types.TBool in
      mk (TEBinop (op, te1, te2)) Types.TBool
    | Ast.Concat -> 
      let te1 = check ctx level e1 Types.TString in
      let te2 = check ctx level e2 Types.TString in
      mk (TEBinop (op, te1, te2)) Types.TString
    | Ast.Land | Ast.Lor | Ast.Lxor | Ast.Lsl | Ast.Lsr -> 
      do
        let te1 = synth ctx level e1 in
        let te2 = synth ctx level e2 in
        try_unify te1.ty te2.ty;
        let resolved = Types.repr te1.ty in
        match resolved with
        | Types.TInt -> mk (TEBinop (op, te1, te2)) Types.TInt
        | Types.TVar {contents = Types.Unbound ((id, _))} -> 
          if List.mem id ctx.constraint_tvars do
            mk (TEBinop (op, te1, te2)) (Types.repr te1.ty)
          else do
            try_unify te1.ty Types.TInt;
            mk (TEBinop (op, te1, te2)) Types.TInt
          end
        | _ -> mk (TEBinop (op, te1, te2)) (Types.repr te1.ty)

      end
    | Ast.Pipe -> 
      let te1 = synth ctx level e1 in
      let te2 = synth ctx level e2 in
      let ret_ty = Types.new_tvar level in
      let call_eff = Types.new_effvar level in
      try_unify te2.ty (Types.TArrow (te1.ty, call_eff, ret_ty));
      try_subeffect call_eff ctx.current_eff;
      mk (TEBinop (op, te1, te2)) ret_ty

  and synth_unop ctx level op e =
    match op with
    | Ast.Neg -> 
      do
        let te = synth ctx level e in
        let resolved = Types.repr te.ty in
        match resolved with
        | Types.TFloat -> mk (TEUnop (op, te)) Types.TFloat
        | Types.TVar {contents = Types.Unbound ((id, _))} -> 
          if List.mem id ctx.constraint_tvars do
            mk (TEUnop (op, te)) (Types.repr te.ty)
          else do
            try_unify te.ty Types.TInt;
            mk (TEUnop (op, te)) Types.TInt
          end
        | Types.TInt -> mk (TEUnop (op, te)) Types.TInt
        | _ -> mk (TEUnop (op, te)) te.ty

      end
    | Ast.Not -> 
      let te = check ctx level e Types.TBool in
      mk (TEUnop (op, te)) Types.TBool
    | Ast.Lnot -> 
      do
        let te = synth ctx level e in
        let resolved = Types.repr te.ty in
        match resolved with
        | Types.TInt -> mk (TEUnop (op, te)) Types.TInt
        | Types.TVar {contents = Types.Unbound _} -> 
          try_unify te.ty Types.TInt;
          mk (TEUnop (op, te)) Types.TInt
        | _ -> mk (TEUnop (op, te)) te.ty

      end

  and qualify_ctor_name type_env name info =
    if String.contains name "." do
      name
    else
      match String.rindex_opt info.ctor_type_name #2e with
      | Some i -> 
        let qualified = (String.sub info.ctor_type_name 0 (i + 1)) ^ name in
        if (List.assoc_opt qualified type_env.constructors) <> None do
          qualified
        else
          name
      | None -> name

  and qualify_pattern type_env pat =
    let rec go pat =
      match pat with
      | Ast.PatConstruct ((name, arg)) -> 
        let qname =
          match List.assoc_opt name type_env.constructors with
          | Some info -> qualify_ctor_name type_env name info
          | None -> name
         in
        Ast.PatConstruct (qname, Option.map go arg)
      | Ast.PatTuple ps -> Ast.PatTuple (List.map go ps)
      | Ast.PatCons ((hd, tl)) -> Ast.PatCons (go hd, go tl)
      | Ast.PatOr ((p1, p2)) -> Ast.PatOr (go p1, go p2)
      | Ast.PatAs ((p, n)) -> Ast.PatAs (go p, n)
      | Ast.PatRecord fields -> Ast.PatRecord (List.map (fn (f, p) -> (f, go p)) fields)
      | Ast.PatArray ps -> Ast.PatArray (List.map go ps)
      | Ast.PatMap kvs -> Ast.PatMap (List.map (fn (k, v) -> (go k, go v)) kvs)
      | Ast.PatAnnot ((p, a)) -> Ast.PatAnnot (go p, a)
      | _ -> pat
     in
    go pat
  and synth_construct ctx level name arg =
    match List.assoc_opt name ctx.type_env.constructors with
    | None -> error ($"unknown constructor: {name}")
    | Some info -> 
      do
        let qname = qualify_ctor_name ctx.type_env name info in
        let num_fresh = info.ctor_num_params + info.ctor_existentials in
        let all_fresh = List.init num_fresh (fn _ -> Types.new_tvar level) in
        let fresh_universals = List.filteri (fn i _ -> i < info.ctor_num_params) all_fresh in
        let result_ty =
          match info.ctor_return_ty_params with
          | None -> Types.TVariant (info.ctor_type_name, fresh_universals)
          | Some params -> Types.TVariant (info.ctor_type_name, List.map (subst_tgens all_fresh) params)
         in
        match (info.ctor_arg_ty, arg) with
        | (None, None) -> mk (TEConstruct (qname, None)) result_ty
        | (Some expected_ty, Some arg_expr) -> 
          let concrete_ty = freshen_arrow_effects level (subst_tgens all_fresh expected_ty) in
          let arg_te = check ctx level arg_expr concrete_ty in
          mk (TEConstruct (qname, Some arg_te)) result_ty
        | (None, Some _) -> error ($"constructor {name} takes no arguments")
        | (Some expected_ty, None) -> 
          let concrete_ty = freshen_arrow_effects level (subst_tgens all_fresh expected_ty) in
          let param = "__x" in
          let param_var = mk (TEVar param) concrete_ty in
          let body = mk (TEConstruct (qname, Some param_var)) result_ty in
          mk (TEFun (param, body, false)) (Types.TArrow (concrete_ty, Types.EffEmpty, result_ty))

      end

  and freeze_texpr te =
    let ft = Types.deep_repr te.ty in
    let fe =
      match te.expr with
      | TEInt _ | TEFloat _ | TEBool _ | TEString _ | TEByte _ | TERune _ | TEUnit | TEVar _ | TENil -> te.expr
      | TELet ((n, s, e1, e2)) -> TELet (n, s, freeze_texpr e1, freeze_texpr e2)
      | TELetRec ((n, s, e1, e2)) -> TELetRec (n, s, freeze_texpr e1, freeze_texpr e2)
      | TEFun ((p, body, hr)) -> TEFun (p, freeze_texpr body, hr)
      | TEApp ((f, a)) -> TEApp (freeze_texpr f, freeze_texpr a)
      | TEIf ((c, t, e)) -> TEIf (freeze_texpr c, freeze_texpr t, freeze_texpr e)
      | TEBinop ((op, l, r)) -> TEBinop (op, freeze_texpr l, freeze_texpr r)
      | TEUnop ((op, e)) -> TEUnop (op, freeze_texpr e)
      | TETuple es -> TETuple (List.map freeze_texpr es)
      | TERecord fs -> TERecord (List.map (fn (n, e) -> (n, freeze_texpr e)) fs)
      | TERecordUpdate ((base, overrides)) -> TERecordUpdate (freeze_texpr base, List.map (fn (n, e) -> (n, freeze_texpr e)) overrides)
      | TERecordUpdateIdx ((base, pairs)) -> TERecordUpdateIdx (freeze_texpr base, List.map (fn (i, v) -> (freeze_texpr i, freeze_texpr v)) pairs)
      | TEField ((e, f)) -> TEField (freeze_texpr e, f)
      | TEIndex ((e, i)) -> TEIndex (freeze_texpr e, freeze_texpr i)
      | TECons ((h, t)) -> TECons (freeze_texpr h, freeze_texpr t)
      | TEConstruct ((n, arg)) -> TEConstruct (n, Option.map freeze_texpr arg)
      | TEMatch ((s, arms, p)) -> TEMatch (freeze_texpr s, List.map (fn (pat, g, b) -> (pat, Option.map freeze_texpr g, freeze_texpr b)) arms, p)
      | TELetMut ((n, e1, e2)) -> TELetMut (n, freeze_texpr e1, freeze_texpr e2)
      | TEAssign ((n, e)) -> TEAssign (n, freeze_texpr e)
      | TEFieldAssign ((e, f, v)) -> TEFieldAssign (freeze_texpr e, f, freeze_texpr v)
      | TESeq ((e1, e2)) -> TESeq (freeze_texpr e1, freeze_texpr e2)
      | TEPerform ((name, e)) -> TEPerform (name, freeze_texpr e)
      | TEHandle ((e, arms)) -> TEHandle (freeze_texpr e, List.map (fn arm ->
        do
          match arm with
          | THReturn ((n, b)) -> THReturn (n, freeze_texpr b)
          | THOp ((eff, x, k, b)) -> THOp (eff, x, k, freeze_texpr b)

        end) arms)
      | TEResume ((k, v)) -> TEResume (freeze_texpr k, freeze_texpr v)
      | TEWhile ((c, b)) -> TEWhile (freeze_texpr c, freeze_texpr b)
      | TEBreak e -> TEBreak (freeze_texpr e)
      | TEContinueLoop -> TEContinueLoop
      | TEFoldContinue e -> TEFoldContinue (freeze_texpr e)
      | TEForLoop e -> TEForLoop (freeze_texpr e)
      | TELetRecAnd ((binds, body)) -> TELetRecAnd (List.map (fn (n, e) -> (n, freeze_texpr e)) binds, freeze_texpr body)
      | TEMap pairs -> TEMap (List.map (fn (k, v) -> (freeze_texpr k, freeze_texpr v)) pairs)
      | TEArray es -> TEArray (List.map freeze_texpr es)
      | TEReturn e -> TEReturn (freeze_texpr e)
     in
    {expr = fe; ty = ft; loc = te.loc}
  and check_pattern_gadt ctx level pat scrut_ty =
    match pat with
    | Ast.PatConstruct ((name, arg_pat)) -> 
      do
        match List.assoc_opt name ctx.type_env.constructors with
        | None -> error ($"unknown constructor in pattern: {name}")
        | Some info -> 
          let num_fresh = info.ctor_num_params + info.ctor_existentials in
          let all_fresh = List.init num_fresh (fn _ -> Types.new_tvar level) in
          let existential_refs = List.filter_map (fn i -> if i >= info.ctor_num_params do
            do
              match List.nth all_fresh i with
              | Types.TVar r -> Some r
              | _ -> None

            end
          else
            None) (List.init num_fresh (fn x -> x)) in
          let return_ty =
            match info.ctor_return_ty_params with
            | Some params -> Types.TVariant (info.ctor_type_name, List.map (subst_tgens all_fresh) params)
            | None -> 
              let fresh_universals = List.filteri (fn i _ -> i < info.ctor_num_params) all_fresh in
              Types.TVariant (info.ctor_type_name, fresh_universals)
           in
          try_unify scrut_ty return_ty;
          let bindings =
            match (info.ctor_arg_ty, arg_pat) with
            | (None, None) -> []
            | (Some arg_ty, Some p) -> 
              let concrete_ty = freshen_arrow_effects level (subst_tgens all_fresh arg_ty) in
              check_pattern ctx level p concrete_ty
            | (None, Some _) -> error ($"constructor {name} takes no arguments")
            | (Some _, None) -> error ($"constructor {name} requires an argument")
           in
          (bindings, existential_refs)

      end
    | _ -> (check_pattern ctx level pat scrut_ty, [])

  and check_existential_escape existential_refs result_ty =
    let rec collect_tvar_refs acc ty =
      match Types.repr ty with
      | Types.TVar ({contents = Types.Unbound _} as r) -> 
        if List.exists (fn x -> x = r) acc do
          acc
        else
          r :: acc
      | Types.TArrow ((a, _, b)) | Types.TCont ((a, _, b)) -> collect_tvar_refs (collect_tvar_refs acc a) b
      | Types.TTuple ts -> List.fold collect_tvar_refs acc ts
      | Types.TList t -> collect_tvar_refs acc t
      | Types.TArray t -> collect_tvar_refs acc t
      | Types.TMap ((k, v)) -> collect_tvar_refs (collect_tvar_refs acc k) v
      | Types.TRecord row -> List.fold (fn a (_, t) -> collect_tvar_refs a t) acc (Types.record_row_to_fields row)
      | Types.TVariant ((_, args)) -> List.fold collect_tvar_refs acc args
      | Types.TPolyVariant row -> 
        let rec collect_pv a =
          fn
            | Types.PVRow ((_, Some t, tail)) -> collect_pv (collect_tvar_refs a t) tail
            | Types.PVRow ((_, None, tail)) -> collect_pv a tail
            | _ -> a
         in
        collect_pv acc row
      | _ -> acc
     in
    let result_refs = collect_tvar_refs [] (Types.deep_repr result_ty) in
    let has_escape = List.exists (fn exist_ref ->
      do
        match Types.repr (Types.TVar exist_ref) with
        | Types.TVar ({contents = Types.Unbound _} as resolved_ref) -> List.exists (fn r -> r = resolved_ref) result_refs
        | resolved -> 
          let exist_refs = collect_tvar_refs [] resolved in
          List.exists (fn er -> List.exists (fn rr -> er = rr) result_refs) exist_refs

      end) existential_refs in
    if has_escape do
      error "existential type variable would escape the scope of its GADT match arm"
    end
  and synth_match expected_ty ctx level scrut arms partial =
    let scrut_te = synth ctx level scrut in
    let gadt_info =
      match Types.repr scrut_te.ty with
      | Types.TVariant ((name, params)) -> 
        do
          match find_variant_info ctx.type_env name with
          | Some ((_, _, _, true)) -> Some (name, params)
          | _ -> None

        end
      | _ -> None
     in
    match gadt_info with
    | Some ((_gadt_name, scrut_params)) -> 
      do
        let result_ty =
          match expected_ty with
          | Some ty -> ty
          | None -> Types.new_tvar level
         in
        let get_tvar_ref ty =
          match Types.repr ty with
          | Types.TVar r -> Some r
          | _ -> None
         in
        let param_refs = List.filter_map (fn p ->
          do
            match get_tvar_ref p with
            | Some r -> Some (r, Ref.get r)
            | None -> None

          end) scrut_params in
        let save_snapshot () = List.map (fn (r, _) -> (r, Ref.get r)) param_refs in
        let restore_snapshot saved = List.iter (fn (r, v) -> Ref.set r v) saved in
        let check_gadt_arm (pat, guard, body) =
          let snapshot = save_snapshot () in
          let ctor_name =
            match pat with
            | Ast.PatConstruct ((name, _)) -> Some name
            | _ -> None
           in
          let is_gadt_ctor =
            match ctor_name with
            | Some name -> 
              do
                match List.assoc_opt name ctx.type_env.constructors with
                | Some info -> info.ctor_return_ty_params <> None
                | None -> false

              end
            | None -> false
           in
          let (bindings, existential_refs) =
            if is_gadt_ctor do
              check_pattern_gadt ctx level pat scrut_te.ty
            else
              (check_pattern ctx level pat scrut_te.ty, []) in
          let ctx' = List.fold (fn c (n, t) -> extend_var_mono c n t) ctx bindings in
          let guard_te =
            match guard with
            | Some g -> Some (check ctx' level g Types.TBool)
            | None -> None
           in
          let body_te = check ctx' level body result_ty in
          let guard_te = Option.map freeze_texpr guard_te in
          let body_te = freeze_texpr body_te in
          if existential_refs <> [] do
            check_existential_escape existential_refs result_ty
          end;
          restore_snapshot snapshot;
          (qualify_pattern ctx.type_env pat, guard_te, body_te) in
        match arms with
        | [] -> error "match expression has no arms"
        | first :: rest -> 
          let first_arm = check_gadt_arm first in
          let rest_arms = List.map check_gadt_arm rest in
          let all_arms = first_arm :: rest_arms in
          if not partial do
            Ref.get exhaustiveness_check_ref ctx (Types.repr scrut_te.ty) all_arms
          end;
          mk (TEMatch (scrut_te, all_arms, partial)) result_ty

      end
    | None -> 
      do
        let check_arm ctx (pat, guard, body) =
          let bindings = check_pattern ctx level pat scrut_te.ty in
          let ctx' = List.fold (fn c (n, t) -> extend_var_mono c n t) ctx bindings in
          let guard_te =
            match guard with
            | Some g -> 
              let gte = check ctx' level g Types.TBool in
              Some gte
            | None -> None
           in
          let body_te = synth ctx' level body in
          (qualify_pattern ctx.type_env pat, guard_te, body_te) in
        match arms with
        | [] -> error "match expression has no arms"
        | first :: rest -> 
          let (fp, fg, fb) = check_arm ctx first in
          let result_ty = fb.ty in
          let all_arms = (fp, fg, fb) :: List.map (fn arm -> let (p, g, b) = check_arm ctx arm in
          try_unify b.ty result_ty;
          (p, g, b)) rest in
          if not partial do
            Ref.get exhaustiveness_check_ref ctx (Types.repr scrut_te.ty) all_arms
          end;
          mk (TEMatch (scrut_te, all_arms, partial)) result_ty

      end

  and check ctx level (expr : Ast.expr) (expected : Types.ty) : texpr =
    match expr with
    | Ast.ELoc ((loc, inner)) -> 
      Ref.set current_loc loc;
      check ctx level inner expected
    | Ast.EFun ((param, body)) when param.annot = None -> 
      let arg_ty = Types.new_tvar level in
      let ret_ty = Types.new_tvar level in
      let fn_eff = Types.new_effvar level in
      try_unify expected (Types.TArrow (arg_ty, fn_eff, ret_ty));
      let return_used = Ref.create false in
      let ctx' = extend_var_mono {ctx with current_eff = fn_eff; return_type = Some ret_ty; inside_handler = false; return_used} param.name (Types.repr arg_ty) in
      let body_te = check ctx' level body ret_ty in
      let has_return =
        if param.is_generated do
          false
        else
          Ref.get return_used in
      mk (TEFun (param.name, body_te, has_return)) (Types.TArrow (arg_ty, fn_eff, body_te.ty))
    | Ast.EMatch ((scrut, arms, partial)) -> synth_match (Some expected) ctx level scrut arms partial
    | _ -> 
      let te = synth ctx level expr in
      try_unify te.ty expected;
      {te with ty = expected}

  and check_pattern ctx level (pat : Ast.pattern) (ty : Types.ty) : (string * Types.ty) list =
    match pat with
    | Ast.PatWild -> []
    | Ast.PatVar name -> (name, ty) :: []
    | Ast.PatInt _ -> 
      try_unify ty Types.TInt;
      []
    | Ast.PatFloat _ -> 
      try_unify ty Types.TFloat;
      []
    | Ast.PatBool _ -> 
      try_unify ty Types.TBool;
      []
    | Ast.PatString _ -> 
      try_unify ty Types.TString;
      []
    | Ast.PatUnit -> 
      try_unify ty Types.TUnit;
      []
    | Ast.PatTuple pats -> 
      let tys = List.map (fn _ -> Types.new_tvar level) pats in
      try_unify ty (Types.TTuple tys);
      List.flatten (List.map2 (check_pattern ctx level) pats tys)
    | Ast.PatCons ((hd_pat, tl_pat)) -> 
      let elem_ty = Types.new_tvar level in
      try_unify ty (Types.TList elem_ty);
      let hd_bindings = check_pattern ctx level hd_pat elem_ty in
      let tl_bindings = check_pattern ctx level tl_pat ty in
      List.concat hd_bindings tl_bindings
    | Ast.PatNil -> 
      let elem_ty = Types.new_tvar level in
      try_unify ty (Types.TList elem_ty);
      []
    | Ast.PatConstruct ((name, arg_pat)) -> 
      do
        match List.assoc_opt name ctx.type_env.constructors with
        | None -> error ($"unknown constructor in pattern: {name}")
        | Some info -> 
          do
            let fresh_args = List.init info.ctor_num_params (fn _ -> Types.new_tvar level) in
            let expected_variant = Types.TVariant (info.ctor_type_name, fresh_args) in
            try_unify ty expected_variant;
            match (info.ctor_arg_ty, arg_pat) with
            | (None, None) -> []
            | (Some arg_ty, Some p) -> 
              let concrete_ty = freshen_arrow_effects level (subst_tgens fresh_args arg_ty) in
              check_pattern ctx level p concrete_ty
            | (None, Some _) -> error ($"constructor {name} takes no arguments")
            | (Some _, None) -> error ($"constructor {name} requires an argument")

          end

      end
    | Ast.PatRecord field_pats -> 
      let field_tys =
        match Types.repr ty with
        | Types.TRecord row -> Types.record_row_to_fields row
        | _ -> 
          do
            let pat_field_names = List.map fst field_pats in
            let candidates = List.filter (fn (_name, fields) -> List.forall (fn fn_ -> List.mem_assoc fn_ fields) pat_field_names) ctx.type_env.records in
            match candidates with
            | (_name, fields) :: [] -> 
              let row = instantiate_record_row level fields in
              try_unify ty (Types.TRecord row);
              instantiate_record_fields level fields
            | [] -> 
              do
                match Types.repr ty with
                | Types.TVar _ -> 
                  let row = List.fold_right (fn fname rest -> Types.RRow (fname, Types.new_tvar level, rest)) pat_field_names (Types.new_rvar level) in
                  try_unify ty (Types.TRecord row);
                  Types.record_row_to_fields (match Types.repr ty with
                  | Types.TRecord r -> r
                  | _ -> error "record pattern used with non-record type"
                  )
                | _ -> error "record pattern used with non-record type"

              end
            | _ -> error "ambiguous record pattern  annotate the type"

          end
       in
      List.flatten (List.map (fn (name, pat) ->
        do
          match List.assoc_opt name field_tys with
          | Some fty -> check_pattern ctx level pat fty
          | None -> error ($"record type has no field {name}")

        end) field_pats)
    | Ast.PatAs ((inner_pat, name)) -> 
      let bindings = check_pattern ctx level inner_pat ty in
      (name, ty) :: bindings
    | Ast.PatOr ((p1, p2)) -> 
      let bindings1 = check_pattern ctx level p1 ty in
      let bindings2 = check_pattern ctx level p2 ty in
      let names1 = (List.map fst bindings1) |> (List.sort String.compare) in
      let names2 = (List.map fst bindings2) |> (List.sort String.compare) in
      if names1 <> names2 do
        error "or-pattern branches must bind the same variables"
      end;
      List.iter (fn (name, ty1) ->
        do
          match List.assoc_opt name bindings2 with
          | Some ty2 -> try_unify ty1 ty2
          | None -> ()

        end) bindings1;
      bindings1
    | Ast.PatArray pats -> 
      let elem_ty = Types.new_tvar level in
      try_unify ty (Types.TArray elem_ty);
      List.concat_map (fn p -> check_pattern ctx level p elem_ty) pats
    | Ast.PatMap entries -> 
      let key_ty = Types.new_tvar level in
      let val_ty = Types.new_tvar level in
      try_unify ty (Types.TMap (key_ty, val_ty));
      List.concat_map (fn (kpat, vpat) -> List.concat (check_pattern ctx level kpat key_ty) (check_pattern ctx level vpat val_ty)) entries
    | Ast.PatPolyVariant ((tag, None)) -> 
      let tail = Types.new_pvvar level in
      let row = Types.PVRow (tag, None, tail) in
      try_unify ty (Types.TPolyVariant row);
      []
    | Ast.PatPolyVariant ((tag, Some sub_pat)) -> 
      let payload_ty = Types.new_tvar level in
      let tail = Types.new_pvvar level in
      let row = Types.PVRow (tag, Some payload_ty, tail) in
      try_unify ty (Types.TPolyVariant row);
      check_pattern ctx level sub_pat payload_ty
    | Ast.PatPin name -> 
      do
        match List.assoc_opt name ctx.vars with
        | Some scheme -> 
          let var_ty = Types.instantiate level scheme in
          try_unify ty var_ty;
          []
        | None -> error ($"unbound variable in pin pattern: {name}")

      end
    | Ast.PatAnnot ((inner_pat, annot)) -> 
      let annot_ty = resolve_ty_annot ctx level annot in
      try_unify ty annot_ty;
      check_pattern ctx level inner_pat ty

  and synth_poly_rec_fn ctx level name qualified_name type_params params ret_annot body =
    let shared_tvars = Hashtbl.create 4 in
    List.iter (fn tp -> Hashtbl.set shared_tvars tp (Types.new_tvar (level + 1))) type_params;
    let param_tys = List.map (fn (p : Ast.param) ->
      do
        match p.annot with
        | Some annot -> resolve_ty_annot_shared ctx (level + 1) shared_tvars annot
        | None -> Types.new_tvar (level + 1)

      end) params in
    let (ret_ty, body_eff) =
      match ret_annot with
      | Some (Ast.TyWithEffect ((ty, eff_annot))) -> 
        let ty' = resolve_ty_annot_shared ctx (level + 1) shared_tvars ty in
        let eff =
          match eff_annot with
          | Ast.EffAnnotPure -> Types.EffEmpty
          | Ast.EffAnnotRow items -> resolve_eff_items ctx (level + 1) shared_tvars items
         in
        (ty', eff)
      | Some annot -> (resolve_ty_annot_shared ctx (level + 1) shared_tvars annot, Types.new_effvar (level + 1))
      | None -> (Types.new_tvar (level + 1), Types.new_effvar (level + 1))
     in
    let fn_ty =
      match List.rev param_tys with
      | [] -> ret_ty
      | last :: rest -> 
        let inner = Types.TArrow (last, body_eff, ret_ty) in
        List.fold (fn acc pty -> Types.TArrow (pty, Types.EffEmpty, acc)) inner rest
     in
    let scheme = Types.generalize level fn_ty in
    let ctx_with_self = extend_var ctx name scheme in
    let ctx_with_self =
      if qualified_name <> "" do
        extend_var ctx_with_self qualified_name scheme
      else
        ctx_with_self in
    let inner_ctx = List.fold2 (fn c (p : Ast.param) ty -> extend_var_mono c p.name ty) {ctx_with_self with current_eff = body_eff} params param_tys in
    let body_te = check inner_ctx (level + 1) body ret_ty in
    let te =
      match (List.rev params, List.rev param_tys) with
      | ([], []) -> body_te
      | (last_p :: rest_ps, last_pty :: rest_ptys) -> 
        let inner = mk (TEFun (last_p.name, body_te, false)) (Types.TArrow (last_pty, body_eff, body_te.ty)) in
        List.fold2 (fn acc (p : Ast.param) pty -> mk (TEFun (p.name, acc, false)) (Types.TArrow (pty, Types.EffEmpty, acc.ty))) inner rest_ps rest_ptys
      | _ -> failwith "assert false"
     in
    (te, scheme)

  pub let rec normalize_pattern (pat : Ast.pattern) : Ast.pattern list =
    match pat with
    | Ast.PatAs ((inner, _)) -> normalize_pattern inner
    | Ast.PatOr ((p1, p2)) -> List.concat (normalize_pattern p1) (normalize_pattern p2)
    | p -> p :: []


  pub let ctor_short_name name =
    match String.rindex_opt name #2e with
    | Some i -> String.sub name (i + 1) (((String.length name) - i) - 1)
    | None -> name


  pub let rec specialize_variant pats ctor_name = List.concat_map (fn pat ->
    do
      match pat with
      | Ast.PatConstruct ((name, sub)) when (ctor_short_name name) = ctor_name -> 
        do
          match sub with
          | Some p -> normalize_pattern p
          | None -> Ast.PatWild :: []

        end
      | Ast.PatConstruct ((_, _)) -> []
      | Ast.PatWild | Ast.PatVar _ -> Ast.PatWild :: []
      | Ast.PatAs ((inner, _)) -> specialize_variant (normalize_pattern inner) ctor_name
      | Ast.PatOr ((p1, p2)) -> List.concat (specialize_variant (normalize_pattern p1) ctor_name) (specialize_variant (normalize_pattern p2) ctor_name)
      | _ -> []

    end) pats

  pub let has_wildcard pats = List.exists (fn p ->
    do
      match p with
      | Ast.PatWild | Ast.PatVar _ -> true
      | _ -> false

    end) pats

  pub let rec uncovered_patterns type_env ty pats =
    let pats = List.concat_map normalize_pattern pats in
    if has_wildcard pats do
      []
    else
      match Types.repr ty with
      | Types.TVariant ((name, args)) -> 
        do
          match find_variant_info type_env name with
          | None -> []
          | Some ((_, _, ctors, is_gadt)) -> 
            let reachable_ctors =
              if is_gadt do
                List.filter (fn (ctor_name, _) ->
                  do
                    match List.assoc_opt ctor_name type_env.constructors with
                    | Some info -> 
                      do
                        match info.ctor_return_ty_params with
                        | None -> true
                        | Some ret_params -> ((List.length ret_params) = (List.length args)) && (List.forall2 Types.types_compatible (List.map (fn p -> subst_tgens args p) ret_params) args)

                      end
                    | None -> true

                  end) ctors
              else
                ctors in
            List.concat_map (fn (ctor_name, ctor_arg_ty) -> let sub_pats = specialize_variant pats ctor_name in
            match ctor_arg_ty with
            | None -> 
              if (List.length sub_pats) = 0 do
                ctor_name :: []
              else
                []
            | Some arg_ty -> 
              if (List.length sub_pats) = 0 do
                ctor_name ^ " _" :: []
              else do
                let sub_missing = uncovered_patterns type_env arg_ty sub_pats in
                List.map (fn m -> ctor_name ^ (" (" ^ (m ^ ")"))) sub_missing
              end
            ) reachable_ctors

        end
      | Types.TBool -> 
        let has_true = List.exists (fn p ->
          do
            match p with
            | Ast.PatBool true -> true
            | _ -> false

          end) pats in
        let has_false = List.exists (fn p ->
          do
            match p with
            | Ast.PatBool false -> true
            | _ -> false

          end) pats in
        let missing = Ref.create [] in
        if not has_true do
          Ref.set missing ("true" :: Ref.get missing)
        end;
        if not has_false do
          Ref.set missing ("false" :: Ref.get missing)
        end;
        Ref.get missing
      | Types.TList _ -> 
        let has_nil = List.exists (fn p ->
          do
            match p with
            | Ast.PatNil -> true
            | _ -> false

          end) pats in
        let has_cons = List.exists (fn p ->
          do
            match p with
            | Ast.PatCons _ -> true
            | _ -> false

          end) pats in
        let missing = Ref.create [] in
        if not has_nil do
          Ref.set missing ("[]" :: Ref.get missing)
        end;
        if not has_cons do
          Ref.set missing ("_ :: _" :: Ref.get missing)
        end;
        Ref.get missing
      | Types.TArray _ -> 
        let lengths = List.filter_map (fn p ->
          do
            match p with
            | Ast.PatArray elems -> Some (List.length elems)
            | _ -> None

          end) pats in
        let lengths_set = List.sort_uniq compare lengths in
        let rec find_missing n =
          if List.mem n lengths_set do
            find_missing (n + 1)
          else
            n in
        let missing_len = find_missing 0 in
        let missing_pat =
          if missing_len = 0 do
            "#[]"
          else
            "#[" ^ ((String.concat "; " (List.init missing_len (fn _ -> "_"))) ^ "]") in
        missing_pat :: []
      | Types.TMap _ -> "_" :: []
      | Types.TInt | Types.TFloat | Types.TString -> "_" :: []
      | Types.TUnit -> 
        let has_unit = List.exists (fn p ->
          do
            match p with
            | Ast.PatUnit -> true
            | _ -> false

          end) pats in
        if has_unit do
          []
        else
          "()" :: []
      | Types.TTuple ts -> 
        let tuple_pats = List.filter_map (fn p ->
          do
            match p with
            | Ast.PatTuple ps when (List.length ps) = (List.length ts) -> Some ps
            | _ -> None

          end) pats in
        if tuple_pats = [] do
          "(" ^ ((String.concat ", " (List.init (List.length ts) (fn _ -> "_"))) ^ ")") :: []
        else do
          let rec check_positions i =
            fn
              | [] -> []
              | elem_ty :: rest_tys -> 
                let position_pats = List.map (fn ps -> List.nth ps i) tuple_pats in
                let sub_missing = uncovered_patterns type_env elem_ty position_pats in
                if sub_missing <> [] do
                  let template = List.init (List.length ts) (fn j -> if j = i do
                    List.hd sub_missing
                  else
                    "_") in
                  "(" ^ ((String.concat ", " template) ^ ")") :: []
                else
                  check_positions (i + 1) rest_tys
           in
          check_positions 0 ts
        end
      | _ -> []


  pub let exhaustiveness_check ctx ty arms =
    let unguarded_pats = List.filter_map (fn (pat, guard, _body) ->
      do
        match guard with
        | None -> Some pat
        | Some _ -> None

      end) arms in
    let missing = uncovered_patterns ctx.type_env ty unguarded_pats in
    if missing <> [] do
      error ($"non-exhaustive match, missing: {String.concat ", " missing}")
    end

  pub let () = Ref.set exhaustiveness_check_ref exhaustiveness_check

  pub let process_type_def ctx type_params type_name (def : Ast.type_def) : ctx =
    let num_params = List.length type_params in
    match def with
    | Ast.TDVariant ctors -> 
      let pre_ctx = {ctx with type_env = {ctx.type_env with variants = (type_name, num_params, [], false) :: ctx.type_env.variants}} in
      let param_tbl = Hashtbl.create 4 in
      List.iteri (fn i name -> Hashtbl.set param_tbl name i) type_params;
      let resolve_with_params annot =
        let tvars = Hashtbl.create 4 in
        let rec go =
          fn
            | Ast.TyVar name -> 
              do
                match Hashtbl.get param_tbl name with
                | Some idx -> Types.TGen idx
                | None -> 
                  do
                    match Hashtbl.get tvars name with
                    | Some tv -> tv
                    | None -> 
                      let tv = Types.new_tvar 0 in
                      Hashtbl.set tvars name tv;
                      tv

                  end

              end
            | Ast.TyName "int" -> Types.TInt
            | Ast.TyName "float" -> Types.TFloat
            | Ast.TyName "bool" -> Types.TBool
            | Ast.TyName "string" -> Types.TString
            | Ast.TyName "unit" -> Types.TUnit
            | Ast.TyName name -> 
              do
                let canonical = resolve_type_alias pre_ctx.type_env name in
                match List.find (fn (n, _, _) -> n = canonical) pre_ctx.type_env.type_synonyms with
                | Some ((_, 0, ty)) -> ty
                | Some ((_, n, _)) -> error ($"type {name} expects {n} type argument(s)")
                | None -> 
                  do
                    match find_variant_info pre_ctx.type_env name with
                    | Some ((_, 0, _, _)) -> Types.TVariant (canonical, [])
                    | Some ((_, n, _, _)) -> error ($"type {name} expects {n} type argument(s)")
                    | None -> 
                      if (List.assoc_opt canonical pre_ctx.type_env.records) <> None do
                        let fields = List.assoc canonical pre_ctx.type_env.records in
                        Types.TRecord (Types.fields_to_closed_row fields)
                      else
                        error ($"unknown type: {name}")

                  end

              end
            | Ast.TyArrow ((a, b, _)) -> Types.TArrow (go a, Types.EffEmpty, go b)
            | Ast.TyTuple ts -> Types.TTuple (List.map go ts)
            | Ast.TyList t -> Types.TList (go t)
            | Ast.TyArray t -> Types.TArray (go t)
            | Ast.TyMap ((k, v)) -> Types.TMap (go k, go v)
            | Ast.TyApp ((args, tname)) -> 
              do
                let canonical = resolve_type_alias pre_ctx.type_env tname in
                let arg_tys = List.map go args in
                match List.find (fn (n, _, _) -> n = canonical) pre_ctx.type_env.type_synonyms with
                | Some ((_, np, ty)) -> 
                  if (List.length arg_tys) <> np do
                    error ($"type {tname} expects {np} type argument(s), got {List.length arg_tys}")
                  end;
                  subst_tgens arg_tys ty
                | None -> 
                  do
                    match find_variant_info pre_ctx.type_env tname with
                    | Some ((_, np, _, _)) -> 
                      if (List.length arg_tys) <> np do
                        error ($"type {tname} expects {np} type argument(s), got {List.length arg_tys}")
                      end;
                      Types.TVariant (canonical, arg_tys)
                    | None -> error ($"unknown type constructor: {tname}")

                  end

              end
            | Ast.TyRecord ((fields, is_open)) -> 
              let fields = List.map (fn (n, t) -> (n, go t)) fields in
              let fields = List.sort (fn (a, _) (b, _) -> String.compare a b) fields in
              let tail =
                if is_open do
                  Types.new_rvar 0
                else
                  Types.REmpty in
              Types.TRecord (List.fold_right (fn (n, t) acc -> Types.RRow (n, t, acc)) fields tail)
            | Ast.TyQualified ((path, name)) -> 
              let qualified = (String.concat "." path) ^ ("." ^ name) in
              go (Ast.TyName qualified)
            | Ast.TyPolyVariant ((_kind, tags)) -> 
              let row = List.fold_right (fn (tag, payload_annot) acc -> Types.PVRow (tag, Option.map go payload_annot, acc)) tags Types.PVEmpty in
              Types.TPolyVariant row
            | Ast.TyWithEffect ((ty, _)) -> go ty
         in
        go annot in
      let is_gadt = List.exists (fn (_, _, ret) -> ret <> None) ctors in
      let rec collect_annot_vars acc =
        fn
          | Ast.TyVar name -> 
            if List.mem name acc do
              acc
            else
              name :: acc
          | Ast.TyArrow ((a, b, _)) -> collect_annot_vars (collect_annot_vars acc a) b
          | Ast.TyTuple ts -> List.fold collect_annot_vars acc ts
          | Ast.TyList t | Ast.TyArray t -> collect_annot_vars acc t
          | Ast.TyMap ((k, v)) -> collect_annot_vars (collect_annot_vars acc k) v
          | Ast.TyApp ((args, _)) -> List.fold collect_annot_vars acc args
          | Ast.TyRecord ((fs, _)) -> List.fold (fn a (_, t) -> collect_annot_vars a t) acc fs
          | Ast.TyQualified _ | Ast.TyName _ -> acc
          | Ast.TyPolyVariant ((_, tags)) -> List.fold (fn a (_, ty_opt) ->
            do
              match ty_opt with
              | Some t -> collect_annot_vars a t
              | None -> a

            end) acc tags
          | Ast.TyWithEffect ((ty, _)) -> collect_annot_vars acc ty
       in
      let process_ctor (name, arg_annot, ret_annot) =
        match ret_annot with
        | None -> 
          let arg_ty = Option.map resolve_with_params arg_annot in
          let info = {ctor_type_name = type_name; ctor_arg_ty = arg_ty; ctor_num_params = num_params; ctor_return_ty_params = None; ctor_existentials = 0} in
          ((name, arg_ty), (name, info))
        | Some ret -> 
          let (ret_type_name, ret_type_args) =
            match ret with
            | Ast.TyName n -> (n, [])
            | Ast.TyApp ((args, n)) -> (n, args)
            | _ -> error ($"GADT constructor {name}: return type must be {type_name}")
           in
          let canonical_ret = resolve_type_alias pre_ctx.type_env ret_type_name in
          let name_matches = (canonical_ret = type_name) || (match String.rindex_opt type_name #2e with
          | Some i -> 
            let short = String.sub type_name (i + 1) (((String.length type_name) - i) - 1) in
            ret_type_name = short
          | None -> false
          ) in
          if not name_matches do
            error ($"GADT constructor {name}: return type must be {type_name}, got {ret_type_name}")
          end;
          if (List.length ret_type_args) <> num_params do
            error ($"GADT constructor {name}: return type has {List.length ret_type_args} type arg(s), expected {num_params}")
          end;
          let ret_vars = List.fold collect_annot_vars [] ret_type_args in
          let arg_vars =
            match arg_annot with
            | None -> []
            | Some a -> collect_annot_vars [] a
           in
          let existentials = List.filter (fn v -> (not (List.mem v ret_vars)) && (not (List.mem v type_params))) arg_vars in
          let num_exist = List.length existentials in
          let gadt_tbl = Hashtbl.create 8 in
          List.iteri (fn i p -> Hashtbl.set gadt_tbl p i) type_params;
          List.iteri (fn i e -> Hashtbl.set gadt_tbl e (num_params + i)) existentials;
          let gadt_tvars = Hashtbl.create 4 in
          let rec gadt_resolve =
            fn
              | Ast.TyVar vname -> 
                do
                  match Hashtbl.get gadt_tbl vname with
                  | Some idx -> Types.TGen idx
                  | None -> 
                    do
                      match Hashtbl.get gadt_tvars vname with
                      | Some tv -> tv
                      | None -> 
                        let tv = Types.new_tvar 0 in
                        Hashtbl.set gadt_tvars vname tv;
                        tv

                    end

                end
              | Ast.TyName "int" -> Types.TInt
              | Ast.TyName "float" -> Types.TFloat
              | Ast.TyName "bool" -> Types.TBool
              | Ast.TyName "string" -> Types.TString
              | Ast.TyName "unit" -> Types.TUnit
              | Ast.TyName n -> 
                do
                  let canonical = resolve_type_alias pre_ctx.type_env n in
                  match List.find (fn (tn, _, _) -> tn = canonical) pre_ctx.type_env.type_synonyms with
                  | Some ((_, 0, ty)) -> ty
                  | Some ((_, np, _)) -> error ($"type {n} expects {np} type argument(s)")
                  | None -> 
                    do
                      match find_variant_info pre_ctx.type_env n with
                      | Some ((_, 0, _, _)) -> Types.TVariant (canonical, [])
                      | Some ((_, np, _, _)) -> error ($"type {n} expects {np} type argument(s)")
                      | None -> 
                        if (List.assoc_opt canonical pre_ctx.type_env.records) <> None do
                          let fields = List.assoc canonical pre_ctx.type_env.records in
                          if fields = [] do
                            Types.TRecord Types.RWild
                          else
                            Types.TRecord (Types.fields_to_closed_row fields)
                        else
                          error ($"unknown type: {n}")

                    end

                end
              | Ast.TyArrow ((a, b, _)) -> Types.TArrow (gadt_resolve a, Types.EffEmpty, gadt_resolve b)
              | Ast.TyTuple ts -> Types.TTuple (List.map gadt_resolve ts)
              | Ast.TyList t -> Types.TList (gadt_resolve t)
              | Ast.TyArray t -> Types.TArray (gadt_resolve t)
              | Ast.TyMap ((k, v)) -> Types.TMap (gadt_resolve k, gadt_resolve v)
              | Ast.TyApp ((args, tname)) -> 
                do
                  let canonical = resolve_type_alias pre_ctx.type_env tname in
                  let arg_tys = List.map gadt_resolve args in
                  match List.find (fn (tn, _, _) -> tn = canonical) pre_ctx.type_env.type_synonyms with
                  | Some ((_, np, ty)) -> 
                    if (List.length arg_tys) <> np do
                      error ($"type {tname} expects {np} type argument(s), got {List.length arg_tys}")
                    end;
                    subst_tgens arg_tys ty
                  | None -> 
                    do
                      match find_variant_info pre_ctx.type_env tname with
                      | Some ((_, np, _, _)) -> 
                        if (List.length arg_tys) <> np do
                          error ($"type {tname} expects {np} type argument(s), got {List.length arg_tys}")
                        end;
                        Types.TVariant (canonical, arg_tys)
                      | None -> error ($"unknown type constructor: {tname}")

                    end

                end
              | Ast.TyRecord ((fields, is_open)) -> 
                let fields = List.sort (fn (a, _) (b, _) -> String.compare a b) (List.map (fn (fn_, ft) -> (fn_, gadt_resolve ft)) fields) in
                let tail =
                  if is_open do
                    Types.new_rvar 0
                  else
                    Types.REmpty in
                Types.TRecord (List.fold_right (fn (n, t) acc -> Types.RRow (n, t, acc)) fields tail)
              | Ast.TyQualified ((path, n)) -> 
                let qualified = (String.concat "." path) ^ ("." ^ n) in
                gadt_resolve (Ast.TyName qualified)
              | Ast.TyPolyVariant ((_kind, tags)) -> 
                let row = List.fold_right (fn (tag, payload_annot) acc -> Types.PVRow (tag, Option.map gadt_resolve payload_annot, acc)) tags Types.PVEmpty in
                Types.TPolyVariant row
              | Ast.TyWithEffect ((ty, _)) -> gadt_resolve ty
           in
          let arg_ty = Option.map gadt_resolve arg_annot in
          let ret_params = List.map gadt_resolve ret_type_args in
          let info = {ctor_type_name = type_name; ctor_arg_ty = arg_ty; ctor_num_params = num_params; ctor_return_ty_params = Some ret_params; ctor_existentials = num_exist} in
          ((name, arg_ty), (name, info))
       in
      let results = List.map process_ctor ctors in
      let variant_def = List.map fst results in
      let ctor_infos = List.map snd results in
      let type_env = {ctx.type_env with variants = (type_name, num_params, variant_def, is_gadt) :: ctx.type_env.variants; constructors = List.concat ctor_infos ctx.type_env.constructors} in
      {ctx with type_env}
    | Ast.TDRecord fields -> 
      let pre_ctx = {ctx with type_env = {ctx.type_env with records = (type_name, []) :: ctx.type_env.records}} in
      let param_tbl = Hashtbl.create 4 in
      List.iteri (fn i name -> Hashtbl.set param_tbl name i) type_params;
      let typed_fields = List.map (fn (_is_mut, name, annot) -> let tvars = Hashtbl.create 4 in
      let rec resolve_field =
        fn
          | Ast.TyVar vname -> 
            do
              match Hashtbl.get param_tbl vname with
              | Some idx -> Types.TGen idx
              | None -> 
                do
                  match Hashtbl.get tvars vname with
                  | Some tv -> tv
                  | None -> 
                    let tv = Types.new_tvar 0 in
                    Hashtbl.set tvars vname tv;
                    tv

                end

            end
          | Ast.TyName "int" -> Types.TInt
          | Ast.TyName "float" -> Types.TFloat
          | Ast.TyName "bool" -> Types.TBool
          | Ast.TyName "string" -> Types.TString
          | Ast.TyName "unit" -> Types.TUnit
          | Ast.TyName n -> resolve_ty_annot pre_ctx 0 (Ast.TyName n)
          | Ast.TyArrow ((a, b, _)) -> Types.TArrow (resolve_field a, Types.EffEmpty, resolve_field b)
          | Ast.TyTuple ts -> Types.TTuple (List.map resolve_field ts)
          | Ast.TyList t -> Types.TList (resolve_field t)
          | Ast.TyArray t -> Types.TArray (resolve_field t)
          | Ast.TyMap ((k, v)) -> Types.TMap (resolve_field k, resolve_field v)
          | Ast.TyApp ((args, n)) -> 
            do
              let arg_tys = List.map resolve_field args in
              match List.find (fn (tn, _, _) -> tn = n) pre_ctx.type_env.type_synonyms with
              | Some ((_, np, ty)) -> 
                if (List.length arg_tys) <> np do
                  error ($"type {n} expects {np} arg(s), got {List.length arg_tys}")
                end;
                subst_tgens arg_tys ty
              | None -> 
                do
                  match find_variant_info pre_ctx.type_env n with
                  | Some ((_, np, _, _)) -> 
                    if (List.length arg_tys) <> np do
                      error ($"type {n} expects {np} arg(s), got {List.length arg_tys}")
                    end;
                    let canonical = resolve_type_alias pre_ctx.type_env n in
                    Types.TVariant (canonical, arg_tys)
                  | None -> error ($"unknown type constructor: {n}")

                end

            end
          | Ast.TyRecord ((fs, is_open)) -> 
            let fields = List.sort (fn (a, _) (b, _) -> String.compare a b) (List.map (fn (fn_, ft) -> (fn_, resolve_field ft)) fs) in
            let tail =
              if is_open do
                Types.new_rvar 0
              else
                Types.REmpty in
            Types.TRecord (List.fold_right (fn (n, t) acc -> Types.RRow (n, t, acc)) fields tail)
          | Ast.TyQualified ((path, n)) -> 
            let qualified = (String.concat "." path) ^ ("." ^ n) in
            resolve_field (Ast.TyName qualified)
          | Ast.TyPolyVariant ((_kind, tags)) -> 
            let row = List.fold_right (fn (tag, payload_annot) acc -> Types.PVRow (tag, Option.map resolve_field payload_annot, acc)) tags Types.PVEmpty in
            Types.TPolyVariant row
          | Ast.TyWithEffect ((ty, _)) -> resolve_field ty
       in
      (name, resolve_field annot)) fields in
      let mut_fields = List.filter_map (fn (is_mut, name, _) -> if is_mut do
        Some name
      else
        None) fields in
      let sorted_fields = List.sort (fn (a, _) (b, _) -> String.compare a b) typed_fields in
      let type_env = {ctx.type_env with records = (type_name, sorted_fields) :: ctx.type_env.records; mutable_fields = List.concat mut_fields ctx.type_env.mutable_fields; type_synonyms = (type_name, num_params, Types.TRecord (Types.fields_to_closed_row sorted_fields)) :: ctx.type_env.type_synonyms} in
      {ctx with type_env}
    | Ast.TDAlias annot -> 
      let param_tbl = Hashtbl.create 4 in
      List.iteri (fn i name -> Hashtbl.set param_tbl name i) type_params;
      let tvars = Hashtbl.create 4 in
      let rec resolve_alias =
        fn
          | Ast.TyVar name -> 
            do
              match Hashtbl.get param_tbl name with
              | Some idx -> Types.TGen idx
              | None -> 
                do
                  match Hashtbl.get tvars name with
                  | Some tv -> tv
                  | None -> 
                    let tv = Types.new_tvar 0 in
                    Hashtbl.set tvars name tv;
                    tv

                end

            end
          | Ast.TyName "int" -> Types.TInt
          | Ast.TyName "float" -> Types.TFloat
          | Ast.TyName "bool" -> Types.TBool
          | Ast.TyName "string" -> Types.TString
          | Ast.TyName "unit" -> Types.TUnit
          | Ast.TyName name -> 
            do
              let canonical = resolve_type_alias ctx.type_env name in
              match List.find (fn (n, _, _) -> n = canonical) ctx.type_env.type_synonyms with
              | Some ((_, 0, ty)) -> ty
              | Some ((_, n, _)) -> error ($"type {name} expects {n} type argument(s)")
              | None -> 
                do
                  match find_variant_info ctx.type_env name with
                  | Some ((_, 0, _, _)) -> Types.TVariant (canonical, [])
                  | Some ((_, n, _, _)) -> error ($"type {name} expects {n} type argument(s)")
                  | None -> 
                    if (List.assoc_opt canonical ctx.type_env.records) <> None do
                      let fields = List.assoc canonical ctx.type_env.records in
                      if fields = [] do
                        Types.TRecord Types.RWild
                      else
                        Types.TRecord (Types.fields_to_closed_row fields)
                    else
                      error ($"unknown type: {name}")

                end

            end
          | Ast.TyArrow ((a, b, _)) -> Types.TArrow (resolve_alias a, Types.EffEmpty, resolve_alias b)
          | Ast.TyTuple ts -> Types.TTuple (List.map resolve_alias ts)
          | Ast.TyList t -> Types.TList (resolve_alias t)
          | Ast.TyArray t -> Types.TArray (resolve_alias t)
          | Ast.TyMap ((k, v)) -> Types.TMap (resolve_alias k, resolve_alias v)
          | Ast.TyApp ((args, tname)) -> 
            do
              let canonical = resolve_type_alias ctx.type_env tname in
              let arg_tys = List.map resolve_alias args in
              match List.find (fn (n, _, _) -> n = canonical) ctx.type_env.type_synonyms with
              | Some ((_, np, ty)) -> 
                if (List.length arg_tys) <> np do
                  error ($"type {tname} expects {np} type argument(s), got {List.length arg_tys}")
                end;
                subst_tgens arg_tys ty
              | None -> 
                do
                  match find_variant_info ctx.type_env tname with
                  | Some ((_, np, _, _)) -> 
                    if (List.length arg_tys) <> np do
                      error ($"type {tname} expects {np} type argument(s), got {List.length arg_tys}")
                    end;
                    Types.TVariant (canonical, arg_tys)
                  | None -> error ($"unknown type constructor: {tname}")

                end

            end
          | Ast.TyRecord ((fields, is_open)) -> 
            let fields = List.map (fn (n, t) -> (n, resolve_alias t)) fields in
            let fields = List.sort (fn (a, _) (b, _) -> String.compare a b) fields in
            let tail =
              if is_open do
                Types.new_rvar 0
              else
                Types.REmpty in
            Types.TRecord (List.fold_right (fn (n, t) acc -> Types.RRow (n, t, acc)) fields tail)
          | Ast.TyQualified ((path, name)) -> 
            let qualified = (String.concat "." path) ^ ("." ^ name) in
            resolve_alias (Ast.TyName qualified)
          | Ast.TyPolyVariant ((_kind, tags)) -> 
            let row = List.fold_right (fn (tag, payload_annot) acc -> Types.PVRow (tag, Option.map resolve_alias payload_annot, acc)) tags Types.PVEmpty in
            Types.TPolyVariant row
          | Ast.TyWithEffect ((ty, _)) -> resolve_alias ty
       in
      let resolved_ty = resolve_alias annot in
      let type_env = {ctx.type_env with type_synonyms = (type_name, num_params, resolved_ty) :: ctx.type_env.type_synonyms} in
      {ctx with type_env}


  pub let wrap_params_decl params ret_annot body =
    match ret_annot with
    | Some (Ast.TyWithEffect ((ret_ty, eff_annot))) when params <> [] -> 
      let body = Ast.EAnnot (body, ret_ty) in
      let full_fun = List.fold_right (fn param body -> Ast.EFun (param, body)) params body in
      let rec build_arrow =
        fn
          | [] -> ret_ty
          | p :: [] -> 
            let pty =
              match p.annot with
              | Some t -> t
              | None -> Ast.TyVar ("'_eff_p_" ^ p.name)
             in
            Ast.TyArrow (pty, ret_ty, Some eff_annot)
          | p :: rest -> 
            let pty =
              match p.annot with
              | Some t -> t
              | None -> Ast.TyVar ("'_eff_p_" ^ p.name)
             in
            Ast.TyArrow (pty, build_arrow rest, None)
       in
      Ast.EAnnot (full_fun, build_arrow params)
    | _ -> 
      let body =
        match ret_annot with
        | Some ty -> Ast.EAnnot (body, ty)
        | None -> body
       in
      List.fold_right (fn param body -> Ast.EFun (param, body)) params body


  pub let process_class_def ctx (class_name : string) (tyvar_names : string list) (fundep_annots : (string list * string list) list) (methods : (string * Ast.ty_annot) list) : ctx * tdecl =
    if List.exists (fn c -> c.class_name = class_name) ctx.type_env.classes do
      error ($"duplicate class definition: {class_name}")
    end;
    let num_class_params = List.length tyvar_names in
    let method_tys = List.map (fn (mname, annot) -> let tvars = Hashtbl.create 4 in
    List.iteri (fn i name -> Hashtbl.set tvars name (Types.TGen i)) tyvar_names;
    let next_gen = Ref.create num_class_params in
    let eff_tvars = Hashtbl.create 2 in
    let next_effgen = Ref.create 0 in
    let resolve_eff_var name =
      match Hashtbl.get eff_tvars name with
      | Some eg -> eg
      | None -> 
        let idx = Ref.get next_effgen in
        Ref.set next_effgen (idx + 1);
        let eg = Types.EffGen idx in
        Hashtbl.set eff_tvars name eg;
        eg
     in
    let rec resolve =
      fn
        | Ast.TyVar name -> 
          do
            match Hashtbl.get tvars name with
            | Some tv -> tv
            | None -> 
              let idx = Ref.get next_gen in
              Ref.set next_gen (idx + 1);
              Hashtbl.set tvars name (Types.TGen idx);
              Types.TGen idx

          end
        | Ast.TyName "int" -> Types.TInt
        | Ast.TyName "float" -> Types.TFloat
        | Ast.TyName "bool" -> Types.TBool
        | Ast.TyName "string" -> Types.TString
        | Ast.TyName "unit" -> Types.TUnit
        | Ast.TyName name -> 
          do
            let canonical = resolve_type_alias ctx.type_env name in
            match find_variant_info ctx.type_env name with
            | Some ((_, 0, _, _)) -> Types.TVariant (canonical, [])
            | Some ((_, n, _, _)) -> error ($"type {name} expects {n} type argument(s)")
            | None -> error ($"unknown type: {name}")

          end
        | Ast.TyArrow ((a, b, eff_opt)) -> 
          let eff =
            match eff_opt with
            | None -> Types.EffEmpty
            | Some Ast.EffAnnotPure -> Types.EffEmpty
            | Some (Ast.EffAnnotRow items) -> resolve_class_eff_items items
           in
          Types.TArrow (resolve a, eff, resolve b)
        | Ast.TyTuple ts -> Types.TTuple (List.map resolve ts)
        | Ast.TyList t -> Types.TList (resolve t)
        | Ast.TyArray t -> Types.TArray (resolve t)
        | Ast.TyMap ((k, v)) -> Types.TMap (resolve k, resolve v)
        | Ast.TyApp ((args, name)) -> 
          do
            let canonical = resolve_type_alias ctx.type_env name in
            let arg_tys = List.map resolve args in
            match find_variant_info ctx.type_env name with
            | Some ((_, np, _, _)) -> 
              if (List.length arg_tys) <> np do
                error ($"type {name} expects {np} type argument(s), got {List.length arg_tys}")
              end;
              Types.TVariant (canonical, arg_tys)
            | None -> error ($"unknown type constructor: {name}")

          end
        | Ast.TyRecord ((fields, is_open)) -> 
          let fields = List.sort (fn (a, _) (b, _) -> String.compare a b) (List.map (fn (n, t) -> (n, resolve t)) fields) in
          let tail =
            if is_open do
              Types.new_rvar 0
            else
              Types.REmpty in
          Types.TRecord (List.fold_right (fn (n, t) acc -> Types.RRow (n, t, acc)) fields tail)
        | Ast.TyQualified ((path, name)) -> 
          let qualified = (String.concat "." path) ^ ("." ^ name) in
          resolve (Ast.TyName qualified)
        | Ast.TyPolyVariant ((_kind, tags)) -> 
          let row = List.fold_right (fn (tag, payload_annot) acc -> Types.PVRow (tag, Option.map resolve payload_annot, acc)) tags Types.PVEmpty in
          Types.TPolyVariant row
        | Ast.TyWithEffect ((ty, _)) -> resolve ty

    and resolve_class_eff_items items =
      let labels = Ref.create [] in
      let tail = Ref.create Types.EffEmpty in
      List.iter (fn item ->
        do
          match item with
          | Ast.EffLabel ((name, param_annots)) -> 
            let resolved_params = List.map resolve param_annots in
            Ref.set labels ((name, resolved_params) :: Ref.get labels)
          | Ast.EffVar name -> Ref.set tail (resolve_eff_var name)

        end) items;
      List.fold_right (fn (name, params) acc -> Types.EffRow (name, params, acc)) (List.rev (Ref.get labels)) (Ref.get tail) in
    let ty = resolve annot in
    let method_quant = Ref.get next_gen in
    let method_equant = Ref.get next_effgen in
    (mname, ty, method_quant, method_equant)) methods in
    let class_fundeps = List.map (fn (from_names, to_names) -> let resolve_idx name =
      match List.find_index (fn n -> n = name) tyvar_names with
      | Some i -> i
      | None -> error ($"functional dependency type variable '{name} not in class parameters")
     in
    {fd_from = List.map resolve_idx from_names; fd_to = List.map resolve_idx to_names}) fundep_annots in
    let class_def = {class_name; class_params = tyvar_names; class_methods = List.map (fn (m, t, _, _) -> (m, t)) method_tys; class_fundeps} in
    let ctx = List.fold (fn ctx (mname, mty, mquant, mequant) -> let scheme = {quant = mquant; equant = mequant; pvquant = 0; rquant = 0; constraints = []; record_evidences = []; body = mty} in
    extend_var ctx mname scheme) ctx method_tys in
    let type_env = {ctx.type_env with classes = class_def :: ctx.type_env.classes} in
    let ctx = {ctx with type_env} in
    (ctx, TDClass class_name)

  pub let resolve_inst_tys ctx (annots : Ast.ty_annot list) =
    let tvars = Hashtbl.create 4 in
    let next_idx = Ref.create 0 in
    let rec go =
      fn
        | Ast.TyVar name -> 
          do
            match Hashtbl.get tvars name with
            | Some idx -> Types.TGen idx
            | None -> 
              let idx = Ref.get next_idx in
              Ref.set next_idx (idx + 1);
              Hashtbl.set tvars name idx;
              Types.TGen idx

          end
        | Ast.TyName "int" -> Types.TInt
        | Ast.TyName "float" -> Types.TFloat
        | Ast.TyName "bool" -> Types.TBool
        | Ast.TyName "string" -> Types.TString
        | Ast.TyName "byte" -> Types.TByte
        | Ast.TyName "rune" -> Types.TRune
        | Ast.TyName "unit" -> Types.TUnit
        | Ast.TyName name -> 
          do
            let canonical = resolve_type_alias ctx.type_env name in
            match find_variant_info ctx.type_env name with
            | Some ((_, 0, _, _)) -> Types.TVariant (canonical, [])
            | Some ((_, n, _, _)) -> error ($"type {name} expects {n} type argument(s)")
            | None -> 
              if (List.assoc_opt name ctx.type_env.records) <> None do
                let fields = List.assoc name ctx.type_env.records in
                if fields = [] do
                  Types.TRecord Types.RWild
                else
                  Types.TRecord (Types.fields_to_closed_row fields)
              else
                error ($"unknown type: {name}")

          end
        | Ast.TyArrow ((a, b, _)) -> Types.TArrow (go a, Types.EffEmpty, go b)
        | Ast.TyTuple ts -> Types.TTuple (List.map go ts)
        | Ast.TyList t -> Types.TList (go t)
        | Ast.TyArray t -> Types.TArray (go t)
        | Ast.TyMap ((k, v)) -> Types.TMap (go k, go v)
        | Ast.TyApp ((args, name)) -> 
          do
            let canonical = resolve_type_alias ctx.type_env name in
            let arg_tys = List.map go args in
            match find_variant_info ctx.type_env name with
            | Some ((_, np, _, _)) -> 
              if (List.length arg_tys) <> np do
                error ($"type {name} expects {np} type argument(s), got {List.length arg_tys}")
              end;
              Types.TVariant (canonical, arg_tys)
            | None -> error ($"unknown type constructor: {name}")

          end
        | Ast.TyRecord ((fields, is_open)) -> 
          let fields = List.map (fn (n, t) -> (n, go t)) fields in
          let fields = List.sort (fn (a, _) (b, _) -> String.compare a b) fields in
          let tail =
            if is_open do
              Types.new_rvar 0
            else
              Types.REmpty in
          Types.TRecord (List.fold_right (fn (n, t) acc -> Types.RRow (n, t, acc)) fields tail)
        | Ast.TyQualified ((path, name)) -> 
          let qualified = (String.concat "." path) ^ ("." ^ name) in
          go (Ast.TyName qualified)
        | Ast.TyPolyVariant ((_kind, tags)) -> 
          let row = List.fold_right (fn (tag, payload_annot) acc -> Types.PVRow (tag, Option.map go payload_annot, acc)) tags Types.PVEmpty in
          Types.TPolyVariant row
        | Ast.TyWithEffect ((ty, _)) -> go ty
     in
    let tys = List.map go annots in
    (tys, Ref.get next_idx, tvars)

  pub let process_instance_def ctx level (class_name : string) (inst_ty_annots : Ast.ty_annot list) (constraints : Ast.constraint_ list) (methods : (string * Ast.param list * Ast.expr) list) : ctx * tdecl =
    let class_name = resolve_type_alias ctx.type_env class_name in
    let class_def =
      match List.find (fn c -> c.class_name = class_name) ctx.type_env.classes with
      | Some c -> c
      | None -> error ($"unknown class: {class_name}")
     in
    let num_class_params = List.length class_def.class_params in
    let (stored_tys, num_inst_vars, inst_tvars) = resolve_inst_tys ctx inst_ty_annots in
    if (List.length stored_tys) <> num_class_params do
      error ($"class {class_name} expects {num_class_params} type parameters, got {List.length stored_tys}")
    end;
    let dname = Types.dict_name class_name stored_tys in
    let check_tvar_list = List.init num_inst_vars (fn _ -> Types.new_tvar (level + 1)) in
    let check_tys = List.map (fn t -> subst_tgens check_tvar_list t) stored_tys in
    if List.exists (fn i -> (i.inst_class = class_name) && (((List.length i.inst_tys) = (List.length stored_tys)) && (Types.match_partial_inst i.inst_tys (List.map (fn t -> Some t) stored_tys)))) ctx.type_env.instances do
      error ($"duplicate instance {class_name} for types {String.concat ", " (List.map Types.pp_ty stored_tys)}")
    end;
    List.iter (fn (mname, _) -> if not (List.exists (fn (n, _, _) -> n = mname) methods) do
      error ($"instance {class_name} {String.concat " " (List.map Types.pp_ty stored_tys)} missing method: {mname}")
    end) class_def.class_methods;
    let typed_methods = List.map (fn (mname, params, body) -> let method_schema_ty =
      match List.assoc_opt mname class_def.class_methods with
      | Some ty -> ty
      | None -> error ($"{mname} is not a method of class {class_name}")
     in
    let concrete_method_ty = subst_tgens check_tys method_schema_ty in
    let max_tgen = max_tgen_in_ty concrete_method_ty in
    let max_effgen = max_effgen_in_ty concrete_method_ty in
    let quant =
      if max_tgen >= 0 do
        max_tgen + 1
      else
        0 in
    let equant =
      if max_effgen >= 0 do
        max_effgen + 1
      else
        0 in
    let concrete_method_ty =
      if (quant > 0) || (equant > 0) do
        Types.instantiate (level + 1) {quant; equant; pvquant = 0; rquant = 0; constraints = []; record_evidences = []; body = concrete_method_ty}
      else
        concrete_method_ty in
    let full_body = wrap_params_decl params None body in
    let te = check ctx (level + 1) full_body concrete_method_ty in
    (mname, te)) methods in
    let sorted_methods = List.sort (fn (a, _) (b, _) -> String.compare a b) typed_methods in
    let record_ty = Types.TRecord (Types.fields_to_closed_row (List.map (fn (n, te) -> (n, te.ty)) sorted_methods)) in
    let dict_expr = mk (TERecord sorted_methods) record_ty in
    let inst_constraints = List.map (fn (cclass, tyvar_names) -> let cclass = resolve_type_alias ctx.type_env cclass in
    let cc_args = List.map (fn tvname ->
      do
        match Hashtbl.get inst_tvars tvname with
        | Some idx -> Types.CATGen idx
        | None -> error ($"constraint type variable '{tvname} not found in instance type parameters")

      end) tyvar_names in
    {cc_class = cclass; cc_args}) constraints in
    let inst_def = {inst_class = class_name; inst_tys = stored_tys; inst_dict_name = dname; inst_constraints} in
    do
      do try
        Types.check_fundep_consistency class_def inst_def ctx.type_env.instances
      with
      | unify_error msg -> error msg
      end
    end;
    let type_env = {ctx.type_env with instances = inst_def :: ctx.type_env.instances} in
    let ctx = {ctx with type_env} in
    (ctx, TDLet (dname, dict_expr))

  pub let extract_tyvar_ids annot ty =
    let (mapping : (string, int) Hashtbl.t) = Hashtbl.create 4 in
    let rec walk annot ty =
      match (annot, Types.repr ty) with
      | (Ast.TyVar name, Types.TVar {contents = Types.Unbound ((id, _))}) -> 
        if not (Hashtbl.has mapping name) do
          Hashtbl.set mapping name id
        end
      | (Ast.TyArrow ((a1, a2, _)), Types.TArrow ((t1, _, t2)) | Types.TCont ((t1, _, t2))) -> 
        walk a1 t1;
        walk a2 t2
      | (Ast.TyTuple anns, Types.TTuple tys) when (List.length anns) = (List.length tys) -> List.iter2 walk anns tys
      | (Ast.TyList a, Types.TList t) -> walk a t
      | (Ast.TyArray a, Types.TArray t) -> walk a t
      | (Ast.TyMap ((k1, v1)), Types.TMap ((k2, v2))) -> 
        walk k1 k2;
        walk v1 v2
      | (Ast.TyApp ((args, _)), Types.TVariant ((_, tys))) when (List.length args) = (List.length tys) -> List.iter2 walk args tys
      | (Ast.TyWithEffect ((a, _)), _) -> walk a ty
      | _ -> ()
     in
    walk annot ty;
    mapping

  pub let resolve_let_constraints type_env level constraints params ret_annot te_ty shared_tvars =
    if constraints = [] do
      Types.generalize level te_ty
    else do
      let (name_to_tvar : (string, int) Hashtbl.t) = Hashtbl.create 4 in
      let merge_into tbl = Hashtbl.iter (fn k v -> if not (Hashtbl.has name_to_tvar k) do
        Hashtbl.set name_to_tvar k v
      end) tbl in
      let rec walk_params params ty =
        match (params, Types.repr ty) with
        | (p :: rest, Types.TArrow ((param_ty, _, ret_ty)) | Types.TCont ((param_ty, _, ret_ty))) -> 
          do
            match p.annot with
            | Some annot -> merge_into (extract_tyvar_ids annot param_ty)
            | None -> ()

          end;
          walk_params rest ret_ty
        | _ -> ()
       in
      walk_params params te_ty;
      do
        match ret_annot with
        | Some annot -> 
          let rec skip_arrows ty n =
            if n = 0 do
              ty
            else
              match Types.repr ty with
              | Types.TArrow ((_, _, rest)) | Types.TCont ((_, _, rest)) -> skip_arrows rest (n - 1)
              | _ -> ty
           in
          let ret_ty = skip_arrows te_ty (List.length params) in
          merge_into (extract_tyvar_ids annot ret_ty)
        | None -> ()

      end;
      let (scheme, id_map) = Types.generalize_with_map level te_ty in
      let phantom_counter = Ref.create scheme.quant in
      let phantom_map = Hashtbl.create 4 in
      let cc_list = List.map (fn (cclass, tyvar_names) -> let cclass = resolve_type_alias type_env cclass in
      let cc_args = List.map (fn tvname ->
        do
          match Hashtbl.get name_to_tvar tvname with
          | Some tvar_id -> 
            do
              match Hashtbl.get id_map tvar_id with
              | Some (Types.TGen idx) -> Types.CATGen idx
              | _ -> error ($"constraint type variable '{tvname} is not polymorphic")

            end
          | None -> 
            do
              match Hashtbl.get shared_tvars tvname with
              | Some tv -> 
                do
                  let tv_id =
                    match Types.repr tv with
                    | Types.TVar {contents = Types.Unbound ((id, _))} -> Some id
                    | _ -> None
                   in
                  let tgen_from_map =
                    match tv_id with
                    | Some id -> Hashtbl.get id_map id
                    | None -> None
                   in
                  match tgen_from_map with
                  | Some (Types.TGen idx) -> Types.CATGen idx
                  | _ -> 
                    let idx =
                      match Hashtbl.get phantom_map tvname with
                      | Some idx -> idx
                      | None -> 
                        let idx = Ref.get phantom_counter in
                        Ref.set phantom_counter (Ref.get phantom_counter + 1);
                        Hashtbl.set phantom_map tvname idx;
                        idx
                     in
                    Types.CAPhantom (idx, tv)

                end
              | None -> error ($"constraint type variable '{tvname} not found in function signature")

            end

        end) tyvar_names in
      {cc_class = cclass; cc_args}) constraints in
      {scheme with constraints = cc_list}
    end

  pub let unify_constraint_tvars type_env constraints shared_tvars body_te =
    let classes = type_env.classes in
    let rec walk te =
      match te.expr with
      | TEVar name -> 
        do
          let class_opt =
            match Types.find_method_class classes name with
            | Some _ as r -> r
            | None -> 
              do
                match String.rindex_opt name #2e with
                | None -> None
                | Some i -> 
                  let short = String.sub name (i + 1) (((String.length name) - i) - 1) in
                  Types.find_method_class classes short

              end
           in
          match class_opt with
          | Some class_def -> 
            do
              let method_name =
                match String.rindex_opt name #2e with
                | Some i -> String.sub name (i + 1) (((String.length name) - i) - 1)
                | None -> name
               in
              match List.assoc_opt method_name class_def.class_methods with
              | Some method_schema_ty -> 
                let num_params = List.length class_def.class_params in
                let param_map = Hashtbl.create num_params in
                let rec go s r =
                  let r = Types.repr r in
                  match (s, r) with
                  | (Types.TGen i, _) when i < num_params -> 
                    if not (Hashtbl.has param_map i) do
                      Hashtbl.set param_map i r
                    end
                  | (Types.TArrow ((s1, _, s2)), Types.TArrow ((r1, _, r2))) | (Types.TCont ((s1, _, s2)), Types.TCont ((r1, _, r2))) -> 
                    go s1 r1;
                    go s2 r2
                  | (Types.TTuple ss, Types.TTuple rs) when (List.length ss) = (List.length rs) -> List.iter2 go ss rs
                  | (Types.TList s1, Types.TList r1) -> go s1 r1
                  | (Types.TArray s1, Types.TArray r1) -> go s1 r1
                  | (Types.TMap ((sk, sv)), Types.TMap ((rk, rv))) -> 
                    go sk rk;
                    go sv rv
                  | (Types.TVariant ((_, ss)), Types.TVariant ((_, rs))) when (List.length ss) = (List.length rs) -> List.iter2 go ss rs
                  | _ -> ()
                 in
                go method_schema_ty te.ty;
                List.iter (fn (cclass, tyvar_names) -> if (cclass = class_def.class_name) && ((List.length tyvar_names) = num_params) do
                  let from_match = List.forall (fn (fd : Types.fundep) -> List.forall (fn fi ->
                    do
                      match Hashtbl.get param_map fi with
                      | Some body_tv -> 
                        do
                          let tvname = List.nth tyvar_names fi in
                          match Hashtbl.get shared_tvars tvname with
                          | Some constraint_tv -> (Types.repr body_tv) = (Types.repr constraint_tv)
                          | None -> true

                        end
                      | None -> true

                    end) fd.fd_from) class_def.class_fundeps in
                  if from_match do
                    List.iter (fn (fd : Types.fundep) -> List.iter (fn ti ->
                      do
                        match Hashtbl.get param_map ti with
                        | Some body_tv -> 
                          do
                            let tvname = List.nth tyvar_names ti in
                            match Hashtbl.get shared_tvars tvname with
                            | Some constraint_tv -> (* try/catch-all *) Types.unify body_tv constraint_tv
                            | None -> ()

                          end
                        | None -> ()

                      end) fd.fd_to) class_def.class_fundeps
                  end
                end) constraints
              | None -> ()

            end
          | None -> ()

        end
      | TEApp ((f, x)) -> 
        walk f;
        walk x
      | TEFun ((_, body, _)) -> walk body
      | TELet ((_, _, e1, e2)) -> 
        walk e1;
        walk e2
      | TELetRec ((_, _, e1, e2)) -> 
        walk e1;
        walk e2
      | TEIf ((c, t, e)) -> 
        walk c;
        walk t;
        walk e
      | TEBinop ((_, a, b)) -> 
        walk a;
        walk b
      | TEUnop ((_, a)) -> walk a
      | TETuple es -> List.iter walk es
      | TERecord fields -> List.iter (fn (_, e) -> walk e) fields
      | TERecordUpdate ((e, fields)) -> 
        walk e;
        List.iter (fn (_, e) -> walk e) fields
      | TERecordUpdateIdx ((e, pairs)) -> 
        walk e;
        List.iter (fn (i, v) -> walk i;
        walk v) pairs
      | TEField ((e, _)) -> walk e
      | TEIndex ((e1, e2)) -> 
        walk e1;
        walk e2
      | TECons ((hd, tl)) -> 
        walk hd;
        walk tl
      | TEMatch ((scrut, branches, _)) -> 
        walk scrut;
        List.iter (fn (_, guard, body) -> do
          match guard with
          | Some g -> walk g
          | None -> ()

        end;
        walk body) branches
      | TESeq ((e1, e2)) -> 
        walk e1;
        walk e2
      | TELetMut ((_, e1, e2)) -> 
        walk e1;
        walk e2
      | TEAssign ((_, e)) -> walk e
      | TEFieldAssign ((e1, _, e2)) -> 
        walk e1;
        walk e2
      | TEConstruct ((_, Some e)) -> walk e
      | TEPerform ((_, e)) -> walk e
      | TEHandle ((body, _)) -> walk body
      | TEResume ((e1, e2)) -> 
        walk e1;
        walk e2
      | TEWhile ((cond, body)) -> 
        walk cond;
        walk body
      | TEForLoop body -> walk body
      | TEMap kvs -> List.iter (fn (k, v) -> walk k;
      walk v) kvs
      | TEArray es -> List.iter walk es
      | TEReturn e -> walk e
      | TEBreak e -> walk e
      | TEFoldContinue e -> walk e
      | TELetRecAnd ((bindings, body)) -> 
        List.iter (fn (_, e) -> walk e) bindings;
        walk body
      | _ -> ()
     in
    walk body_te

  pub let synth_constrained_fn ctx level constraints params ret_annot body =
    let shared_tvars = Hashtbl.create 4 in
    let constraint_tyvar_names = (List.flatten (List.map (fn (_, names) -> names) constraints)) |> (List.sort_uniq String.compare) in
    List.iter (fn tvname -> Hashtbl.set shared_tvars tvname (Types.new_tvar (level + 1))) constraint_tyvar_names;
    let constraint_tvar_ids = List.filter_map (fn tvname ->
      do
        match Types.repr (Hashtbl.find shared_tvars tvname) with
        | Types.TVar {contents = Types.Unbound ((id, _))} -> Some id
        | _ -> None

      end) constraint_tyvar_names in
    let param_tys = List.map (fn p ->
      do
        match p.annot with
        | Some annot -> resolve_ty_annot_shared ctx (level + 1) shared_tvars annot
        | None -> Types.new_tvar (level + 1)

      end) params in
    let ret_ty_opt =
      match ret_annot with
      | Some annot -> Some (resolve_ty_annot_shared ctx (level + 1) shared_tvars annot)
      | None -> None
     in
    let body_eff = Types.new_effvar (level + 1) in
    let inner_ctx = List.fold2 (fn c p ty -> extend_var_mono c p.name ty) {ctx with constraint_tvars = List.concat constraint_tvar_ids ctx.constraint_tvars; current_eff = body_eff} params param_tys in
    let body_te =
      match ret_ty_opt with
      | Some ret_ty -> check inner_ctx (level + 1) body ret_ty
      | None -> synth inner_ctx (level + 1) body
     in
    unify_constraint_tvars ctx.type_env constraints shared_tvars body_te;
    let te =
      match (List.rev params, List.rev param_tys) with
      | ([], []) -> body_te
      | (last_p :: rest_ps, last_pty :: rest_ptys) -> 
        let inner = mk (TEFun (last_p.name, body_te, false)) (Types.TArrow (last_pty, body_eff, body_te.ty)) in
        List.fold2 (fn acc p pty -> mk (TEFun (p.name, acc, false)) (Types.TArrow (pty, Types.EffEmpty, acc.ty))) inner rest_ps rest_ptys
      | _ -> failwith "assert false"
     in
    let scheme = resolve_let_constraints ctx.type_env level constraints params ret_annot te.ty shared_tvars in
    (te, scheme)

  pub let find_module_in_env type_env mod_name =
    match String.split "." mod_name with
    | [] -> None
    | name :: [] -> List.assoc_opt name type_env.modules
    | first :: rest -> 
      do
        match List.assoc_opt first type_env.modules with
        | None -> None
        | Some minfo -> 
          let rec drill mi =
            fn
              | [] -> Some mi
              | seg :: rest -> 
                do
                  match List.assoc_opt seg mi.mod_submodules with
                  | None -> None
                  | Some sub -> drill sub rest

                end
           in
          drill minfo rest

      end


  pub let open_module_into_ctx ctx mod_name names_opt =
    match find_module_in_env ctx.type_env mod_name with
    | None -> error ($"unknown module: {mod_name}")
    | Some minfo -> 
      let filter name =
        match names_opt with
        | None -> true
        | Some names -> List.mem name names
       in
      let ctx = List.fold (fn ctx (short, scheme) -> if filter short do
        if List.mem short minfo.mod_pub_mutable_vars do
          extend_var_mutable ctx short scheme
        else
          extend_var ctx short scheme
      else
        ctx) ctx minfo.mod_pub_vars in
      let type_env = List.fold (fn te (short, info) -> if filter short do
        {te with constructors = (short, info) :: te.constructors}
      else
        te) ctx.type_env minfo.mod_pub_constructors in
      let type_env = List.fold (fn te qname -> let short =
        match String.rindex_opt qname #2e with
        | Some i -> String.sub qname (i + 1) (((String.length qname) - i) - 1)
        | None -> qname
       in
      if filter short do
        let te =
          match List.find (fn (n, _, _, _) -> n = qname) te.variants with
          | Some ((_, np, vdef, is_gadt)) -> 
            if List.exists (fn (n, _, _, _) -> n = short) te.variants do
              te
            else
              {te with variants = (short, np, vdef, is_gadt) :: te.variants}
          | None -> te
         in
        let te =
          match List.assoc_opt qname te.records with
          | Some fields -> 
            if (List.assoc_opt short te.records) <> None do
              te
            else
              {te with records = (short, fields) :: te.records}
          | None -> te
         in
        let te =
          match List.find (fn (n, _, _) -> n = qname) te.type_synonyms with
          | Some ((_, np, expanded)) -> 
            if List.exists (fn (n, _, _) -> n = short) te.type_synonyms do
              te
            else
              {te with type_synonyms = (short, np, expanded) :: te.type_synonyms}
          | None -> te
         in
        let te =
          if short = qname do
            te
          else
            {te with type_aliases = (short, qname) :: te.type_aliases} in
        te
      else
        te) type_env minfo.mod_pub_types in
      let type_env = List.fold (fn te (sub_name, sub_info) -> if filter sub_name do
        {te with modules = (sub_name, sub_info) :: te.modules}
      else
        te) type_env minfo.mod_submodules in
      let type_env = List.fold (fn te qname -> let short =
        match String.rindex_opt qname #2e with
        | Some i -> String.sub qname (i + 1) (((String.length qname) - i) - 1)
        | None -> qname
       in
      if filter short do
        {te with type_aliases = (short, qname) :: te.type_aliases}
      else
        te) type_env minfo.mod_pub_classes in
      {ctx with type_env}


  pub let () = Ref.set find_module_in_env_ref find_module_in_env

  pub let () = Ref.set open_module_into_ctx_ref open_module_into_ctx

  pub let rec collect_tyvars_annot =
    fn
      | Ast.TyVar s -> s :: []
      | Ast.TyArrow ((a, b, _)) -> List.concat (collect_tyvars_annot a) (collect_tyvars_annot b)
      | Ast.TyTuple ts -> List.concat_map collect_tyvars_annot ts
      | Ast.TyList t | Ast.TyArray t -> collect_tyvars_annot t
      | Ast.TyApp ((args, _)) -> List.concat_map collect_tyvars_annot args
      | Ast.TyMap ((k, v)) -> List.concat (collect_tyvars_annot k) (collect_tyvars_annot v)
      | Ast.TyRecord ((fs, _)) -> List.concat_map (fn (_, t) -> collect_tyvars_annot t) fs
      | Ast.TyName _ | Ast.TyQualified _ -> []
      | Ast.TyPolyVariant ((_, tags)) -> List.concat_map (fn (_, ty_opt) ->
        do
          match ty_opt with
          | Some t -> collect_tyvars_annot t
          | None -> []

        end) tags
      | Ast.TyWithEffect ((ty, _)) -> collect_tyvars_annot ty


  pub let concat_str_exprs =
    fn
      | [] -> Ast.EString ""
      | e :: [] -> e
      | first :: rest -> List.fold (fn acc e -> Ast.EBinop (Ast.Concat, acc, e)) first rest


  pub let make_inst_ty type_params name =
    if type_params = [] do
      Ast.TyName name
    else
      Ast.TyApp (List.map (fn p -> Ast.TyVar p) type_params, name)

  pub let make_constraints class_name type_params annots =
    let all_vars = List.concat_map (fn ann -> collect_tyvars_annot ann) annots in
    let unique_vars = List.sort_uniq String.compare all_vars in
    let param_vars = List.filter (fn v -> List.mem v type_params) unique_vars in
    List.map (fn v -> (class_name, v :: [])) param_vars

  pub let gen_show_variant type_params name ctors =
    let inst_ty = make_inst_ty type_params name in
    let annots = List.filter_map (fn (_, a, _) -> a) ctors in
    let constraints = make_constraints "Show" type_params annots in
    let arms = List.map (fn (ctor_name, arg_annot, _) ->
      do
        match arg_annot with
        | None -> (Ast.PatConstruct (ctor_name, None), None, Ast.EString ctor_name)
        | Some (Ast.TyTuple tys) -> 
          let n = List.length tys in
          let vars = List.init n (fn i -> $"__v{i}") in
          let pat = Ast.PatConstruct (ctor_name, Some (Ast.PatTuple (List.map (fn v -> Ast.PatVar v) vars))) in
          let parts = List.concat (Ast.EString (ctor_name ^ "(") :: []) (List.concat (List.flatten (List.mapi (fn i v -> let sv = Ast.EApp (Ast.EVar "show", Ast.EVar v) in
          if i = 0 do
            sv :: []
          else
            Ast.EString ", " :: sv :: []) vars)) (Ast.EString ")" :: [])) in
          (pat, None, concat_str_exprs parts)
        | Some _ -> 
          let pat = Ast.PatConstruct (ctor_name, Some (Ast.PatVar "__v0")) in
          let body = concat_str_exprs (Ast.EString (ctor_name ^ "(") :: Ast.EApp (Ast.EVar "show", Ast.EVar "__v0") :: Ast.EString ")" :: []) in
          (pat, None, body)

      end) ctors in
    let body = Ast.EMatch (Ast.EVar "__x", arms, false) in
    ("Show", inst_ty :: [], constraints, ("show", {name = "__x"; annot = None; is_generated = false} :: [], body) :: [])

  pub let gen_show_record type_params name fields =
    let inst_ty = make_inst_ty type_params name in
    let annots = List.map (fn (_, _, a) -> a) fields in
    let constraints = make_constraints "Show" type_params annots in
    let parts = List.concat (Ast.EString "{ " :: []) (List.concat (List.flatten (List.mapi (fn i (_, fname, _) -> let sf = Ast.EApp (Ast.EVar "show", Ast.EField (Ast.EVar "__x", fname)) in
    if i = 0 do
      Ast.EString (fname ^ " = ") :: sf :: []
    else
      Ast.EString ("; " ^ (fname ^ " = ")) :: sf :: []) fields)) (Ast.EString " }" :: [])) in
    let body = concat_str_exprs parts in
    ("Show", inst_ty :: [], constraints, ("show", {name = "__x"; annot = None; is_generated = false} :: [], body) :: [])

  pub let gen_eq_variant type_params name ctors =
    let inst_ty = make_inst_ty type_params name in
    let annots = List.filter_map (fn (_, a, _) -> a) ctors in
    let constraints = make_constraints "Eq" type_params annots in
    let and_exprs =
      fn
        | [] -> Ast.EBool true
        | e :: [] -> e
        | first :: rest -> List.fold (fn a e -> Ast.EBinop (Ast.And, a, e)) first rest
     in
    let arms = List.map (fn (ctor_name, arg_annot, _) ->
      do
        match arg_annot with
        | None -> 
          let pat = Ast.PatTuple (Ast.PatConstruct (ctor_name, None) :: Ast.PatConstruct (ctor_name, None) :: []) in
          (pat, None, Ast.EBool true)
        | Some (Ast.TyTuple tys) -> 
          let n = List.length tys in
          let vs = List.init n (fn i -> $"__v{i}") in
          let ws = List.init n (fn i -> $"__w{i}") in
          let lp = Ast.PatConstruct (ctor_name, Some (Ast.PatTuple (List.map (fn v -> Ast.PatVar v) vs))) in
          let rp = Ast.PatConstruct (ctor_name, Some (Ast.PatTuple (List.map (fn v -> Ast.PatVar v) ws))) in
          let eqs = List.map2 (fn v w -> Ast.EBinop (Ast.Eq, Ast.EVar v, Ast.EVar w)) vs ws in
          (Ast.PatTuple (lp :: rp :: []), None, and_exprs eqs)
        | Some _ -> 
          let lp = Ast.PatConstruct (ctor_name, Some (Ast.PatVar "__v0")) in
          let rp = Ast.PatConstruct (ctor_name, Some (Ast.PatVar "__w0")) in
          (Ast.PatTuple (lp :: rp :: []), None, Ast.EBinop (Ast.Eq, Ast.EVar "__v0", Ast.EVar "__w0"))

      end) ctors in
    let arms = List.concat arms ((Ast.PatWild, None, Ast.EBool false) :: []) in
    let eq_body = Ast.EMatch (Ast.ETuple (Ast.EVar "__a" :: Ast.EVar "__b" :: []), arms, false) in
    let neq_body = Ast.EUnop (Ast.Not, Ast.EMatch (Ast.ETuple (Ast.EVar "__a" :: Ast.EVar "__b" :: []), List.map (fn (p, g, e) -> (p, g, e)) arms, false)) in
    ("Eq", inst_ty :: [], constraints, ("=", {name = "__a"; annot = None; is_generated = false} :: {name = "__b"; annot = None; is_generated = false} :: [], eq_body) :: ("<>", {name = "__a"; annot = None; is_generated = false} :: {name = "__b"; annot = None; is_generated = false} :: [], neq_body) :: [])

  pub let gen_eq_record type_params name fields =
    let inst_ty = make_inst_ty type_params name in
    let annots = List.map (fn (_, _, a) -> a) fields in
    let constraints = make_constraints "Eq" type_params annots in
    let eqs = List.map (fn (_, fname, _) -> Ast.EBinop (Ast.Eq, Ast.EField (Ast.EVar "__a", fname), Ast.EField (Ast.EVar "__b", fname))) fields in
    let eq_body =
      match eqs with
      | [] -> Ast.EBool true
      | e :: [] -> e
      | first :: rest -> List.fold (fn a e -> Ast.EBinop (Ast.And, a, e)) first rest
     in
    let neq_body = Ast.EUnop (Ast.Not, eq_body) in
    ("Eq", inst_ty :: [], constraints, ("=", {name = "__a"; annot = None; is_generated = false} :: {name = "__b"; annot = None; is_generated = false} :: [], eq_body) :: ("<>", {name = "__a"; annot = None; is_generated = false} :: {name = "__b"; annot = None; is_generated = false} :: [], neq_body) :: [])

  pub let generate_derived_instance type_params name def class_name =
    match (class_name, def) with
    | (_, Ast.TDVariant ctors) when List.exists (fn (_, _, ret) -> ret <> None) ctors -> error ($"cannot derive {class_name} for GADT type {name}")
    | ("Show", Ast.TDVariant ctors) -> Some (gen_show_variant type_params name ctors)
    | ("Show", Ast.TDRecord fields) -> Some (gen_show_record type_params name fields)
    | ("Eq", Ast.TDVariant ctors) -> Some (gen_eq_variant type_params name ctors)
    | ("Eq", Ast.TDRecord fields) -> Some (gen_eq_record type_params name fields)
    | _ -> None


  pub let rec process_module_def ctx level mod_name (items : Ast.module_decl list) =
    let prefix =
      match ctx.current_module with
      | None -> mod_name ^ "."
      | Some parent -> parent ^ (mod_name ^ ".")
     in
    let sub_ctx = {ctx with current_module = Some prefix} in
    let pub_vars = Ref.create [] in
    let pub_mutable_vars = Ref.create [] in
    let pub_types = Ref.create [] in
    let opaque_types = Ref.create [] in
    let pub_constructors = Ref.create [] in
    let all_instances = Ref.create [] in
    let submodules = Ref.create [] in
    let pub_classes = Ref.create [] in
    let typed_decls = Ref.create [] in
    let sub_ctx = List.fold (fn sub_ctx (item : Ast.module_decl) -> let (sub_ctx', tdecl) = check_module_item sub_ctx level prefix item pub_vars pub_mutable_vars pub_types opaque_types pub_constructors all_instances submodules pub_classes typed_decls in
    Ref.set typed_decls (tdecl :: Ref.get typed_decls);
    sub_ctx') sub_ctx items in
    let minfo = {mod_name; mod_pub_vars = Ref.get pub_vars; mod_pub_mutable_vars = Ref.get pub_mutable_vars; mod_pub_types = Ref.get pub_types; mod_opaque_types = Ref.get opaque_types; mod_pub_constructors = Ref.get pub_constructors; mod_instances = Ref.get all_instances; mod_submodules = Ref.get submodules; mod_pub_classes = Ref.get pub_classes} in
    let outer_type_env = {sub_ctx.type_env with modules = (mod_name, minfo) :: ctx.type_env.modules} in
    let outer_type_env = {outer_type_env with type_aliases = ctx.type_env.type_aliases} in
    let outer_vars = List.fold (fn vars (short, scheme) -> let qualified = prefix ^ short in
    (qualified, scheme) :: vars) ctx.vars (Ref.get pub_vars) in
    let outer_type_env = List.fold (fn te (short, info) -> let qualified = prefix ^ short in
    {te with constructors = (qualified, info) :: te.constructors}) outer_type_env (Ref.get pub_constructors) in
    let existing_dict_names = List.map (fn i -> i.inst_dict_name) outer_type_env.instances in
    let new_insts = List.filter (fn inst -> not (List.mem inst.inst_dict_name existing_dict_names)) (Ref.get all_instances) in
    let outer_type_env = {outer_type_env with instances = List.concat new_insts outer_type_env.instances} in
    let outer_mutable_vars = List.fold (fn mvs short -> let qualified = prefix ^ short in
    qualified :: mvs) ctx.mutable_vars (Ref.get pub_mutable_vars) in
    let outer_ctx = {ctx with vars = outer_vars; mutable_vars = outer_mutable_vars; type_env = outer_type_env} in
    (outer_ctx, TDModule (mod_name, List.rev (Ref.get typed_decls)))
  and check_module_item sub_ctx level prefix (item : Ast.module_decl) pub_vars pub_mutable_vars pub_types opaque_types pub_constructors all_instances submodules pub_classes typed_decls =
    let decl = item.decl in
    match decl with
    | Ast.DModule ((inner_name, inner_items)) -> 
      let (sub_ctx', tdecl) = process_module_def sub_ctx level inner_name inner_items in
      do
        match item.vis with
        | Ast.Public -> 
          do
            match find_module_in_env sub_ctx'.type_env inner_name with
            | Some inner_info -> 
              Ref.set submodules ((inner_name, inner_info) :: Ref.get submodules);
              List.iter (fn (short, scheme) -> Ref.set pub_vars ((inner_name ^ ("." ^ short), scheme) :: Ref.get pub_vars)) inner_info.mod_pub_vars;
              List.iter (fn (short, info) -> Ref.set pub_constructors ((inner_name ^ ("." ^ short), info) :: Ref.get pub_constructors)) inner_info.mod_pub_constructors
            | None -> ()

          end
        | _ -> ()

      end;
      (sub_ctx', tdecl)
    | Ast.DType ((type_params, name, def, deriving_)) -> 
      let qualified_name = prefix ^ name in
      let sub_ctx_with_alias = {sub_ctx with type_env = {sub_ctx.type_env with type_aliases = (name, qualified_name) :: sub_ctx.type_env.type_aliases}} in
      let sub_ctx' = process_type_def sub_ctx_with_alias type_params qualified_name def in
      do
        match item.vis with
        | Ast.Public -> 
          do
            Ref.set pub_types (qualified_name :: Ref.get pub_types);
            match def with
            | Ast.TDVariant ctors -> List.iter (fn (ctor_name, _, _) ->
              do
                match List.assoc_opt ctor_name sub_ctx'.type_env.constructors with
                | Some info -> 
                  let qual_info = {info with ctor_type_name = qualified_name} in
                  Ref.set pub_constructors ((ctor_name, qual_info) :: Ref.get pub_constructors)
                | None -> ()

              end) ctors
            | Ast.TDRecord _ | Ast.TDAlias _ -> ()

          end
        | Ast.Opaque -> 
          Ref.set pub_types (qualified_name :: Ref.get pub_types);
          Ref.set opaque_types (qualified_name :: Ref.get opaque_types)
        | Ast.Private -> ()

      end;
      let sub_ctx' = List.fold (fn ctx cls ->
        do
          match generate_derived_instance type_params name def cls with
          | Some ((class_name, inst_tys, constraints, methods)) -> 
            let (ctx', tdecl) = process_instance_def ctx level class_name inst_tys constraints methods in
            Ref.set typed_decls (tdecl :: Ref.get typed_decls);
            Ref.set all_instances ctx'.type_env.instances;
            ctx'
          | None -> error ($"cannot derive {cls} for type {name}")

        end) sub_ctx' deriving_ in
      (sub_ctx', TDType (qualified_name, def))
    | Ast.DLet ((name, params, ret_annot, constraints, body)) -> 
      let qualified_name = prefix ^ name in
      let (te, scheme) =
        if constraints <> [] do
          synth_constrained_fn sub_ctx level constraints params ret_annot body
        else do
          let full_body = wrap_params_decl params ret_annot body in
          let te = synth sub_ctx (level + 1) full_body in
          improve_fundeps_in_expr sub_ctx.vars sub_ctx.type_env te;
          let scheme =
            if (params = []) && (not (is_syntactic_value body)) do
              mono_scheme te.ty
            else
              resolve_let_constraints Types.empty_type_env level [] params ret_annot te.ty (Hashtbl.create 0) in
          let scheme = infer_implicit_constraints "" sub_ctx.type_env sub_ctx.vars te scheme in
          let scheme = infer_record_evidence sub_ctx.vars te scheme in
          (te, scheme)
        end in
      let sub_ctx' = extend_var sub_ctx name scheme in
      let sub_ctx' = extend_var sub_ctx' qualified_name scheme in
      do
        match item.vis with
        | Ast.Public -> Ref.set pub_vars ((name, scheme) :: Ref.get pub_vars)
        | _ -> ()

      end;
      (sub_ctx', TDLet (qualified_name, te))
    | Ast.DLetMut ((name, body)) -> 
      let qualified_name = prefix ^ name in
      let te = synth sub_ctx (level + 1) body in
      let scheme = mono_scheme te.ty in
      let sub_ctx' = extend_var_mutable sub_ctx name scheme in
      let sub_ctx' = extend_var_mutable sub_ctx' qualified_name scheme in
      do
        match item.vis with
        | Ast.Public -> 
          Ref.set pub_vars ((name, scheme) :: Ref.get pub_vars);
          Ref.set pub_mutable_vars (name :: Ref.get pub_mutable_vars)
        | _ -> ()

      end;
      (sub_ctx', TDLetMut (qualified_name, te))
    | Ast.DLetRec ((name, type_params, params, ret_annot, constraints, body)) -> 
      let qualified_name = prefix ^ name in
      let (fn_te, scheme) =
        if type_params <> [] do
          synth_poly_rec_fn sub_ctx level name qualified_name type_params params ret_annot body
        else if constraints <> [] do
          let fn_var = Types.new_tvar (level + 1) in
          let sub_ctx_self = extend_var_mono sub_ctx name fn_var in
          let sub_ctx_self = extend_var_mono sub_ctx_self qualified_name fn_var in
          let (te, scheme) = synth_constrained_fn sub_ctx_self level constraints params ret_annot body in
          try_unify fn_var te.ty;
          (te, scheme)
        else do
          let full_body = wrap_params_decl params ret_annot body in
          let fn_var = Types.new_tvar (level + 1) in
          let sub_ctx' = extend_var_mono sub_ctx name fn_var in
          let sub_ctx' = extend_var_mono sub_ctx' qualified_name fn_var in
          let fn_te = synth sub_ctx' (level + 1) full_body in
          try_unify fn_var fn_te.ty;
          improve_fundeps_in_expr sub_ctx.vars sub_ctx.type_env fn_te;
          let scheme = resolve_let_constraints Types.empty_type_env level [] params ret_annot fn_te.ty (Hashtbl.create 0) in
          let scheme = infer_implicit_constraints name sub_ctx.type_env sub_ctx.vars fn_te scheme in
          let scheme = infer_record_evidence sub_ctx.vars fn_te scheme in
          (fn_te, scheme)
        end in
      let sub_ctx'' = extend_var sub_ctx name scheme in
      let sub_ctx'' = extend_var sub_ctx'' qualified_name scheme in
      do
        match item.vis with
        | Ast.Public -> Ref.set pub_vars ((name, scheme) :: Ref.get pub_vars)
        | _ -> ()

      end;
      (sub_ctx'', TDLetRec (qualified_name, fn_te))
    | Ast.DClass ((name, tyvars, fundeps, methods)) -> 
      let qualified = prefix ^ name in
      let (sub_ctx', tdecl) = process_class_def sub_ctx qualified tyvars fundeps methods in
      let sub_ctx' = {sub_ctx' with type_env = {sub_ctx'.type_env with type_aliases = (name, qualified) :: sub_ctx'.type_env.type_aliases}} in
      do
        match item.vis with
        | Ast.Public -> 
          Ref.set pub_classes (qualified :: Ref.get pub_classes);
          List.iter (fn (mname, _) ->
            do
              match List.assoc_opt mname sub_ctx'.vars with
              | Some scheme -> Ref.set pub_vars ((mname, scheme) :: Ref.get pub_vars)
              | None -> ()

            end) methods
        | _ -> ()

      end;
      (sub_ctx', tdecl)
    | Ast.DInstance ((class_name, inst_ty_annots, constraints, methods)) -> 
      let (sub_ctx', tdecl) = process_instance_def sub_ctx level class_name inst_ty_annots constraints methods in
      let new_insts = List.filter (fn inst -> not (List.exists (fn prev -> prev.inst_dict_name = inst.inst_dict_name) sub_ctx.type_env.instances)) sub_ctx'.type_env.instances in
      Ref.set all_instances (List.concat new_insts (Ref.get all_instances));
      (sub_ctx', tdecl)
    | Ast.DEffect ((name, type_params, ops)) -> 
      let tvars = Hashtbl.create 4 in
      List.iteri (fn i p -> Hashtbl.set tvars p (Types.TGen i)) type_params;
      let resolved_ops = List.map (fn (op_name, annot) -> let ty = resolve_ty_annot_shared sub_ctx 0 tvars annot in
      (op_name, ty)) ops in
      let effect_def = {effect_name = name; effect_params = type_params; effect_ops = resolved_ops} in
      let type_env = {sub_ctx.type_env with effects = effect_def :: sub_ctx.type_env.effects} in
      let sub_ctx' = {sub_ctx with type_env} in
      (sub_ctx', TDEffect name)
    | Ast.DExtern ((name, ty_annot)) -> 
      let qualified_name = prefix ^ name in
      let tvars = Hashtbl.create 4 in
      let ty = resolve_ty_annot_shared sub_ctx 1 tvars ty_annot in
      let scheme = Types.generalize 0 ty in
      let sub_ctx' = extend_var sub_ctx name scheme in
      let sub_ctx' = extend_var sub_ctx' qualified_name scheme in
      do
        match item.vis with
        | Ast.Public -> Ref.set pub_vars ((name, scheme) :: Ref.get pub_vars)
        | _ -> ()

      end;
      (sub_ctx', TDExtern (qualified_name, scheme))
    | Ast.DExpr expr -> 
      let te = synth sub_ctx level expr in
      (sub_ctx, TDExpr te)
    | Ast.DOpen ((mod_name, names_opt)) -> 
      let sub_ctx' = open_module_into_ctx sub_ctx mod_name names_opt in
      let minfo =
        match find_module_in_env sub_ctx.type_env mod_name with
        | Some m -> m
        | None -> error ($"unknown module: {mod_name}")
       in
      let class_method_names = List.concat_map (fn qname ->
        do
          match List.find (fn (c : Types.class_def) -> c.class_name = qname) sub_ctx.type_env.classes with
          | Some cls -> List.map fst cls.class_methods
          | None -> []

        end) minfo.mod_pub_classes in
      let filter name =
        match names_opt with
        | None -> true
        | Some names -> List.mem name names
       in
      let alias_pairs = List.filter_map (fn (short, scheme) -> if (filter short) && (not (List.mem short class_method_names)) do
        let qualified_dst = prefix ^ short in
        let qualified_src = mod_name ^ ("." ^ short) in
        (scheme; ());
        Some (qualified_dst, qualified_src)
      else
        None) minfo.mod_pub_vars in
      let sub_ctx' = List.fold (fn ctx (short, scheme) -> if (filter short) && (not (List.mem short class_method_names)) do
        extend_var ctx (prefix ^ short) scheme
      else
        ctx) sub_ctx' minfo.mod_pub_vars in
      (sub_ctx', TDOpen alias_pairs)
    | Ast.DLetRecAnd bindings -> 
      let has_poly = List.exists (fn (_, tp, _, _, _, _) -> tp <> []) bindings in
      if has_poly do
        let shared_tvars_list = List.map (fn (_, type_params, params, ret_annot, _, _) -> let shared_tvars = Hashtbl.create 4 in
        List.iter (fn tp -> Hashtbl.set shared_tvars tp (Types.new_tvar (level + 1))) type_params;
        let param_tys = List.map (fn (p : Ast.param) ->
          do
            match p.annot with
            | Some annot -> resolve_ty_annot_shared sub_ctx (level + 1) shared_tvars annot
            | None -> Types.new_tvar (level + 1)

          end) params in
        let (ret_ty, body_eff) =
          match ret_annot with
          | Some (Ast.TyWithEffect ((ty, eff_annot))) -> 
            let ty' = resolve_ty_annot_shared sub_ctx (level + 1) shared_tvars ty in
            let eff =
              match eff_annot with
              | Ast.EffAnnotPure -> Types.EffEmpty
              | Ast.EffAnnotRow items -> resolve_eff_items sub_ctx (level + 1) shared_tvars items
             in
            (ty', eff)
          | Some annot -> (resolve_ty_annot_shared sub_ctx (level + 1) shared_tvars annot, Types.new_effvar (level + 1))
          | None -> (Types.new_tvar (level + 1), Types.new_effvar (level + 1))
         in
        let fn_ty =
          match List.rev param_tys with
          | [] -> ret_ty
          | last :: rest -> 
            let inner = Types.TArrow (last, body_eff, ret_ty) in
            List.fold (fn acc pty -> Types.TArrow (pty, Types.EffEmpty, acc)) inner rest
         in
        (shared_tvars, param_tys, ret_ty, body_eff, fn_ty)) bindings in
        let schemes = List.map (fn (_, _, _, _, fn_ty) -> Types.generalize level fn_ty) shared_tvars_list in
        let sub_ctx' = List.fold2 (fn ctx (name, _, _, _, _, _) scheme -> let qualified_name = prefix ^ name in
        let ctx = extend_var ctx name scheme in
        extend_var ctx qualified_name scheme) sub_ctx bindings schemes in
        let body_tes = List.map2 (fn (_, _, params, _, _, body) (_, param_tys, ret_ty, body_eff, _) -> let inner_ctx = List.fold2 (fn c (p : Ast.param) ty -> extend_var_mono c p.name ty) {sub_ctx' with current_eff = body_eff} params param_tys in
        let body_te = check inner_ctx (level + 1) body ret_ty in
        match (List.rev params, List.rev param_tys) with
        | ([], []) -> body_te
        | (last_p :: rest_ps, last_pty :: rest_ptys) -> 
          let inner = mk (TEFun (last_p.name, body_te, false)) (Types.TArrow (last_pty, body_eff, body_te.ty)) in
          List.fold2 (fn acc (p : Ast.param) pty -> mk (TEFun (p.name, acc, false)) (Types.TArrow (pty, Types.EffEmpty, acc.ty))) inner rest_ps rest_ptys
        | _ -> failwith "assert false"
        ) bindings shared_tvars_list in
        let sub_ctx'' = List.fold2 (fn ctx (name, _, _, _, _, _) scheme -> let qualified_name = prefix ^ name in
        let ctx = extend_var ctx name scheme in
        extend_var ctx qualified_name scheme) sub_ctx bindings schemes in
        let typed_bindings = List.map2 (fn (name, _, _, _, _, _) te -> let qualified_name = prefix ^ name in
        (qualified_name, te)) bindings body_tes in
        List.iter (fn (name, _, _, _, _, _) -> let scheme = List.assoc name (List.map2 (fn (n, _, _, _, _, _) s -> (n, s)) bindings schemes) in
        match item.vis with
        | Ast.Public -> Ref.set pub_vars ((name, scheme) :: Ref.get pub_vars)
        | _ -> ()
        ) bindings;
        (sub_ctx'', TDLetRecAnd typed_bindings)
      else do
        let fn_vars = List.map (fn (name, _, _, _, _, _) -> (name, Types.new_tvar (level + 1))) bindings in
        let sub_ctx' = List.fold (fn ctx (name, tv) -> let qualified_name = prefix ^ name in
        let ctx = extend_var_mono ctx name tv in
        extend_var_mono ctx qualified_name tv) sub_ctx fn_vars in
        let body_tes = List.map2 (fn (name, _, params, ret_annot, constraints, body) (_, tv) -> (name; ());
        if constraints <> [] do
          let (te, _scheme) = synth_constrained_fn sub_ctx' level constraints params ret_annot body in
          try_unify tv te.ty;
          te
        else do
          let full_body = wrap_params_decl params ret_annot body in
          let te = synth sub_ctx' (level + 1) full_body in
          try_unify tv te.ty;
          te
        end) bindings fn_vars in
        let sub_ctx'' = List.fold2 (fn ctx (name, _, _, _, _, _) (_, tv) -> let qualified_name = prefix ^ name in
        let scheme = Types.generalize level tv in
        let ctx = extend_var ctx name scheme in
        extend_var ctx qualified_name scheme) sub_ctx bindings fn_vars in
        let typed_bindings = List.map2 (fn (name, _, _, _, _, _) te -> let qualified_name = prefix ^ name in
        (qualified_name, te)) bindings body_tes in
        List.iter2 (fn (name, _, _, _, _, _) (_, tv) -> let scheme = Types.generalize level tv in
        match item.vis with
        | Ast.Public -> Ref.set pub_vars ((name, scheme) :: Ref.get pub_vars)
        | _ -> ()
        ) bindings fn_vars;
        (sub_ctx'', TDLetRecAnd typed_bindings)
      end
    | Ast.DTypeAnd type_defs -> 
      let sub_ctx' = List.fold (fn ctx (type_params, name, def, _deriving) -> let qualified_name = prefix ^ name in
      let num_params = List.length type_params in
      let ctx = {ctx with type_env = {ctx.type_env with type_aliases = (name, qualified_name) :: ctx.type_env.type_aliases}} in
      match def with
      | Ast.TDVariant _ -> {ctx with type_env = {ctx.type_env with variants = (qualified_name, num_params, [], false) :: ctx.type_env.variants}}
      | Ast.TDRecord _ -> {ctx with type_env = {ctx.type_env with records = (qualified_name, []) :: ctx.type_env.records}}
      | Ast.TDAlias _ -> ctx
      ) sub_ctx type_defs in
      let sub_ctx' = List.fold (fn ctx (type_params, name, def, _deriving) ->
        do
          match def with
          | Ast.TDRecord _ -> 
            let qualified_name = prefix ^ name in
            process_type_def ctx type_params qualified_name def
          | _ -> ctx

        end) sub_ctx' type_defs in
      let sub_ctx' = List.fold (fn ctx (type_params, name, def, _deriving) ->
        do
          match def with
          | Ast.TDRecord _ -> ctx
          | _ -> 
            let qualified_name = prefix ^ name in
            process_type_def ctx type_params qualified_name def

        end) sub_ctx' type_defs in
      List.iter (fn (_type_params, name, def, _deriving) -> let qualified_name = prefix ^ name in
      match item.vis with
      | Ast.Public -> 
        do
          Ref.set pub_types (qualified_name :: Ref.get pub_types);
          match def with
          | Ast.TDVariant ctors -> List.iter (fn (ctor_name, _, _) ->
            do
              match List.assoc_opt ctor_name sub_ctx'.type_env.constructors with
              | Some info -> 
                let qual_info = {info with ctor_type_name = qualified_name} in
                Ref.set pub_constructors ((ctor_name, qual_info) :: Ref.get pub_constructors)
              | None -> ()

            end) ctors
          | Ast.TDRecord _ | Ast.TDAlias _ -> ()

        end
      | Ast.Opaque -> 
        Ref.set pub_types (qualified_name :: Ref.get pub_types);
        Ref.set opaque_types (qualified_name :: Ref.get opaque_types)
      | Ast.Private -> ()
      ) type_defs;
      let sub_ctx' = List.fold (fn ctx (type_params, name, def, deriving_) -> List.fold (fn ctx cls ->
        do
          match generate_derived_instance type_params name def cls with
          | Some ((class_name, inst_tys, constraints, methods)) -> 
            let (ctx', tdecl) = process_instance_def ctx level class_name inst_tys constraints methods in
            Ref.set typed_decls (tdecl :: Ref.get typed_decls);
            Ref.set all_instances ctx'.type_env.instances;
            ctx'
          | None -> error ($"cannot derive {cls} for type {name}")

        end) ctx deriving_) sub_ctx' type_defs in
      let type_decls = List.map (fn (_tp, name, def, _d) -> TDType (prefix ^ name, def)) type_defs in
      let rec push_all_but_last =
        fn
          | [] -> failwith "empty DTypeAnd"
          | last :: [] -> last
          | hd :: tl -> 
            Ref.set typed_decls (hd :: Ref.get typed_decls);
            push_all_but_last tl
       in
      let last_tdecl = push_all_but_last type_decls in
      (sub_ctx', last_tdecl)


  pub let process_open ctx mod_name names_opt =
    let minfo =
      match find_module_in_env ctx.type_env mod_name with
      | Some m -> m
      | None -> error ($"unknown module: {mod_name}")
     in
    let class_method_names = List.concat_map (fn qname ->
      do
        match List.find (fn (c : Types.class_def) -> c.class_name = qname) ctx.type_env.classes with
        | Some cls -> List.map fst cls.class_methods
        | None -> []

      end) minfo.mod_pub_classes in
    let alias_pairs = Ref.create [] in
    let filter name =
      match names_opt with
      | None -> true
      | Some names -> List.mem name names
     in
    List.iter (fn (short, _scheme) -> if (filter short) && (not (List.mem short class_method_names)) do
      let qualified = mod_name ^ ("." ^ short) in
      Ref.set alias_pairs ((short, qualified) :: Ref.get alias_pairs)
    end) minfo.mod_pub_vars;
    let ctx' = open_module_into_ctx ctx mod_name names_opt in
    (ctx', TDOpen (Ref.get alias_pairs))

  pub let check_decl ctx level (decl : Ast.decl) : ctx * tdecl list =
    match decl with
    | Ast.DType ((type_params, name, def, deriving_)) -> 
      let ctx' = process_type_def ctx type_params name def in
      let (ctx', derived_tdecls) = List.fold (fn (ctx, acc) cls ->
        do
          match generate_derived_instance type_params name def cls with
          | Some ((class_name, inst_tys, constraints, methods)) -> 
            let (ctx', tdecl) = process_instance_def ctx level class_name inst_tys constraints methods in
            (ctx', tdecl :: acc)
          | None -> error ($"cannot derive {cls} for type {name}")

        end) (ctx', []) deriving_ in
      (ctx', TDType (name, def) :: List.rev derived_tdecls)
    | Ast.DLet ((name, params, ret_annot, constraints, body)) -> 
      if constraints <> [] do
        let (te, scheme) = synth_constrained_fn ctx level constraints params ret_annot body in
        let ctx' = extend_var ctx name scheme in
        (ctx', TDLet (name, te) :: [])
      else do
        let eff = Types.new_effvar level in
        let eff_ctx = {ctx with current_eff = eff} in
        let full_body = wrap_params_decl params ret_annot body in
        let te = synth eff_ctx (level + 1) full_body in
        improve_fundeps_in_expr ctx.vars ctx.type_env te;
        let scheme =
          if (params = []) && (not (is_syntactic_value body)) do
            mono_scheme te.ty
          else
            resolve_let_constraints Types.empty_type_env level [] params ret_annot te.ty (Hashtbl.create 0) in
        let scheme = infer_implicit_constraints "" ctx.type_env ctx.vars te scheme in
        let scheme = infer_record_evidence ctx.vars te scheme in
        let ctx' = extend_var ctx name scheme in
        (ctx', TDLet (name, te) :: [])
      end
    | Ast.DLetMut ((name, body)) -> 
      let eff = Types.new_effvar level in
      let eff_ctx = {ctx with current_eff = eff} in
      let te = synth eff_ctx (level + 1) body in
      let scheme = mono_scheme te.ty in
      let ctx' = extend_var_mutable ctx name scheme in
      (ctx', TDLetMut (name, te) :: [])
    | Ast.DLetRec ((name, type_params, params, ret_annot, constraints, body)) -> 
      if type_params <> [] do
        let (te, scheme) = synth_poly_rec_fn ctx level name "" type_params params ret_annot body in
        let ctx' = extend_var ctx name scheme in
        (ctx', TDLetRec (name, te) :: [])
      else if constraints <> [] do
        let fn_var = Types.new_tvar (level + 1) in
        let ctx_with_self = extend_var_mono ctx name fn_var in
        let (te, scheme) = synth_constrained_fn ctx_with_self level constraints params ret_annot body in
        try_unify fn_var te.ty;
        let ctx' = extend_var ctx name scheme in
        (ctx', TDLetRec (name, te) :: [])
      else do
        let eff = Types.new_effvar level in
        let eff_ctx = {ctx with current_eff = eff} in
        let full_body = wrap_params_decl params ret_annot body in
        let fn_var = Types.new_tvar (level + 1) in
        let ctx' = extend_var_mono eff_ctx name fn_var in
        let fn_te = synth ctx' (level + 1) full_body in
        try_unify fn_var fn_te.ty;
        improve_fundeps_in_expr ctx.vars ctx.type_env fn_te;
        let scheme = resolve_let_constraints Types.empty_type_env level [] params ret_annot fn_te.ty (Hashtbl.create 0) in
        let scheme = infer_implicit_constraints name ctx.type_env ctx.vars fn_te scheme in
        let scheme = infer_record_evidence ctx.vars fn_te scheme in
        let ctx'' = extend_var ctx name scheme in
        (ctx'', TDLetRec (name, fn_te) :: [])
      end
    | Ast.DExpr expr -> 
      let eff = Types.new_effvar level in
      let ctx' = {ctx with current_eff = eff} in
      let te = synth ctx' level expr in
      do
        do try
          Types.unify_eff (Types.eff_repr eff) Types.EffEmpty
        with
        | unify_error _ -> error ($"expression has unhandled effects: {Types.pp_eff eff}")
        end
      end;
      (ctx, TDExpr te :: [])
    | Ast.DClass ((name, tyvars, fundeps, methods)) -> 
      let (ctx', td) = process_class_def ctx name tyvars fundeps methods in
      (ctx', td :: [])
    | Ast.DInstance ((class_name, inst_ty_annots, constraints, methods)) -> 
      let (ctx', td) = process_instance_def ctx level class_name inst_ty_annots constraints methods in
      (ctx', td :: [])
    | Ast.DEffect ((name, type_params, ops)) -> 
      let tvars = Hashtbl.create 4 in
      List.iteri (fn i p -> Hashtbl.set tvars p (Types.TGen i)) type_params;
      let resolved_ops = List.map (fn (op_name, annot) -> let ty = resolve_ty_annot_shared ctx 0 tvars annot in
      (op_name, ty)) ops in
      let effect_def = {effect_name = name; effect_params = type_params; effect_ops = resolved_ops} in
      let type_env = {ctx.type_env with effects = effect_def :: ctx.type_env.effects} in
      let ctx = {ctx with type_env} in
      (ctx, TDEffect name :: [])
    | Ast.DExtern ((name, ty_annot)) -> 
      let tvars = Hashtbl.create 4 in
      let ty = resolve_ty_annot_shared ctx 1 tvars ty_annot in
      let scheme = Types.generalize 0 ty in
      let ctx = extend_var ctx name scheme in
      (ctx, TDExtern (name, scheme) :: [])
    | Ast.DModule ((name, items)) -> 
      let (ctx', td) = process_module_def ctx level name items in
      (ctx', td :: [])
    | Ast.DOpen ((mod_name, names_opt)) -> 
      let (ctx', td) = process_open ctx mod_name names_opt in
      (ctx', td :: [])
    | Ast.DLetRecAnd bindings -> 
      let has_poly = List.exists (fn (_, tp, _, _, _, _) -> tp <> []) bindings in
      if has_poly do
        let shared_tvars_list = List.map (fn (_, type_params, params, ret_annot, _, _) -> let shared_tvars = Hashtbl.create 4 in
        List.iter (fn tp -> Hashtbl.set shared_tvars tp (Types.new_tvar (level + 1))) type_params;
        let param_tys = List.map (fn (p : Ast.param) ->
          do
            match p.annot with
            | Some annot -> resolve_ty_annot_shared ctx (level + 1) shared_tvars annot
            | None -> Types.new_tvar (level + 1)

          end) params in
        let (ret_ty, body_eff) =
          match ret_annot with
          | Some (Ast.TyWithEffect ((ty, eff_annot))) -> 
            let ty' = resolve_ty_annot_shared ctx (level + 1) shared_tvars ty in
            let eff =
              match eff_annot with
              | Ast.EffAnnotPure -> Types.EffEmpty
              | Ast.EffAnnotRow items -> resolve_eff_items ctx (level + 1) shared_tvars items
             in
            (ty', eff)
          | Some annot -> (resolve_ty_annot_shared ctx (level + 1) shared_tvars annot, Types.new_effvar (level + 1))
          | None -> (Types.new_tvar (level + 1), Types.new_effvar (level + 1))
         in
        let fn_ty =
          match List.rev param_tys with
          | [] -> ret_ty
          | last :: rest -> 
            let inner = Types.TArrow (last, body_eff, ret_ty) in
            List.fold (fn acc pty -> Types.TArrow (pty, Types.EffEmpty, acc)) inner rest
         in
        (shared_tvars, param_tys, ret_ty, body_eff, fn_ty)) bindings in
        let schemes = List.map (fn (_, _, _, _, fn_ty) -> Types.generalize level fn_ty) shared_tvars_list in
        let ctx' = List.fold2 (fn ctx (name, _, _, _, _, _) scheme -> extend_var ctx name scheme) ctx bindings schemes in
        let body_tes = List.map2 (fn (_, _, params, _, _, body) (_, param_tys, ret_ty, body_eff, _) -> let inner_ctx = List.fold2 (fn c (p : Ast.param) ty -> extend_var_mono c p.name ty) {ctx' with current_eff = body_eff} params param_tys in
        let body_te = check inner_ctx (level + 1) body ret_ty in
        match (List.rev params, List.rev param_tys) with
        | ([], []) -> body_te
        | (last_p :: rest_ps, last_pty :: rest_ptys) -> 
          let inner = mk (TEFun (last_p.name, body_te, false)) (Types.TArrow (last_pty, body_eff, body_te.ty)) in
          List.fold2 (fn acc (p : Ast.param) pty -> mk (TEFun (p.name, acc, false)) (Types.TArrow (pty, Types.EffEmpty, acc.ty))) inner rest_ps rest_ptys
        | _ -> failwith "assert false"
        ) bindings shared_tvars_list in
        let ctx'' = List.fold2 (fn ctx (name, _, _, _, _, _) scheme -> extend_var ctx name scheme) ctx bindings schemes in
        let typed_bindings = List.map2 (fn (name, _, _, _, _, _) te -> (name, te)) bindings body_tes in
        (ctx'', TDLetRecAnd typed_bindings :: [])
      else do
        let fn_vars = List.map (fn (name, _, _, _, _, _) -> (name, Types.new_tvar (level + 1))) bindings in
        let ctx' = List.fold (fn ctx (name, tv) -> extend_var_mono ctx name tv) ctx fn_vars in
        let body_tes = List.map2 (fn (name, _, params, ret_annot, constraints, body) (_, tv) -> (name; ());
        if constraints <> [] do
          let (te, _scheme) = synth_constrained_fn ctx' level constraints params ret_annot body in
          try_unify tv te.ty;
          te
        else do
          let full_body = wrap_params_decl params ret_annot body in
          let te = synth ctx' (level + 1) full_body in
          try_unify tv te.ty;
          te
        end) bindings fn_vars in
        let ctx'' = List.fold2 (fn ctx (name, _, _, _, _, _) (_, tv) -> let scheme = Types.generalize level tv in
        extend_var ctx name scheme) ctx bindings fn_vars in
        let typed_bindings = List.map2 (fn (name, _, _, _, _, _) te -> (name, te)) bindings body_tes in
        (ctx'', TDLetRecAnd typed_bindings :: [])
      end
    | Ast.DTypeAnd type_defs -> 
      let ctx' = List.fold (fn ctx (type_params, name, def, _deriving) -> let num_params = List.length type_params in
      match def with
      | Ast.TDVariant _ -> 
        let type_env = {ctx.type_env with variants = (name, num_params, [], false) :: ctx.type_env.variants} in
        {ctx with type_env}
      | Ast.TDRecord _ -> 
        let type_env = {ctx.type_env with records = (name, []) :: ctx.type_env.records} in
        {ctx with type_env}
      | Ast.TDAlias _ -> ctx
      ) ctx type_defs in
      let ctx' = List.fold (fn ctx (type_params, name, def, _deriving) ->
        do
          match def with
          | Ast.TDRecord _ -> process_type_def ctx type_params name def
          | _ -> ctx

        end) ctx' type_defs in
      let ctx'' = List.fold (fn ctx (type_params, name, def, _deriving) ->
        do
          match def with
          | Ast.TDRecord _ -> ctx
          | _ -> process_type_def ctx type_params name def

        end) ctx' type_defs in
      let (ctx_final, derived_tdecls) = List.fold (fn (ctx, acc) (type_params, name, def, deriving_) -> let (ctx', new_decls) = List.fold (fn (ctx, acc) cls ->
        do
          match generate_derived_instance type_params name def cls with
          | Some ((class_name, inst_tys, constraints, methods)) -> 
            let (ctx', tdecl) = process_instance_def ctx level class_name inst_tys constraints methods in
            (ctx', tdecl :: acc)
          | None -> error ($"cannot derive {cls} for type {name}")

        end) (ctx, []) deriving_ in
      (ctx', List.concat (List.rev new_decls) acc)) (ctx'', []) type_defs in
      let type_decls = List.map (fn (_tp, name, def, _d) -> TDType (name, def)) type_defs in
      (ctx_final, List.concat type_decls (List.rev derived_tdecls))


  pub let empty_ctx = {vars = []; mutable_vars = []; type_env = Types.empty_type_env; loop_info = None; current_module = None; constraint_tvars = []; current_eff = Types.EffEmpty; return_type = None; inside_handler = false; return_used = Ref.create false}

  pub type xform_ctx = {
    xf_type_env: Types.type_env;
    xf_schemes: (string * Types.scheme) list;
    xf_constrained: (int * string * string) list;
    xf_record_evidence: (int * string * string) list;
    xf_locals: string list
  }

  pub let build_tgen_map schema_ty actual_ty =
    let map = Hashtbl.create 4 in
    let rec walk s a =
      let a = Types.repr a in
      match s with
      | Types.TGen i -> 
        if not (Hashtbl.has map i) do
          Hashtbl.set map i a
        end
      | Types.TArrow ((s1, _, s2)) -> 
        do
          match a with
          | Types.TArrow ((a1, _, a2)) -> 
            walk s1 a1;
            walk s2 a2
          | _ -> ()

        end
      | Types.TCont ((s1, _, s2)) -> 
        do
          match a with
          | Types.TCont ((a1, _, a2)) -> 
            walk s1 a1;
            walk s2 a2
          | _ -> ()

        end
      | Types.TTuple ss -> 
        do
          match a with
          | Types.TTuple aa when (List.length ss) = (List.length aa) -> List.iter2 walk ss aa
          | _ -> ()

        end
      | Types.TList s1 -> 
        do
          match a with
          | Types.TList a1 -> walk s1 a1
          | _ -> ()

        end
      | Types.TArray s1 -> 
        do
          match a with
          | Types.TArray a1 -> walk s1 a1
          | _ -> ()

        end
      | Types.TMap ((sk, sv)) -> 
        do
          match a with
          | Types.TMap ((ak, av)) -> 
            walk sk ak;
            walk sv av
          | _ -> ()

        end
      | Types.TVariant ((_, ss)) -> 
        do
          match a with
          | Types.TVariant ((_, aa)) when (List.length ss) = (List.length aa) -> List.iter2 walk ss aa
          | _ -> ()

        end
      | Types.TRecord srow -> 
        do
          match a with
          | Types.TRecord arow -> 
            let sf = Types.record_row_to_fields srow in
            let af = Types.record_row_to_fields arow in
            List.iter (fn (sname, sty) ->
              do
                match List.assoc_opt sname af with
                | Some aty -> walk sty aty
                | None -> ()

              end) sf
          | _ -> ()

        end
      | Types.TPolyVariant srow -> 
        do
          match a with
          | Types.TPolyVariant arow -> walk_pvrows srow arow
          | _ -> ()

        end
      | _ -> ()

    and walk_pvrows srow arow =
      let rec collect_tags row =
        match row with
        | Types.PVRow ((tag, ty_opt, tail)) -> (tag, ty_opt) :: collect_tags tail
        | Types.PVVar {contents = Types.PVLink r} -> collect_tags r
        | _ -> []
       in
      let atags = collect_tags arow in
      let rec go row =
        match row with
        | Types.PVRow ((stag, sty_opt, stail)) -> 
          do
            match List.assoc_opt stag atags with
            | Some aty_opt -> 
              do
                match (sty_opt, aty_opt) with
                | (Some sty, Some aty) -> walk sty aty
                | _ -> ()

              end
            | None -> ()

          end;
          go stail
        | Types.PVVar {contents = Types.PVLink r} -> go r
        | _ -> ()
       in
      go srow in
    walk schema_ty actual_ty;
    map

  pub let find_constrained_dict xctx tvar_id class_name = List.find_map (fn (tid, dparam, cls) -> if (tid = tvar_id) && (cls = class_name) do
    Some dparam
  else
    None) xctx.xf_constrained

  pub let rec resolve_dict_arg xctx (cc : Types.class_constraint) tgen_map =
    let arg_types = List.map (fn (ca : Types.class_arg) ->
      do
        match ca with
        | CATGen idx -> 
          do
            match Hashtbl.get tgen_map idx with
            | Some ty -> Some (Types.repr ty)
            | None -> None

          end
        | CATy ty -> Some (Types.freshen_unbound ty)
        | CAWild -> Some (Types.new_tvar 1)
        | CAPhantom ((idx, _)) -> 
          do
            match Hashtbl.get tgen_map idx with
            | Some ty -> Some (Types.repr ty)
            | None -> 
              let tv = Types.new_tvar 1 in
              Hashtbl.set tgen_map idx tv;
              Some tv

          end

      end) cc.cc_args in
    let has_unresolved = List.exists (fn opt -> opt = None) arg_types in
    if has_unresolved do
      if cc.cc_class = "Show" do
        mk (TERecord (("show", mk (TEVar "__show_value") Types.TUnit) :: [])) Types.TUnit
      else
        error ($"could not resolve constraint type argument for {cc.cc_class}")
    else do
      let arg_types = List.filter_map (fn x -> x) arg_types in
      let arg_types =
        let has_unbound = List.exists (fn ty ->
          do
            match ty with
            | Types.TVar {contents = Types.Unbound _} -> true
            | _ -> false

          end) arg_types in
        if has_unbound do
          do
            let class_opt = List.find (fn (cls : Types.class_def) -> (cls.class_name = cc.cc_class) && (cls.class_fundeps <> [])) xctx.xf_type_env.classes in
            match class_opt with
            | Some class_def -> 
              let partial = List.map (fn ty ->
                do
                  match Types.repr ty with
                  | Types.TVar {contents = Types.Unbound _} -> None
                  | t -> Some t

                end) arg_types in
              let improved = Types.improve_with_fundeps xctx.xf_type_env.instances class_def partial in
              List.iter2 (fn orig_ty imp ->
                do
                  match (imp, Types.repr orig_ty) with
                  | (Some resolved, Types.TVar ({contents = Types.Unbound _} as r)) -> (* try/catch-all *) Types.unify (Types.TVar r) resolved
                  | _ -> ()

                end) arg_types improved;
              List.map Types.repr arg_types
            | None -> arg_types

          end
        else
          arg_types in
      let constrained_match = List.find_map (fn ty ->
        do
          match ty with
          | Types.TVar {contents = Types.Unbound ((id, _))} -> find_constrained_dict xctx id cc.cc_class
          | _ -> None

        end) arg_types in
      match constrained_match with
      | Some dparam -> mk (TEVar dparam) Types.TUnit
      | None -> 
        do
          let has_unbound_tvar = List.exists (fn ty ->
            do
              match ty with
              | Types.TVar {contents = Types.Unbound _} -> true
              | _ -> false

            end) arg_types in
          if has_unbound_tvar do
            if cc.cc_class = "Show" do
              mk (TERecord (("show", mk (TEVar "__show_value") Types.TUnit) :: [])) Types.TUnit
            else
              error ($"no instance of {cc.cc_class} for types {String.concat ", " (List.map Types.pp_ty arg_types)}")
          else do
            let partial = List.map (fn ty -> Some ty) arg_types in
            let matching = List.filter (fn (inst : Types.instance_def) -> (inst.inst_class = cc.cc_class) && (((List.length inst.inst_tys) = (List.length arg_types)) && (Types.match_partial_inst inst.inst_tys partial))) xctx.xf_type_env.instances in
            match matching with
            | inst :: [] -> 
              if inst.inst_constraints <> [] do
                resolve_factory_dict xctx inst arg_types
              else
                mk (TEVar (inst.inst_dict_name)) Types.TUnit
            | [] -> 
              let is_structural = List.exists (fn ty ->
                do
                  match Types.repr ty with
                  | Types.TPolyVariant _ | Types.TRecord _ -> true
                  | _ -> false

                end) arg_types in
              if is_structural && (cc.cc_class = "Show") do
                mk (TERecord (("show", mk (TEVar "__show_value") Types.TUnit) :: [])) Types.TUnit
              else
                error ($"no instance of {cc.cc_class} for types {String.concat ", " (List.map Types.pp_ty arg_types)}")
            | _ -> 
              do
                match Types.most_specific_inst matching with
                | Some inst -> 
                  if inst.inst_constraints <> [] do
                    resolve_factory_dict xctx inst arg_types
                  else
                    mk (TEVar (inst.inst_dict_name)) Types.TUnit
                | None -> error ($"ambiguous instance for {cc.cc_class}")

              end

          end
        end

    end
  and resolve_factory_dict xctx inst arg_types =
    let sub_map = Hashtbl.create 4 in
    List.iter2 (fn inst_ty actual_ty -> let rec walk s a =
      let a = Types.repr a in
      match s with
      | Types.TGen i -> 
        if not (Hashtbl.has sub_map i) do
          Hashtbl.set sub_map i a
        end
      | Types.TArrow ((s1, _, s2)) -> 
        do
          match a with
          | Types.TArrow ((a1, _, a2)) -> 
            walk s1 a1;
            walk s2 a2
          | _ -> ()

        end
      | Types.TCont ((s1, _, s2)) -> 
        do
          match a with
          | Types.TCont ((a1, _, a2)) -> 
            walk s1 a1;
            walk s2 a2
          | _ -> ()

        end
      | Types.TTuple ss -> 
        do
          match a with
          | Types.TTuple aa when (List.length ss) = (List.length aa) -> List.iter2 walk ss aa
          | _ -> ()

        end
      | Types.TList s1 -> 
        do
          match a with
          | Types.TList a1 -> walk s1 a1
          | _ -> ()

        end
      | Types.TArray s1 -> 
        do
          match a with
          | Types.TArray a1 -> walk s1 a1
          | _ -> ()

        end
      | Types.TMap ((sk, sv)) -> 
        do
          match a with
          | Types.TMap ((ak, av)) -> 
            walk sk ak;
            walk sv av
          | _ -> ()

        end
      | Types.TVariant ((_, ss)) -> 
        do
          match a with
          | Types.TVariant ((_, aa)) when (List.length ss) = (List.length aa) -> List.iter2 walk ss aa
          | _ -> ()

        end
      | _ -> ()
     in
    walk inst_ty actual_ty) inst.inst_tys arg_types;
    let base = mk (TEVar (inst.inst_dict_name)) Types.TUnit in
    List.fold (fn fn_ sub_cc -> let sub_dict = resolve_dict_arg xctx sub_cc sub_map in
    mk (TEApp (fn_, sub_dict)) Types.TUnit) base inst.inst_constraints

  pub let rec pat_bound_names =
    fn
      | Ast.PatVar name -> name :: []
      | Ast.PatTuple pats | Ast.PatArray pats -> List.concat_map pat_bound_names pats
      | Ast.PatCons ((p1, p2)) -> List.concat (pat_bound_names p1) (pat_bound_names p2)
      | Ast.PatConstruct ((_, Some p)) | Ast.PatPolyVariant ((_, Some p)) -> pat_bound_names p
      | Ast.PatRecord fields -> List.concat_map (fn (_, p) -> pat_bound_names p) fields
      | Ast.PatAs ((p, name)) -> name :: pat_bound_names p
      | Ast.PatOr ((p1, _)) -> pat_bound_names p1
      | Ast.PatMap pairs -> List.concat_map (fn (_, v) -> pat_bound_names v) pairs
      | Ast.PatAnnot ((p, _)) -> pat_bound_names p
      | Ast.PatWild | Ast.PatInt _ | Ast.PatFloat _ | Ast.PatBool _ | Ast.PatString _ | Ast.PatUnit | Ast.PatNil | Ast.PatPin _ | Ast.PatConstruct ((_, None)) | Ast.PatPolyVariant ((_, None)) -> []


  pub let rec xform_expr xctx te =
    match te.expr with
    | TEVar name -> 
      let te = xform_class_method xctx name te in
      xform_constrained_ref xctx name te
    | TEBinop ((op, e1, e2)) -> 
      let e1' = xform_expr xctx e1 in
      let e2' = xform_expr xctx e2 in
      xform_binop xctx op e1' e2' te.ty
    | TEUnop ((op, e)) -> 
      let e' = xform_expr xctx e in
      xform_unop xctx op e' te.ty
    | TEApp ((fn_, arg)) -> 
      let fn' = xform_expr xctx fn_ in
      let arg' = xform_expr xctx arg in
      mk (TEApp (fn', arg')) te.ty
    | TEFun ((param, body, hr)) -> 
      let xctx' = {xctx with xf_locals = param :: xctx.xf_locals} in
      mk (TEFun (param, xform_expr xctx' body, hr)) te.ty
    | TELet ((name, Some scheme, e1, e2)) -> 
      let e1' = xform_constrained_def xctx scheme e1 in
      let xctx' = {xctx with xf_schemes = (name, scheme) :: xctx.xf_schemes} in
      mk (TELet (name, Some scheme, e1', xform_expr xctx' e2)) te.ty
    | TELet ((name, None, e1, e2)) -> 
      let xctx' = {xctx with xf_locals = name :: xctx.xf_locals} in
      mk (TELet (name, None, xform_expr xctx e1, xform_expr xctx' e2)) te.ty
    | TELetRec ((name, Some scheme, e1, e2)) -> 
      let xctx' = {xctx with xf_schemes = (name, scheme) :: xctx.xf_schemes} in
      let e1' = xform_constrained_def xctx' scheme e1 in
      mk (TELetRec (name, Some scheme, e1', xform_expr xctx' e2)) te.ty
    | TELetRec ((name, None, e1, e2)) -> 
      let xctx' = {xctx with xf_locals = name :: xctx.xf_locals} in
      mk (TELetRec (name, None, xform_expr xctx' e1, xform_expr xctx' e2)) te.ty
    | TELetMut ((name, e1, e2)) -> 
      let xctx' = {xctx with xf_locals = name :: xctx.xf_locals} in
      mk (TELetMut (name, xform_expr xctx e1, xform_expr xctx' e2)) te.ty
    | TEWhile ((cond, body)) -> mk (TEWhile (xform_expr xctx cond, xform_expr xctx body)) te.ty
    | TELetRecAnd ((bindings, body)) -> 
      let names = List.map fst bindings in
      let xctx' = {xctx with xf_locals = List.concat names xctx.xf_locals} in
      let bindings' = List.map (fn (n, e) -> (n, xform_expr xctx' e)) bindings in
      mk (TELetRecAnd (bindings', xform_expr xctx' body)) te.ty
    | TEIf ((c, t, e)) -> mk (TEIf (xform_expr xctx c, xform_expr xctx t, xform_expr xctx e)) te.ty
    | TETuple es -> mk (TETuple (List.map (xform_expr xctx) es)) te.ty
    | TERecord fields -> mk (TERecord (List.map (fn (n, e) -> (n, xform_expr xctx e)) fields)) te.ty
    | TERecordUpdate ((base, overrides)) -> 
      let base' = xform_expr xctx base in
      let overrides' = List.map (fn (n, e) -> (n, xform_expr xctx e)) overrides in
      let rec get_row_tail row =
        match Types.rrow_repr row with
        | Types.RRow ((_, _, tail)) -> get_row_tail tail
        | tail -> tail
       in
      let has_evidence =
        match Types.repr base'.ty with
        | Types.TRecord row -> 
          do
            match get_row_tail row with
            | Types.RVar {contents = Types.RUnbound ((id, _))} -> List.exists (fn (rid, _, _) -> rid = id) xctx.xf_record_evidence
            | _ -> false

          end
        | _ -> false
       in
      if has_evidence do
        let row =
          match Types.repr base'.ty with
          | Types.TRecord r -> r
          | _ -> failwith "assert false"
         in
        let rvar_id =
          match get_row_tail row with
          | Types.RVar {contents = Types.RUnbound ((id, _))} -> id
          | _ -> failwith "assert false"
         in
        let idx_val_pairs = List.map (fn (name, e) -> let ev_param = List.find_map (fn (rid, fname, pname) -> if (rid = rvar_id) && (fname = name) do
          Some pname
        else
          None) xctx.xf_record_evidence in
        match ev_param with
        | Some pname -> (mk (TEVar pname) Types.TInt, e)
        | None -> error ($"missing record evidence for field {name}")
        ) overrides' in
        mk (TERecordUpdateIdx (base', idx_val_pairs)) te.ty
      else
        mk (TERecordUpdate (base', overrides')) te.ty
    | TERecordUpdateIdx ((base, pairs)) -> mk (TERecordUpdateIdx (xform_expr xctx base, List.map (fn (i, v) -> (xform_expr xctx i, xform_expr xctx v)) pairs)) te.ty
    | TEField ((e, name)) -> mk (TEField (xform_expr xctx e, name)) te.ty
    | TECons ((hd, tl)) -> mk (TECons (xform_expr xctx hd, xform_expr xctx tl)) te.ty
    | TEConstruct ((name, arg)) -> mk (TEConstruct (name, Option.map (xform_expr xctx) arg)) te.ty
    | TEMatch ((scrutinee, arms, partial)) -> 
      let arms' = List.map (fn (pat, guard, body) -> let pvars = pat_bound_names pat in
      let xctx' = {xctx with xf_locals = List.concat pvars xctx.xf_locals} in
      (pat, Option.map (xform_expr xctx') guard, xform_expr xctx' body)) arms in
      mk (TEMatch (xform_expr xctx scrutinee, arms', partial)) te.ty
    | TEAssign ((name, e)) -> mk (TEAssign (name, xform_expr xctx e)) te.ty
    | TEFieldAssign ((r, f, e)) -> mk (TEFieldAssign (xform_expr xctx r, f, xform_expr xctx e)) te.ty
    | TESeq ((e1, e2)) -> mk (TESeq (xform_expr xctx e1, xform_expr xctx e2)) te.ty
    | TEPerform ((name, e)) -> mk (TEPerform (name, xform_expr xctx e)) te.ty
    | TEHandle ((body, arms)) -> 
      let arms' = List.map (fn arm ->
        do
          match arm with
          | THReturn ((n, e)) -> 
            let xctx' = {xctx with xf_locals = n :: xctx.xf_locals} in
            THReturn (n, xform_expr xctx' e)
          | THOp ((op, p, k, e)) -> 
            let xctx' = {xctx with xf_locals = k :: p :: xctx.xf_locals} in
            THOp (op, p, k, xform_expr xctx' e)

        end) arms in
      mk (TEHandle (xform_expr xctx body, arms')) te.ty
    | TEResume ((k, e)) -> mk (TEResume (xform_expr xctx k, xform_expr xctx e)) te.ty
    | TEMap pairs -> mk (TEMap (List.map (fn (k, v) -> (xform_expr xctx k, xform_expr xctx v)) pairs)) te.ty
    | TEArray es -> mk (TEArray (List.map (xform_expr xctx) es)) te.ty
    | TEIndex ((base, idx)) -> mk (TEIndex (xform_expr xctx base, xform_expr xctx idx)) te.ty
    | TEBreak e -> mk (TEBreak (xform_expr xctx e)) te.ty
    | TEContinueLoop -> te
    | TEFoldContinue e -> mk (TEFoldContinue (xform_expr xctx e)) te.ty
    | TEForLoop e -> mk (TEForLoop (xform_expr xctx e)) te.ty
    | TEReturn e -> mk (TEReturn (xform_expr xctx e)) te.ty
    | TEInt _ | TEFloat _ | TEBool _ | TEString _ | TEByte _ | TERune _ | TEUnit | TENil -> te

  and xform_class_method xctx name te =
    if List.mem name xctx.xf_locals do
      te
    else do
      let (class_opt, method_name) =
        match Types.find_method_class xctx.xf_type_env.classes name with
        | Some _ as result -> (result, name)
        | None -> 
          do
            match String.rindex_opt name #2e with
            | None -> (None, name)
            | Some i -> 
              do
                let mod_prefix = String.sub name 0 (i + 1) in
                let short = String.sub name (i + 1) (((String.length name) - i) - 1) in
                let class_prefix = String.sub name 0 i in
                match Types.find_method_class xctx.xf_type_env.classes short with
                | Some class_def when class_def.class_name = class_prefix -> (Some class_def, short)
                | Some class_def when ((String.length class_def.class_name) > (String.length mod_prefix)) && ((String.sub class_def.class_name 0 (String.length mod_prefix)) = mod_prefix) -> (Some class_def, short)
                | _ -> (None, name)

              end

          end
       in
      match class_opt with
      | Some class_def -> 
        do
          let method_schema_ty = List.assoc method_name class_def.class_methods in
          let is_overridden =
            match List.assoc_opt name xctx.xf_schemes with
            | Some s -> s.body <> method_schema_ty
            | None -> false
           in
          if is_overridden do
            te
          else do
            let num_params = List.length class_def.class_params in
            let found = Hashtbl.create num_params in
            let rec go s r =
              let r = Types.repr r in
              match (s, r) with
              | (Types.TGen i, _) when i < num_params -> 
                if not (Hashtbl.has found i) do
                  Hashtbl.set found i r
                end
              | (Types.TArrow ((s1, _, s2)), Types.TArrow ((r1, _, r2))) | (Types.TCont ((s1, _, s2)), Types.TCont ((r1, _, r2))) -> 
                go s1 r1;
                go s2 r2
              | (Types.TTuple ss, Types.TTuple rs) when (List.length ss) = (List.length rs) -> List.iter2 go ss rs
              | (Types.TList s1, Types.TList r1) -> go s1 r1
              | (Types.TArray s1, Types.TArray r1) -> go s1 r1
              | (Types.TMap ((sk, sv)), Types.TMap ((rk, rv))) -> 
                go sk rk;
                go sv rv
              | (Types.TVariant ((_, ss)), Types.TVariant ((_, rs))) when (List.length ss) = (List.length rs) -> List.iter2 go ss rs
              | _ -> ()
             in
            go method_schema_ty te.ty;
            let constrained_match =
              if xctx.xf_constrained <> [] do
                do
                  let exact_match = List.find_map (fn i ->
                    do
                      match Hashtbl.get found i with
                      | Some (Types.TVar {contents = Types.Unbound ((id, _))}) -> find_constrained_dict xctx id class_def.class_name
                      | _ -> None

                    end) (List.init num_params (fn x -> x)) in
                  match exact_match with
                  | Some _ -> exact_match
                  | None -> 
                    let has_unbound_arg = List.exists (fn i ->
                      do
                        match Hashtbl.get found i with
                        | Some (Types.TVar {contents = Types.Unbound _}) -> true
                        | _ -> false

                      end) (List.init num_params (fn x -> x)) in
                    if has_unbound_arg do
                      do
                        let matching_constraints = List.filter (fn (_tid, _dp, cls) -> cls = class_def.class_name) xctx.xf_constrained in
                        match matching_constraints with
                        | (_tid, dp, _cls) :: [] -> Some dp
                        | _ -> None

                      end
                    else
                      None

                end
              else
                None in
            match constrained_match with
            | Some dp -> mk (TEField (mk (TEVar dp) Types.TUnit, method_name)) te.ty
            | None -> 
              let type_args = List.init num_params (fn i -> Hashtbl.get found i) in
              let partial_args = List.map (fn opt ->
                do
                  match opt with
                  | Some ty -> 
                    do
                      match Types.repr ty with
                      | Types.TVar {contents = Types.Unbound _} -> None
                      | _ -> Some ty

                    end
                  | None -> None

                end) type_args in
              let has_info = List.exists (fn opt -> opt <> None) partial_args in
              if has_info do
                do
                  let matching = List.filter (fn (inst : Types.instance_def) -> (inst.inst_class = class_def.class_name) && (((List.length inst.inst_tys) = (List.length partial_args)) && (Types.match_partial_inst inst.inst_tys partial_args))) xctx.xf_type_env.instances in
                  let all_concrete = List.forall (fn opt -> opt <> None) partial_args in
                  let resolved =
                    match matching with
                    | inst :: [] -> Some inst
                    | _ :: _ -> Types.most_specific_inst matching
                    | [] -> None
                   in
                  match resolved with
                  | Some inst when (inst.inst_constraints <> []) && all_concrete -> 
                    let arg_types = List.filter_map (fn x -> x) type_args in
                    let factory = resolve_factory_dict xctx inst arg_types in
                    mk (TEField (factory, method_name)) te.ty
                  | Some inst when inst.inst_constraints = [] -> mk (TEField (mk (TEVar (inst.inst_dict_name)) Types.TUnit, method_name)) te.ty
                  | _ -> te

                end
              else
                te

          end
        end
      | None -> te

    end
  and xform_constrained_ref xctx name te =
    match List.assoc_opt name xctx.xf_schemes with
    | Some scheme when scheme_needs_xform scheme -> 
      let result = Ref.create te in
      if scheme.constraints <> [] do
        let tgen_map = build_tgen_map scheme.body te.ty in
        let dict_args = List.map (fn cc -> resolve_dict_arg xctx cc tgen_map) scheme.constraints in
        Ref.set result (List.fold (fn fn_ dict_arg -> mk (TEApp (fn_, dict_arg)) Types.TUnit) (Ref.get result) dict_args)
      end;
      if scheme.record_evidences <> [] do
        let rgen_map = build_rgen_map scheme.body te.ty in
        let ev_args = List.concat_map (fn (re : Types.record_evidence) -> resolve_record_evidence_args xctx rgen_map re) scheme.record_evidences in
        Ref.set result (List.fold (fn fn_ ev_arg -> mk (TEApp (fn_, ev_arg)) Types.TUnit) (Ref.get result) ev_args)
      end;
      Ref.get result
    | _ -> te

  and resolve_record_evidence_args xctx rgen_map (re : Types.record_evidence) =
    match Hashtbl.get rgen_map re.re_rgen with
    | Some arow -> 
      do
        let fields = Types.record_row_to_fields arow in
        let sorted_names = List.map fst (List.sort (fn (a, _) (b, _) -> String.compare a b) fields) in
        let rec is_closed r =
          match Types.rrow_repr r with
          | Types.RRow ((_, _, tail)) -> is_closed tail
          | Types.REmpty -> true
          | _ -> false
         in
        if is_closed arow do
          List.map (fn field_name -> let idx = Ref.create (-1) in
          List.iteri (fn i n -> if n = field_name do
            Ref.set idx i
          end) sorted_names;
          if (Ref.get idx) >= 0 do
            mk (TEInt (Ref.get idx)) Types.TInt
          else
            error ($"field {field_name} not found in concrete record for evidence")) re.re_fields
        else do
          let rec get_tail r =
            match Types.rrow_repr r with
            | Types.RRow ((_, _, tail)) -> get_tail tail
            | tail -> tail
           in
          match get_tail arow with
          | Types.RVar {contents = Types.RUnbound ((id, _))} -> List.map (fn field_name ->
            do
              match List.find_map (fn (rid, fname, pname) -> if (rid = id) && (fname = field_name) do
                Some pname
              else
                None) xctx.xf_record_evidence with
              | Some pname -> mk (TEVar pname) Types.TInt
              | None -> error ($"no evidence for field {field_name} in polymorphic context")

            end) re.re_fields
          | _ -> error "expected open row for evidence forwarding"

        end
      end
    | None -> error ($"internal error: no record evidence for fields [{String.concat ", " re.re_fields}]")

  and xform_binop xctx op e1 e2 result_ty =
    let class_info =
      match op with
      | Ast.Add -> Some ("Num", "+")
      | Ast.Sub -> Some ("Num", "-")
      | Ast.Mul -> Some ("Num", "*")
      | Ast.Div -> Some ("Num", "/")
      | Ast.Eq -> Some ("Eq", "=")
      | Ast.Neq -> Some ("Eq", "<>")
      | Ast.Lt -> Some ("Ord", "<")
      | Ast.Gt -> Some ("Ord", ">")
      | Ast.Le -> Some ("Ord", "<=")
      | Ast.Ge -> Some ("Ord", ">=")
      | Ast.Land -> Some ("Bitwise", "land")
      | Ast.Lor -> Some ("Bitwise", "lor")
      | Ast.Lxor -> Some ("Bitwise", "lxor")
      | Ast.Lsl -> Some ("Bitwise", "lsl")
      | Ast.Lsr -> Some ("Bitwise", "lsr")
      | _ -> None
     in
    match class_info with
    | Some ((class_name, method_name)) when xctx.xf_constrained <> [] -> 
      do
        match Types.repr e1.ty with
        | Types.TVar {contents = Types.Unbound ((id, _))} -> 
          do
            match find_constrained_dict xctx id class_name with
            | Some dparam -> 
              let dict_ref = mk (TEVar dparam) Types.TUnit in
              let method_ref = mk (TEField (dict_ref, method_name)) Types.TUnit in
              let app1 = mk (TEApp (method_ref, e1)) Types.TUnit in
              mk (TEApp (app1, e2)) result_ty
            | None -> mk (TEBinop (op, e1, e2)) result_ty

          end
        | _ -> mk (TEBinop (op, e1, e2)) result_ty

      end
    | _ -> mk (TEBinop (op, e1, e2)) result_ty

  and xform_unop xctx op e result_ty =
    let class_info =
      match op with
      | Ast.Neg -> Some ("Num", "negate")
      | _ -> None
     in
    match class_info with
    | Some ((class_name, method_name)) when xctx.xf_constrained <> [] -> 
      do
        match Types.repr e.ty with
        | Types.TVar {contents = Types.Unbound ((id, _))} -> 
          do
            match find_constrained_dict xctx id class_name with
            | Some dparam -> 
              let dict_ref = mk (TEVar dparam) Types.TUnit in
              let method_ref = mk (TEField (dict_ref, method_name)) Types.TUnit in
              mk (TEApp (method_ref, e)) result_ty
            | None -> mk (TEUnop (op, e)) result_ty

          end
        | _ -> mk (TEUnop (op, e)) result_ty

      end
    | _ -> mk (TEUnop (op, e)) result_ty

  and xform_constrained_def xctx scheme te =
    let tgen_map = build_tgen_map scheme.body te.ty in
    let (all_constrained, dict_param_names) = List.fold (fn (entries, params) (cc : Types.class_constraint) -> let tvar_entries = List.filter_map (fn (ca : Types.class_arg) ->
      do
        match ca with
        | CATGen tgen_idx -> 
          do
            match Hashtbl.get tgen_map tgen_idx with
            | Some (Types.TVar {contents = Types.Unbound ((id, _))}) -> Some (id, tgen_idx)
            | _ -> None

          end
        | CATy ty -> 
          do
            match Types.repr ty with
            | Types.TVar {contents = Types.Unbound ((id, _))} -> Some (id, 1000 + id)
            | _ -> None

          end
        | CAWild -> None
        | CAPhantom ((_, tv)) -> 
          do
            match Types.repr tv with
            | Types.TVar {contents = Types.Unbound ((id, _))} -> Some (id, 1000 + id)
            | _ -> None

          end

      end) cc.cc_args in
    match tvar_entries with
    | [] -> 
      let dparam = $"__dict_{cc.cc_class}_resolved_{List.length params}" in
      (entries, dparam :: params)
    | _ -> 
      let dparam = $"__dict_{cc.cc_class}_{String.concat "_" (List.map (fn (_, idx) -> string_of_int idx) tvar_entries)}" in
      let new_entries = List.map (fn (id, _) -> (id, dparam, cc.cc_class)) tvar_entries in
      (List.concat new_entries entries, dparam :: params)
    ) ([], []) scheme.constraints in
    let dict_param_names = List.rev dict_param_names in
    let rgen_map = build_rgen_map scheme.body te.ty in
    let (all_record_ev, ev_param_names) = List.fold (fn (entries, params) (re : Types.record_evidence) -> List.fold (fn (entries, params) field_name -> let pname = $"__ev_{field_name}_r{re.re_rgen}" in
    let rvar_entries =
      match Hashtbl.get rgen_map re.re_rgen with
      | Some arow -> 
        do
          let rec get_tail r =
            match Types.rrow_repr r with
            | Types.RRow ((_, _, tail)) -> get_tail tail
            | tail -> tail
           in
          match get_tail arow with
          | Types.RVar {contents = Types.RUnbound ((id, _))} -> (id, field_name, pname) :: []
          | _ -> []

        end
      | None -> []
     in
    (List.concat rvar_entries entries, pname :: params)) (entries, params) re.re_fields) ([], []) scheme.record_evidences in
    let ev_param_names = List.rev ev_param_names in
    let xctx = {xctx with xf_constrained = List.concat all_constrained xctx.xf_constrained; xf_record_evidence = List.concat all_record_ev xctx.xf_record_evidence} in
    let rewritten = xform_expr xctx te in
    let all_params = List.concat dict_param_names ev_param_names in
    List.fold_right (fn dparam body -> mk (TEFun (dparam, body, false)) (Types.TArrow (Types.TUnit, Types.EffEmpty, body.ty))) all_params rewritten

  pub let xform_constrained_inst xctx inst_def dict_expr =
    let class_def =
      match Types.find_method_class xctx.xf_type_env.classes (fst (List.hd (match dict_expr.expr with
      | TERecord fs -> fs
      | _ -> failwith "assert false"
      ))) with
      | Some cd when cd.class_name = inst_def.inst_class -> cd
      | _ -> 
        do
          match List.find (fn c -> c.class_name = inst_def.inst_class) xctx.xf_type_env.classes with
          | Some cd -> cd
          | None -> error ($"class {inst_def.inst_class} not found")

        end
     in
    let class_param_map = Hashtbl.create 4 in
    let inst_tvar_map = Hashtbl.create 4 in
    do
      match dict_expr.expr with
      | TERecord fields -> 
        List.iter (fn (mname, mte) ->
          do
            match List.assoc_opt mname class_def.class_methods with
            | Some class_method_ty -> 
              let rec walk_class s a =
                let a = Types.repr a in
                match s with
                | Types.TGen i -> 
                  if not (Hashtbl.has class_param_map i) do
                    Hashtbl.set class_param_map i a
                  end
                | Types.TArrow ((s1, _, s2)) -> 
                  do
                    match a with
                    | Types.TArrow ((a1, _, a2)) -> 
                      walk_class s1 a1;
                      walk_class s2 a2
                    | _ -> ()

                  end
                | Types.TCont ((s1, _, s2)) -> 
                  do
                    match a with
                    | Types.TCont ((a1, _, a2)) -> 
                      walk_class s1 a1;
                      walk_class s2 a2
                    | _ -> ()

                  end
                | Types.TTuple ss -> 
                  do
                    match a with
                    | Types.TTuple aa when (List.length ss) = (List.length aa) -> List.iter2 walk_class ss aa
                    | _ -> ()

                  end
                | Types.TList s1 -> 
                  do
                    match a with
                    | Types.TList a1 -> walk_class s1 a1
                    | _ -> ()

                  end
                | Types.TArray s1 -> 
                  do
                    match a with
                    | Types.TArray a1 -> walk_class s1 a1
                    | _ -> ()

                  end
                | Types.TMap ((sk, sv)) -> 
                  do
                    match a with
                    | Types.TMap ((ak, av)) -> 
                      walk_class sk ak;
                      walk_class sv av
                    | _ -> ()

                  end
                | Types.TVariant ((_, ss)) -> 
                  do
                    match a with
                    | Types.TVariant ((_, aa)) when (List.length ss) = (List.length aa) -> List.iter2 walk_class ss aa
                    | _ -> ()

                  end
                | _ -> ()
               in
              walk_class class_method_ty mte.ty
            | None -> ()

          end) fields;
        List.iteri (fn class_idx stored_ty ->
          do
            match Hashtbl.get class_param_map class_idx with
            | Some actual_ty -> 
              let rec walk_inst s a =
                let a = Types.repr a in
                match s with
                | Types.TGen i -> 
                  do
                    if not (Hashtbl.has inst_tvar_map i) do
                      match a with
                      | Types.TVar {contents = Types.Unbound ((id, _))} -> Hashtbl.set inst_tvar_map i id
                      | _ -> ()

                    end
                  end
                | Types.TArrow ((s1, _, s2)) -> 
                  do
                    match a with
                    | Types.TArrow ((a1, _, a2)) -> 
                      walk_inst s1 a1;
                      walk_inst s2 a2
                    | _ -> ()

                  end
                | Types.TCont ((s1, _, s2)) -> 
                  do
                    match a with
                    | Types.TCont ((a1, _, a2)) -> 
                      walk_inst s1 a1;
                      walk_inst s2 a2
                    | _ -> ()

                  end
                | Types.TTuple ss -> 
                  do
                    match a with
                    | Types.TTuple aa when (List.length ss) = (List.length aa) -> List.iter2 walk_inst ss aa
                    | _ -> ()

                  end
                | Types.TList s1 -> 
                  do
                    match a with
                    | Types.TList a1 -> walk_inst s1 a1
                    | _ -> ()

                  end
                | Types.TArray s1 -> 
                  do
                    match a with
                    | Types.TArray a1 -> walk_inst s1 a1
                    | _ -> ()

                  end
                | Types.TMap ((sk, sv)) -> 
                  do
                    match a with
                    | Types.TMap ((ak, av)) -> 
                      walk_inst sk ak;
                      walk_inst sv av
                    | _ -> ()

                  end
                | Types.TVariant ((_, ss)) -> 
                  do
                    match a with
                    | Types.TVariant ((_, aa)) when (List.length ss) = (List.length aa) -> List.iter2 walk_inst ss aa
                    | _ -> ()

                  end
                | _ -> ()
               in
              walk_inst stored_ty actual_ty
            | None -> ()

          end) inst_def.inst_tys
      | _ -> ()

    end;
    let (all_constrained, dict_param_names) = List.fold (fn (entries, params) (cc : Types.class_constraint) -> let tvar_entries = List.filter_map (fn (ca : Types.class_arg) ->
      do
        match ca with
        | CATGen tgen_idx -> 
          do
            match Hashtbl.get inst_tvar_map tgen_idx with
            | Some tvar_id -> Some (tvar_id, tgen_idx)
            | None -> None

          end
        | CATy _ -> None
        | CAWild -> None
        | CAPhantom _ -> None

      end) cc.cc_args in
    match tvar_entries with
    | [] -> (entries, params)
    | _ -> 
      let dparam = $"__dict_{cc.cc_class}_{String.concat "_" (List.map (fn (_, idx) -> string_of_int idx) tvar_entries)}" in
      let new_entries = List.map (fn (id, _) -> (id, dparam, cc.cc_class)) tvar_entries in
      (List.concat new_entries entries, dparam :: params)
    ) ([], []) inst_def.inst_constraints in
    let dict_param_names = List.rev dict_param_names in
    let xctx = {xctx with xf_constrained = List.concat all_constrained xctx.xf_constrained} in
    let rewritten = xform_expr xctx dict_expr in
    List.fold_right (fn dparam body -> mk (TEFun (dparam, body, false)) (Types.TArrow (Types.TUnit, Types.EffEmpty, body.ty))) dict_param_names rewritten

  pub let apply_fundep_improvement type_env vars =
    fn tprog -> List.iter (fn tdecl ->
      do
        match tdecl with
        | TDLet ((_, te)) | TDLetRec ((_, te)) | TDExpr te | TDLetMut ((_, te)) -> improve_fundeps_in_expr vars type_env te
        | TDLetRecAnd bindings -> List.iter (fn (_, te) -> improve_fundeps_in_expr vars type_env te) bindings
        | TDModule ((_, decls)) -> List.iter (fn d ->
          do
            match d with
            | TDLet ((_, te)) | TDLetRec ((_, te)) | TDExpr te | TDLetMut ((_, te)) -> improve_fundeps_in_expr vars type_env te
            | TDLetRecAnd bindings -> List.iter (fn (_, te) -> improve_fundeps_in_expr vars type_env te) bindings
            | _ -> ()

          end) decls
        | _ -> ()

      end) tprog

  pub let transform_constraints ctx (tprog : tprogram) : tprogram =
    apply_fundep_improvement ctx.type_env ctx.vars tprog;
    let xctx = {xf_type_env = ctx.type_env; xf_schemes = ctx.vars; xf_constrained = []; xf_record_evidence = []; xf_locals = []} in
    let xform_decl xctx tdecl =
      match tdecl with
      | TDLet ((name, te)) -> 
        do
          match List.assoc_opt name xctx.xf_schemes with
          | Some scheme when scheme_needs_xform scheme -> TDLet (name, xform_constrained_def xctx scheme te)
          | _ -> 
            do
              let inst = List.find (fn (i : Types.instance_def) -> (i.inst_dict_name = name) && (i.inst_constraints <> [])) xctx.xf_type_env.instances in
              match inst with
              | Some inst_def -> TDLet (name, xform_constrained_inst xctx inst_def te)
              | None -> TDLet (name, xform_expr xctx te)

            end

        end
      | TDLetRec ((name, te)) -> 
        do
          match List.assoc_opt name xctx.xf_schemes with
          | Some scheme when scheme_needs_xform scheme -> TDLetRec (name, xform_constrained_def xctx scheme te)
          | _ -> TDLetRec (name, xform_expr xctx te)

        end
      | TDLetRecAnd bindings -> TDLetRecAnd (List.map (fn (n, te) ->
        do
          match List.assoc_opt n xctx.xf_schemes with
          | Some scheme when scheme_needs_xform scheme -> (n, xform_constrained_def xctx scheme te)
          | _ -> (n, xform_expr xctx te)

        end) bindings)
      | TDExpr te -> TDExpr (xform_expr xctx te)
      | TDLetMut ((name, te)) -> TDLetMut (name, xform_expr xctx te)
      | other -> other
     in
    let decl_names tdecl =
      match tdecl with
      | TDLet ((name, _)) | TDLetRec ((name, _)) | TDLetMut ((name, _)) -> name :: []
      | TDLetRecAnd bindings -> List.map fst bindings
      | _ -> []
     in
    let open_schemes xctx tdecl =
      match tdecl with
      | TDOpen alias_pairs -> List.fold (fn schemes (dst, src) ->
        do
          match List.assoc_opt src schemes with
          | Some scheme -> (dst, scheme) :: schemes
          | None -> schemes

        end) xctx.xf_schemes alias_pairs
      | _ -> xctx.xf_schemes
     in
    let rec xform_decls xctx =
      fn
        | [] -> []
        | tdecl :: rest -> 
          let tdecl' =
            match tdecl with
            | TDModule ((name, decls)) -> TDModule (name, xform_decls xctx decls)
            | _ -> xform_decl xctx tdecl
           in
          let names = decl_names tdecl in
          let xctx' = {xctx with xf_locals = List.concat names xctx.xf_locals; xf_schemes = open_schemes xctx tdecl'} in
          tdecl' :: xform_decls xctx' rest
     in
    xform_decls xctx tprog

  pub let check_program (program : Ast.program) : tprogram * Types.type_env =
    let (ctx, decls) = List.fold (fn (ctx, decls) decl -> let (ctx', tdecls) = check_decl ctx 0 decl in
    (ctx', List.rev_append tdecls decls)) (empty_ctx, []) program in
    (List.rev decls, ctx.type_env)

  pub let check_program_in_ctx (ctx : ctx) (program : Ast.program) : ctx * tprogram =
    let (ctx, decls) = List.fold (fn (ctx, decls) decl -> let (ctx', tdecls) = check_decl ctx 0 decl in
    (ctx', List.rev_append tdecls decls)) (ctx, []) program in
    (ctx, List.rev decls)

end
